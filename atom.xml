<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>白哥的博客</title>
  
  <subtitle>白哥的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-05-10T15:19:42.689Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>白哥</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode127. 单词接龙</title>
    <link href="http://yoursite.com/2019/05/10/leetcode127.%20%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99/"/>
    <id>http://yoursite.com/2019/05/10/leetcode127. 单词接龙/</id>
    <published>2019-05-10T15:08:11.005Z</published>
    <updated>2019-05-10T15:19:42.689Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord<br>的最短转换序列的长度。转换需遵循如下规则：</p><p>每次转换只能改变一个字母。 转换过程中的中间单词必须是字典中的单词。<br><strong>说明:</strong></p><p>如果不存在这样的转换序列，返回 0。 所有单词具有相同的长度。 所有单词只由小写字母组成。 字典中不存在重复的单词。 你可以假设<br>beginWord 和 endWord 是非空的，且二者不相同。<br><strong>示例 1:</strong></p><p><strong>输入:</strong> beginWord = “hit”, endWord = “cog”, wordList = [“hot”,”dot”,”dog”,”lot”,”log”,”cog”]</p><p><strong>输出: 5</strong></p><p><strong>解释:</strong> 一个最短转换序列是 “hit” -&gt; “hot” -&gt; “dot” -&gt; “dog” -&gt; “cog”,<br>     返回它的长度 5。<br><strong>示例 2:</strong></p><p><strong>输入:</strong> beginWord = “hit” endWord = “cog” wordList = [“hot”,”dot”,”dog”,”lot”,”log”]</p><p><strong>输出:</strong> 0</p><p><strong>解释:</strong> endWord “cog” 不在字典中，所以无法进行转换。</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>就是找出图的最短路径，从beginWord出发，找出能到达的点；然后再遍历能到达的点，找到其能到达的点，一直查询直到到达endWord或者全部到达终点即不能再到达其他点。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public int ladderLength(String beginWord, String endWord, List&lt;String&gt; wordList) &#123;</span><br><span class="line">        HashSet&lt;String&gt; wordSet = new HashSet&lt;&gt;(wordList);</span><br><span class="line">        if(!wordSet.contains(endWord)) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        //记录已经使用过的结点</span><br><span class="line">        HashMap&lt;String, Integer&gt; stateMap = new HashMap&lt;&gt;();</span><br><span class="line">        HashSet&lt;String&gt; bs = new HashSet&lt;&gt;();</span><br><span class="line">        bs.add(beginWord);</span><br><span class="line">        Queue&lt;String&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(beginWord);</span><br><span class="line">        //记录原点，并记录路径长度</span><br><span class="line">        stateMap.put(beginWord, 1);</span><br><span class="line">        while(!queue.isEmpty()) &#123;</span><br><span class="line">            String word = queue.poll();</span><br><span class="line">            int level = stateMap.get(word);</span><br><span class="line">            for(int i = 0; i &lt; wordList.size(); i ++) &#123;</span><br><span class="line">                String newWord = wordList.get(i);</span><br><span class="line">                if(helper(word, newWord)) &#123;</span><br><span class="line">                    //已经走过的点的路径就是最短的了 可以直接去掉</span><br><span class="line">                    wordList.remove(i--);</span><br><span class="line">                    if(newWord.equals(endWord)) return level + 1;</span><br><span class="line">                    stateMap.put(newWord, level+1);</span><br><span class="line">                    //把能走的点放入队列，继续判断可到达的点</span><br><span class="line">                    queue.add(newWord);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">public boolean helper(String word, String beginWord) &#123;</span><br><span class="line">int cnt = 0, len = word.length();</span><br><span class="line">for(int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">if(word.charAt(i) != beginWord.charAt(i)) cnt++;</span><br><span class="line">if(cnt &gt; 1) return  false;</span><br><span class="line">&#125;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 277 ms, 在Word Ladder的Java提交中击败了50.48% 的用户<br>内存消耗 : 41.1 MB, 在Word Ladder的Java提交中击败了66.22% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord&lt;
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-B树</title>
    <link href="http://yoursite.com/2019/05/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-B%E6%A0%91/"/>
    <id>http://yoursite.com/2019/05/10/数据结构-B树/</id>
    <published>2019-05-10T08:23:52.696Z</published>
    <updated>2019-05-10T15:19:20.161Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-B树的定义"><a href="#1-B树的定义" class="headerlink" title="1.    B树的定义"></a>1.    B树的定义</h2><p>B树是为磁盘或其他直接存取的辅助存储设备而设计的一种平衡搜索树。<br>一棵B树T是具有以下性质的有根树（根为T.root）：</p><ol><li><p>每个结点x有下面的属性：<br>a)    x.n，当前存储在结点x中的关键字个数。<br>b)    x.n个关键字本身x.key1，x.key2，……，x.keyn，以非降序存放，使得x.key1≤x.key2≤……≤x.keyn。<br>c)    x.leaf，一个布尔值，如果x是叶结点则为true；如果x为内部结点，则为false。</p></li><li><p>每个内部结点x还包含x.n+1个指向其孩子的指针x.c1，x.c2，……，x.cx.n+1。叶结点没有孩子，所以他们的ci属性没有定义。</p></li><li>关键字x.keyi对存储在各子树中的关键字范围加以分割：如果ki为任意一个存储在以x.ci为根的子树中的关键字，那么<br>k1≤x.key1≤k2≤x.key2≤……≤x.keyn≤x.keyn+1<br>即父节点的关键字把子节点的关键字按大小分隔开。</li><li>每个叶结点具有相同的深度，即树的高度h。</li><li>每个结点所包含的关键字个数有上界和下界。用一个被称为B树的最小度数的固定整数t≥2来表示这些界：<br>a)    除了根节点以外的每个结点必须至少有t-1个关键字。因此，除了根节点以外的每个内部结点至少有t个孩子。如果树非空，根结点至少有一个关键字。<br>b)    每个结点至多可包含2t-1个关键字。因此，一个内部结点之多可有2t个孩子。当一个结点恰好有2t-1个关键字是，称该结点是满的。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-B树的定义&quot;&gt;&lt;a href=&quot;#1-B树的定义&quot; class=&quot;headerlink&quot; title=&quot;1.    B树的定义&quot;&gt;&lt;/a&gt;1.    B树的定义&lt;/h2&gt;&lt;p&gt;B树是为磁盘或其他直接存取的辅助存储设备而设计的一种平衡搜索树。&lt;br&gt;一棵B树T是
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>1_Collection接口</title>
    <link href="http://yoursite.com/2019/05/10/1_Collection%E6%8E%A5%E5%8F%A3/"/>
    <id>http://yoursite.com/2019/05/10/1_Collection接口/</id>
    <published>2019-05-10T00:41:14.062Z</published>
    <updated>2019-05-10T00:42:13.011Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-1-List接口"><a href="#1-1-List接口" class="headerlink" title="1.1 List接口"></a>1.1 List接口</h2><h3 id="1-1-1-ArrayList"><a href="#1-1-1-ArrayList" class="headerlink" title="1.1.1 ArrayList"></a>1.1.1 ArrayList</h3><p>1、    实现原理：采用动态数组对象实现，默认构造方法创建了一个空数组<br>2、    第一次添加元素，扩展容量为10，之后的扩充算法：原来数组大小+原来数组的一半<br>3、    不适合进行删除或插入操作<br>4、    为了防止数组动态的扩充次数过多，建议创建ArrayList时，给定初始容量<br>5、    线程不安全，适合在单线程访问时使用</p><h3 id="1-1-2-Vector"><a href="#1-1-2-Vector" class="headerlink" title="1.1.2 Vector"></a>1.1.2 Vector</h3><p>1、    实现原理：采用动态数组对象实现，默认构造方法创建了一个大小为10的对象数组<br>2、    扩充算法：当增量小于等于0时，扩充为原来的2倍，当增量大于0时，扩充为原来数组大小+增量。<br>3、    不适合删除或插入操作。<br>4、    为了防止数组动态的扩充次数过多，建议创建Vector时，给定初始容量<br>5、    线程安全，适合在多线程时访问使用；效率较低。</p><h3 id="1-1-3-LinkedList"><a href="#1-1-3-LinkedList" class="headerlink" title="1.1.3 LinkedList"></a>1.1.3 LinkedList</h3><p>1、    实现原理：采用双向链表结构实现<br>2、    适合插入，删除操作，性能高<br>如何选择List的具体实现？<br>1、    安全性问题<br>2、    是否频繁插入，删除操作（LinkedList）<br>3、    是否是存储后遍历</p><h2 id="1-2-Set接口"><a href="#1-2-Set接口" class="headerlink" title="1.2 Set接口"></a>1.2 Set接口</h2><p>1、    无序的，不保证顺序<br>2、    不允许重复元素</p><h3 id="1-2-1-HashSet"><a href="#1-2-1-HashSet" class="headerlink" title="1.2.1  HashSet"></a>1.2.1  HashSet</h3><p>1、实现原理：基于哈希表（HashMap）实现<br>2、不允许重复，可以有一个null<br>3、不保证顺序恒久不变<br>4、添加元素时，把元素作为HashMap的key，HashMap的value使用一个固定的Object对象<br>5、排除重复元素是通过equals来判断的（关键）<br>6、判断两个对象是否相同，先判断两个对象的hashCode是否相同（如果hashCode相同，不一定是同一个对象，如果不同，则一定不是同一个对象），如果不同，则两个对象不是用一个对象，如果相同，还要进行equals判断，如果相同是同一个对象，如果不同则不是同一个对象<br>7、自定义对象要认为属性值相同时为同一个对象，有这种需求时，那么我们要重写对象所在类的 hashCode和 equas方法</p><h3 id="1-2-2-TreeSet"><a href="#1-2-2-TreeSet" class="headerlink" title="1.2.2  TreeSet"></a>1.2.2  TreeSet</h3><p>1、有序的，基于TreeMap（二叉树结构），对象需要比较大小，通过对象比较器来实现<br>2、对象比较器还可以用来去除重复元素，没有实现比较器接口，将无法添加到TreeSet集合中</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-1-List接口&quot;&gt;&lt;a href=&quot;#1-1-List接口&quot; class=&quot;headerlink&quot; title=&quot;1.1 List接口&quot;&gt;&lt;/a&gt;1.1 List接口&lt;/h2&gt;&lt;h3 id=&quot;1-1-1-ArrayList&quot;&gt;&lt;a href=&quot;#1-1-1-
      
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode120. 三角形最小路径和</title>
    <link href="http://yoursite.com/2019/05/09/leetcode120.%20%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
    <id>http://yoursite.com/2019/05/09/leetcode120. 三角形最小路径和/</id>
    <published>2019-05-09T03:09:24.829Z</published>
    <updated>2019-05-09T11:48:31.336Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><pre><code>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。例如，给定三角形：    [         [2],        [3,4],       [6,5,7],      [4,1,8,3]    ]自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。说明：如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。</code></pre><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p><strong>上一行的点index只能走下一行的index和index+1</strong>这2个下标，所以自底向上的做法来维护一个dp数组，可以得出dp[index] = Math.min(dp[index], dp[index+1]) + list.get(index);<br><strong>下一行的点index只能走上一行的 index-1和index</strong>,所以自顶向下的做法可得出dp[index] = Math.min(dp[index-1], dp[index]) + list.get(index);</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123;</span><br><span class="line">        /**</span><br><span class="line">         * 自顶向下</span><br><span class="line">         */</span><br><span class="line">        int size = triangle.size();</span><br><span class="line">        if(size == 0) return 0;</span><br><span class="line">        int[] dp = new int[size];</span><br><span class="line">        dp[0] = triangle.get(0).get(0);</span><br><span class="line">        //排除后面的数据的干扰</span><br><span class="line">        for(int i = 1; i &lt; size; i ++) &#123;</span><br><span class="line">            dp[i] = Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 1; i &lt; size; i ++) &#123;</span><br><span class="line">            List&lt;Integer&gt; list = triangle.get(i);</span><br><span class="line">            //dp改变后对后面的数据有影响</span><br><span class="line">            int[] tmp = Arrays.copyOf(dp, size);</span><br><span class="line">            for(int j = 0; j &lt;= i; j ++) &#123;</span><br><span class="line">                dp[j] = list.get(j) + (j-1&gt;=0 ? Math.min(tmp[j-1], tmp[j]) : tmp[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //不知道最小的值在哪里 仍需要再遍历一遍数组</span><br><span class="line">        int res = Integer.MAX_VALUE;</span><br><span class="line">        for(int i = 0; i &lt; size; i ++) &#123;</span><br><span class="line">            res = Math.min(dp[i], res);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">        /**</span><br><span class="line">         * 自底向上的做法</span><br><span class="line">         * 直接从后面走到最上面解决</span><br><span class="line">         */</span><br><span class="line">        /*int size = triangle.size();</span><br><span class="line">        if(size == 0) return 0;</span><br><span class="line">        int[] dp = new int[size];</span><br><span class="line">        List&lt;Integer&gt; list = triangle.get(size-1);</span><br><span class="line">        for(int i = 0; i &lt; size; i ++) &#123;</span><br><span class="line">            dp[i] = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = size-2; i &gt;= 0; i --) &#123;</span><br><span class="line">            list = triangle.get(i);</span><br><span class="line">            for(int j = 0; j &lt;= i; j ++) &#123;</span><br><span class="line">                dp[j] = Math.min(dp[j], dp[j+1]) + list.get(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[0];*/</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 4 ms, 在Triangle的Java提交中击败了95.80% 的用户<br>内存消耗 : 35.4 MB, 在Triangle的Java提交中击败了95.85% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。

例如，给定三角形：

    [
   
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode117. 填充每个节点的下一个右侧节点指针 II</title>
    <link href="http://yoursite.com/2019/05/08/leetcode117.%20%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88%20II/"/>
    <id>http://yoursite.com/2019/05/08/leetcode117. 填充每个节点的下一个右侧节点指针 II/</id>
    <published>2019-05-08T13:33:51.544Z</published>
    <updated>2019-05-08T13:33:49.509Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个二叉树</p><pre><code>struct Node {  int val;  Node *left;  Node *right;  Node *next;}</code></pre><p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p><p>初始状态下，所有 next 指针都被设置为 NULL。<br><img src="https://img-blog.csdnimg.cn/20190508212123665.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDQ4NTc0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这题使用队列来解决思路比较清晰，把每一层的结点放入队列中，在每一层的后面放入一个null作为每一层的结束结点，每次都把每一层的前一个结点的next指向下一个即可。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public Node connect(Node root) &#123;</span><br><span class="line">        if(root == null) return null;</span><br><span class="line">        Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        queue.add(null);</span><br><span class="line">        while(!queue.isEmpty()) &#123;</span><br><span class="line">            Node preNode = queue.remove();</span><br><span class="line">            Node nextNode = queue.peek();</span><br><span class="line">            preNode.next = nextNode;</span><br><span class="line">            if(preNode.left != null) queue.add(preNode.left);</span><br><span class="line">            if(preNode.right != null) queue.add(preNode.right);</span><br><span class="line">            if(nextNode == null) &#123;</span><br><span class="line">            //每一层的结束</span><br><span class="line">                queue.remove();</span><br><span class="line">                if(!queue.isEmpty())</span><br><span class="line">                    queue.add(null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 7 ms, 在Populating Next Right Pointers in Each Node II的Java提交中击败了51.00% 的用户<br>内存消耗 : 67.5 MB, 在Populating Next Right Pointers in Each Node II的Java提交中击败了5.12% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个二叉树&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct Node {
  int val;
  Node *l
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode116. 填充每个节点的下一个右侧节点指针</title>
    <link href="http://yoursite.com/2019/05/08/leetcode116.%20%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88/"/>
    <id>http://yoursite.com/2019/05/08/leetcode116. 填充每个节点的下一个右侧节点指针/</id>
    <published>2019-05-08T13:33:34.506Z</published>
    <updated>2019-05-08T13:33:31.701Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p><pre><code>struct Node {  int val;  Node *left;  Node *right;  Node *next;}</code></pre><p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p><p>初始状态下，所有 next 指针都被设置为 NULL。<br><strong>示例：</strong> <img src="https://img-blog.csdnimg.cn/20190508204149742.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDQ4NTc0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>解释：</strong> 给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>左结点的next指向右结点，然后递归调用他们的叶子结点即可。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public Node connect(Node root) &#123;</span><br><span class="line">        if(root == null) return null;</span><br><span class="line">        root.next = null;</span><br><span class="line">        connect(root.left, root.right);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    public void connect(Node left, Node right) &#123;</span><br><span class="line">        if(left == null) return;</span><br><span class="line">        left.next = right;</span><br><span class="line">        connect(left.left, left.right);</span><br><span class="line">        connect(left.right, right.left);</span><br><span class="line">        connect(right.left, right.right);</span><br><span class="line">        right.next = null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 1 ms, 在Populating Next Right Pointers in Each Node的Java提交中击败了86.12% 的用户<br>内存消耗 : 34.8 MB, 在Populating Next Right Pointers in Each Node的Java提交中击败了89.07% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：&lt;/p&gt;
&lt;pre&gt;&lt;co
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode114. 二叉树展开为链表</title>
    <link href="http://yoursite.com/2019/05/08/leetcode114.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2019/05/08/leetcode114. 二叉树展开为链表/</id>
    <published>2019-05-08T13:31:24.045Z</published>
    <updated>2019-05-08T13:33:25.150Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个二叉树，原地将它展开为链表。</p><p>例如，给定二叉树<br><img src="https://img-blog.csdnimg.cn/20190508194419597.png" alt="在这里插入图片描述"> 将其展开为：<br><img src="https://img-blog.csdnimg.cn/20190508194434133.png" alt="在这里插入图片描述"></p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>1.因为其左右子结点的关系很符合栈的先进后出原理，所以可以利用栈，把root右结点先push，然后push左结点；从栈中取出的栈顶元素，如果再push其右结点、左结点，接到root的最右个结点（记得把其左子树置null），直到栈为空即可。<br>2.使用递归方式求解。把左子树的结点接到root的右边，右子树接到左子树的右边，一直递归进行即可。</p><h2 id="思路1代码如下"><a href="#思路1代码如下" class="headerlink" title="思路1代码如下"></a>思路1代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public void flatten(TreeNode root) &#123;</span><br><span class="line">        if(root == null) return;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        //栈先进后出，所以先把右结点push，再push左结点</span><br><span class="line">        if(root.right != null) stack.push(root.right);</span><br><span class="line">        if(root.left != null) stack.push(root.left);</span><br><span class="line">        TreeNode p = root;</span><br><span class="line">        p.left = null;</span><br><span class="line">        while(!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode tn = stack.pop();</span><br><span class="line">            if(tn.right != null) stack.push(tn.right);</span><br><span class="line">            if(tn.left != null) stack.push(tn.left);</span><br><span class="line">            //把结点取出来接到p的右边，然后把取出来的结点的左子树去掉</span><br><span class="line">            p.right = tn;</span><br><span class="line">            p = p.right;</span><br><span class="line">            p.left = null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 4 ms, 在Flatten Binary Tree to Linked List的Java提交中击败了68.62% 的用户<br>内存消耗 : 35.3 MB, 在Flatten Binary Tree to Linked List的Java提交中击败了85.69% 的用户</p><h2 id="思路2代码如下"><a href="#思路2代码如下" class="headerlink" title="思路2代码如下"></a>思路2代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void flatten(TreeNode root) &#123;</span><br><span class="line">    helper(root);</span><br><span class="line">    &#125;</span><br><span class="line">    public TreeNode helper(TreeNode root) &#123;</span><br><span class="line">        if(root == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode left = helper(root.left);</span><br><span class="line">        TreeNode right = helper(root.right);</span><br><span class="line">        if(left != null)&#123;</span><br><span class="line">            root.right = left;</span><br><span class="line">            //left指针走到left&quot;链表&quot;的最后</span><br><span class="line">            while(left.right != null)&#123;</span><br><span class="line">                left = left.right;</span><br><span class="line">            &#125;</span><br><span class="line">            left.right = right;</span><br><span class="line">        &#125;</span><br><span class="line">        //去掉root的左子树</span><br><span class="line">        root.left = null;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果-1"><a href="#提交结果-1" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 2 ms, 在Flatten Binary Tree to Linked List的Java提交中击败了98.12% 的用户<br>内存消耗 : 34.7 MB, 在Flatten Binary Tree to Linked List的Java提交中击败了91.99% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个二叉树，原地将它展开为链表。&lt;/p&gt;
&lt;p&gt;例如，给定二叉树&lt;br&gt;&lt;img src=&quot;https://i
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>apache POI学习</title>
    <link href="http://yoursite.com/2019/05/08/apache%20POI%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2019/05/08/apache POI学习/</id>
    <published>2019-05-08T02:58:04.433Z</published>
    <updated>2019-05-08T10:18:16.040Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-导入包"><a href="#1-导入包" class="headerlink" title="1.导入包"></a>1.导入包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.poi&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;poi&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;3.11&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="2-编写测试代码"><a href="#2-编写测试代码" class="headerlink" title="2.编写测试代码"></a>2.编写测试代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import org.apache.poi.hssf.usermodel.HSSFSheet;</span><br><span class="line">import org.apache.poi.hssf.usermodel.HSSFWorkbook;</span><br><span class="line">import org.apache.poi.ss.usermodel.Cell;</span><br><span class="line">import org.apache.poi.ss.usermodel.Row;</span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">public class POITest &#123;</span><br><span class="line">@Test</span><br><span class="line">public void test() throws FileNotFoundException, IOException &#123;</span><br><span class="line">//定义导入excel文件的路径</span><br><span class="line">String filePath = &quot;D:\\区域导入测试数据.xls&quot;;</span><br><span class="line">//包装一个Excel文件对象</span><br><span class="line">HSSFWorkbook workbook = new HSSFWorkbook(new FileInputStream(new File(filePath)));</span><br><span class="line">//读取Excel文件中的第一个sheet标签</span><br><span class="line">HSSFSheet hssfSheet = workbook.getSheetAt(0);</span><br><span class="line">//遍历标签页中所有的行</span><br><span class="line">for(Row row: hssfSheet) &#123;</span><br><span class="line">//遍历标签行里的所有单元格</span><br><span class="line">for(Cell cell: row) &#123;</span><br><span class="line">//输出单元格中的数据</span><br><span class="line">String val = cell.getStringCellValue();</span><br><span class="line">System.out.print(val);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-运行结果"><a href="#3-运行结果" class="headerlink" title="3.运行结果"></a>3.运行结果</h2><p><img src="https://img-blog.csdnimg.cn/20190508105753168.png" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-导入包&quot;&gt;&lt;a href=&quot;#1-导入包&quot; class=&quot;headerlink&quot; title=&quot;1.导入包&quot;&gt;&lt;/a&gt;1.导入包&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;
      
    
    </summary>
    
      <category term="项目开发" scheme="http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode109. 有序链表转换二叉搜索树</title>
    <link href="http://yoursite.com/2019/05/07/leetcode109.%20%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>http://yoursite.com/2019/05/07/leetcode109. 有序链表转换二叉搜索树/</id>
    <published>2019-05-07T12:42:00.681Z</published>
    <updated>2019-05-07T12:41:54.984Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。</p><p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p><p><strong>示例:</strong></p><p>给定的有序链表： [-10, -3, 0, 5, 9],</p><p>一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：<br><img src="https://img-blog.csdnimg.cn/20190507171848340.png" alt="在这里插入图片描述"></p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>找出list的中间结点list[i]，以其作为根结点，然后把list[0,i)作为其左子树，list[i+1,n]为其右子树，递归建树即可。<br>在找list的中间结点时，我本来是用传入链表长度len参数的方法去找，然后又学习了一种查找list中间指针的方法—<strong>快慢指针</strong>的方法，就是使用2个指针mid,midNext每次<strong>mid走一步，midNext走2步</strong>，等到midNext为空或者midNext.next为空，mid即为中间结点。</p><h2 id="使用len参数的代码"><a href="#使用len参数的代码" class="headerlink" title="使用len参数的代码"></a>使用len参数的代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode sortedListToBST(ListNode head) &#123;</span><br><span class="line">        ListNode p = head;</span><br><span class="line">        int len = 0;</span><br><span class="line">        while (p != null)&#123;</span><br><span class="line">            len++;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        if(len == 0) return null;</span><br><span class="line">        return helper(head, len);</span><br><span class="line">    &#125;</span><br><span class="line">    public TreeNode helper(ListNode head, int len)&#123;</span><br><span class="line">        TreeNode root;</span><br><span class="line">        if(len == 1)&#123;</span><br><span class="line">            root = new TreeNode(head.val);</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line">        if(len &lt; 1)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode p = head;</span><br><span class="line">        //找到中间结点</span><br><span class="line">        for(int i = 1; i &lt; (len+1)/2; i ++)&#123;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        root = new TreeNode(p.val);</span><br><span class="line">        root.right = helper(p.next, len-(len+1)/2);</span><br><span class="line">        p.next = null;</span><br><span class="line">        //-1是去掉中间结点</span><br><span class="line">        root.left = helper(head, (len+1)/2-1);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用快慢指针的方法"><a href="#使用快慢指针的方法" class="headerlink" title="使用快慢指针的方法"></a>使用快慢指针的方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode sortedListToBST(ListNode head) &#123;</span><br><span class="line">        if(head == null || head.next == null)&#123;</span><br><span class="line">            return head == null ? null : new TreeNode(head.val);</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode pre = head, mid = head, midNext = head;</span><br><span class="line">        while(midNext != null &amp;&amp; midNext.next != null)&#123;</span><br><span class="line">            pre = mid;</span><br><span class="line">            mid = mid.next;</span><br><span class="line">            midNext = midNext.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre.next = null;</span><br><span class="line">        TreeNode root = new TreeNode(mid.val);</span><br><span class="line">        root.left = sortedListToBST(head);</span><br><span class="line">        root.right = sortedListToBST(mid.next);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p><img src="https://img-blog.csdnimg.cn/20190507172545934.png" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。&lt;/p&gt;
&lt;p&gt;本题中，一个高度平衡二叉树是
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode106. 从中序与后序遍历序列构造二叉树</title>
    <link href="http://yoursite.com/2019/05/07/leetcode106.%20%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2019/05/07/leetcode106. 从中序与后序遍历序列构造二叉树/</id>
    <published>2019-05-07T03:20:40.826Z</published>
    <updated>2019-05-07T03:20:56.515Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>根据一棵树的中序遍历与后序遍历构造二叉树。</p><p><strong>注意:</strong> 你可以假设树中没有重复的元素。</p><p>例如，给出</p><p>中序遍历 inorder = [9,3,15,20,7] 后序遍历 postorder = [9,15,7,20,3] 返回如下的二叉树：<br><img src="https://img-blog.csdnimg.cn/20190507110245228.png" alt="在这里插入图片描述"></p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>跟使用前序遍历和中序遍历建树一样的思路，就是后序遍历的最后结点为根结点root而已。<br>这题我学习了leetcode上的一个小技巧，在遍历中序遍历的时候从尾遍历，提交结果就快了近10倍，可能是用例问题 <strong>？</strong></p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode buildTree(int[] inorder, int[] postorder) &#123;</span><br><span class="line">        int len = inorder.length;</span><br><span class="line">        if(len == 0) return null;</span><br><span class="line">        return helper(inorder,0,len, postorder,0,len);</span><br><span class="line">    &#125;</span><br><span class="line">    public TreeNode helper(int[] inorder, int inStart, int inEnd, int[] postorder, int postStart, int postEnd) &#123;</span><br><span class="line">        if(postEnd == 0) return null;</span><br><span class="line">        TreeNode root = null;</span><br><span class="line">        int rootVal = postorder[postEnd-1];</span><br><span class="line">        for(int i = inEnd-1; i &gt;= inStart; i --)&#123;</span><br><span class="line">            if(inorder[i] == rootVal)&#123;</span><br><span class="line">                root = new TreeNode(rootVal);</span><br><span class="line">                root.left = helper(inorder, inStart, i, postorder, postStart, postStart+i-inStart);</span><br><span class="line">                root.right = helper(inorder, i+1, inEnd, postorder, postStart+i-inStart, postEnd-1);</span><br><span class="line">                return root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 3 ms, 在Construct Binary Tree from Inorder and Postorder Traversal的Java提交中击败了97.97% 的用户<br>内存消耗 : 35.3 MB, 在Construct Binary Tree from Inorder and Postorder Traversal的Java提交中击败了99.05% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;根据一棵树的中序遍历与后序遍历构造二叉树。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt; 你可以假设树中
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode105. 从前序与中序遍历序列构造二叉树</title>
    <link href="http://yoursite.com/2019/05/07/leetcode105.%20%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2019/05/07/leetcode105. 从前序与中序遍历序列构造二叉树/</id>
    <published>2019-05-07T03:15:07.863Z</published>
    <updated>2019-05-07T03:15:31.091Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>根据一棵树的前序遍历与中序遍历构造二叉树。</p><p><strong>注意:</strong> 你可以假设树中没有重复的元素。</p><p>例如，给出</p><p>前序遍历 preorder = [3,9,20,15,7] 中序遍历 inorder = [9,3,15,20,7]<br>返回如下的二叉树：<br><img src="https://img-blog.csdnimg.cn/2019050710210233.png" alt="在这里插入图片描述"></p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>根据前序遍历和中序遍历的性质，<strong>前序遍历的第一个元素即根</strong>，中序遍历中根的<strong>左边的它的左子树的中序遍历，右边为右子树的中序遍历</strong>，前序遍历中根的后边是它的<strong>左子树+右子树的前序遍历</strong>。<br>所以这就可以使用递归来解决。<br>⒈把前序遍历preorder[preStart, preEnd]第一个元素preorder[preStart]作为根root；<br>⒉在中序遍历inorder[inStart, inEnd]中找到根的下标i；<br>⒊root.left的前序遍历即为preorder[preStart+1, preStart+1+i-inStart),中序遍历为inorder[inStart, i)；<br>（preStart+1即去掉根元素，+i-inStart是由中序遍历计算出左子树的长度。）<br>⒋root.right也同理，注意下标越界的处理即可ac。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode buildTree(int[] preorder, int[] inorder) &#123;</span><br><span class="line">        return helper(preorder, 0, preorder.length, inorder, 0, inorder.length);</span><br><span class="line">    &#125;</span><br><span class="line">    public TreeNode helper(int[] preprder, int preStart, int preEnd, int[] inorder, int inStart, int inEnd)&#123;</span><br><span class="line">        if(preStart &gt;= preprder.length)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        int rootVal = preprder[preStart];</span><br><span class="line">        TreeNode root = null;</span><br><span class="line">        for(int i = inStart; i &lt; inEnd; i ++) &#123;</span><br><span class="line">            if(inorder[i] == rootVal) &#123;</span><br><span class="line">                root = new TreeNode(rootVal);</span><br><span class="line">                root.left = helper(preprder, preStart+1, i+preStart+1-inStart, inorder, inStart, i);</span><br><span class="line">                root.right = helper(preprder, i+preStart+1-inStart, preEnd, inorder, i+1, inEnd);</span><br><span class="line">                return root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 33 ms, 在Construct Binary Tree from Preorder and Inorder Traversal的Java提交中击败了42.18% 的用户<br>内存消耗 : 38.7 MB, 在Construct Binary Tree from Preorder and Inorder Traversal的Java提交中击败了56.29% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;根据一棵树的前序遍历与中序遍历构造二叉树。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt; 你可以假设树中
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode96. 不同的二叉搜索树</title>
    <link href="http://yoursite.com/2019/05/06/leetcode96-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>http://yoursite.com/2019/05/06/leetcode96-不同的二叉搜索树/</id>
    <published>2019-05-06T08:12:28.000Z</published>
    <updated>2019-05-06T08:12:53.475Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？</p><p><strong>示例:</strong></p><p><strong>输入:</strong> 3<br><strong>输出:</strong> 5<br><strong>解释:</strong> 给定 n = 3, 一共有 5 种不同结构的二叉搜索树: <img src="https://img-blog.csdnimg.cn/20190505203055142.png" alt="在这里插入图片描述"></p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>因为1-n中不包含<strong>重复</strong>的结点，所以n个结点所能组成的二叉搜索树的固定个数的，例如（1,2）（2,3）所能组成的二叉搜索树都是2棵。所以这道题就可以直接用动态规划来进行求解了。<br>选定一个结点j，一棵n个结点的二叉搜索树就有<strong>j从0到n,  res += numTrees(j) * numTrees(n-j-1)</strong> 棵子树。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public int numTrees(int n) &#123;</span><br><span class="line">        int[] res = new int[n+1];</span><br><span class="line">        res[0] = 1; res[1] = 1;</span><br><span class="line">        for(int i = 2; i &lt;= n; i ++)&#123;</span><br><span class="line">            for(int j = 0; j &lt; i; j ++)&#123;</span><br><span class="line">                res[i] += res[j] * res[i-j-1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res[n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 1 ms, 在Unique Binary Search Trees的Java提交中击败了20.73% 的用户<br>内存消耗 : 33.2 MB, 在Unique Binary Search Trees的Java提交中击败了9.48% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/st
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode95. 不同的二叉搜索树 II</title>
    <link href="http://yoursite.com/2019/05/05/leetcode95-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-II/"/>
    <id>http://yoursite.com/2019/05/05/leetcode95-不同的二叉搜索树-II/</id>
    <published>2019-05-05T09:45:23.000Z</published>
    <updated>2019-05-05T09:45:50.613Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个整数 n，生成所有由 1 … n 为节点所组成的二叉搜索树。</p><p><strong>示例:</strong></p><p><strong>输入:</strong> 3<br> <strong>输出:</strong> [   [1,null,3,2],   [3,2,null,1],   [3,1,null,null,2],<br>[2,1,3],   [1,null,2,null,3] ]<br><strong>解释:</strong> 以上的输出对应以下 5 种不同结构的二叉搜索树：<br><img src="https://img-blog.csdnimg.cn/20190505172755456.png" alt="在这里插入图片描述"></p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>使用分治+递归的方法建树，<strong>[1,n]中取k(1&lt;=k&lt;=n)为根节点，则他的左子树必定为[1,k-1]，右子树为[k+1,n]</strong>，所以递归调用建树的方法，最后把他所有的左右子树整合在一起。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;TreeNode&gt; generateTrees(int n) &#123;</span><br><span class="line">        if(n == 0) return new ArrayList&lt;&gt;();</span><br><span class="line">        return generateTreeHelper(1,n);</span><br><span class="line">    &#125;</span><br><span class="line">    public List&lt;TreeNode&gt; generateTreeHelper(int i, int j)&#123;</span><br><span class="line">        List&lt;TreeNode&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">        //i&gt;j返回一个空的子树</span><br><span class="line">        if(i &gt; j) &#123;</span><br><span class="line">            res.add(null);</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        //i==j返回一个结点的子树</span><br><span class="line">        if(i == j)&#123;</span><br><span class="line">            res.add(new TreeNode(i));</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        //分治+递归建树</span><br><span class="line">        for(int k = i; k &lt;= j; k++)&#123;</span><br><span class="line">            List&lt;TreeNode&gt; left = generateTreeHelper(i,k-1);</span><br><span class="line">            List&lt;TreeNode&gt; right = generateTreeHelper(k+1,j);</span><br><span class="line">            for(TreeNode tmpR: right)&#123;</span><br><span class="line">                for(TreeNode tmpL: left)&#123;</span><br><span class="line">                    TreeNode tn = new TreeNode(k);</span><br><span class="line">                    tn.left = tmpL;</span><br><span class="line">                    tn.right = tmpR;</span><br><span class="line">                    res.add(tn);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 5 ms, 在Unique Binary Search Trees II的Java提交中击败了66.57% 的用户<br>内存消耗 : 38.8 MB, 在Unique Binary Search Trees II的Java提交中击败了68.05% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个整数 n，生成所有由 1 … n 为节点所组成的二叉搜索树。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/st
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode93. 复原IP地址</title>
    <link href="http://yoursite.com/2019/05/05/leetcode93-%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80/"/>
    <id>http://yoursite.com/2019/05/05/leetcode93-复原IP地址/</id>
    <published>2019-05-05T09:35:00.000Z</published>
    <updated>2019-05-05T09:45:10.830Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。</p><p><strong>示例:</strong></p><p><strong>输入:</strong> “25525511135”<br><strong>输出:</strong> [“255.255.11.135”, “255.255.111.35”]</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>记录每次放入的ip节，对字符串其进行回溯，即每次放入前1-3个数字，一直深度即可。<br>需要注意的是：<br>1.如果第1个数字是0的话可以直接剪枝（必须，不然会解答错误，因为ip节可能出现00这种情况）。<br>2.如果s的长度大于还未放入的ip节数*3可以剪枝。<br>3.放入4个之后即count==0，如果s不为空，则不用继续深度搜索。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//93. 复原IP地址</span><br><span class="line">    public List&lt;String&gt; restoreIpAddresses(String s) &#123;</span><br><span class="line">        ArrayList&lt;String&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">        dfs(res, 4, s, new StringBuilder(16));</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public void dfs(List&lt;String&gt; list, int count, String s, StringBuilder ip)&#123;</span><br><span class="line">//        大于最大的长度</span><br><span class="line">        if(s.length() &gt; 3 * count) return;</span><br><span class="line">        //ip中已经放入4个时</span><br><span class="line">        if(count == 0)&#123;</span><br><span class="line">            if(s.isEmpty()) &#123;</span><br><span class="line">                //去掉最后多的“”&quot;.&quot;</span><br><span class="line">                list.add(ip.substring(0,ip.length()-1));</span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 1; i &lt;= 3 &amp;&amp; i &lt;= s.length(); i ++)&#123;</span><br><span class="line">            String tmp  = s.substring(0,i);</span><br><span class="line">            if(Integer.parseInt(tmp) &lt;= 255)&#123;</span><br><span class="line">                int len = ip.length();</span><br><span class="line">                ip.append(tmp);</span><br><span class="line">                ip.append(&quot;.&quot;);</span><br><span class="line">                dfs(list, count-1, s.substring(i), ip);</span><br><span class="line">                ip.delete(len, ip.length());</span><br><span class="line">                if(tmp.equals(&quot;0&quot;))&#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 5 ms, 在Restore IP Addresses的Java提交中击败了73.10% 的用户<br>内存消耗 : 35.2 MB, 在Restore IP Addresses的Java提交中击败了77.65% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/st
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title> leetcode反转链表2</title>
    <link href="http://yoursite.com/2019/05/05/leetcode%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A82/"/>
    <id>http://yoursite.com/2019/05/05/leetcode反转链表2/</id>
    <published>2019-05-05T09:34:54.000Z</published>
    <updated>2019-05-05T09:44:58.776Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。</p><p><strong>说明:</strong> 1 ≤ m ≤ n ≤ 链表长度。</p><p><strong>示例:</strong></p><p><strong>输入:</strong> 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4<br><strong>输出:</strong> 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>把前面的结点直接接到新链表后面，最后一个结点为<strong>index</strong>，需要反转的结点依次<strong>插入到index后面</strong>，即 <strong>p.next = index.next;           index.next = p;</strong>最后把剩下的结点放到第一个插入index后面的结点即可。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public ListNode reverseBetween(ListNode head, int m, int n) &#123;</span><br><span class="line">        ListNode resList = new ListNode(0);</span><br><span class="line">        ListNode p = head;</span><br><span class="line">        ListNode index = resList;</span><br><span class="line">        //不用反转的结点</span><br><span class="line">        for(int i = 1; i &lt; m; i ++) &#123;</span><br><span class="line">            index.next = p;</span><br><span class="line">            p = p.next;</span><br><span class="line">            index = index.next;</span><br><span class="line">        &#125;</span><br><span class="line">        //需要反转的第一个结点</span><br><span class="line">        ListNode next = index.next;</span><br><span class="line">        next = p;</span><br><span class="line">        p = p.next;</span><br><span class="line">        index.next = next;</span><br><span class="line">        if(p == null) return resList.next;</span><br><span class="line">        ListNode q = p.next;</span><br><span class="line">        //其他结点放在第一个结点之后</span><br><span class="line">        for(int i = m; i &lt; n; i ++) &#123;</span><br><span class="line">            p.next = index.next;</span><br><span class="line">            index.next = p;</span><br><span class="line">            p = q;</span><br><span class="line">            if(q != null) q = q.next;</span><br><span class="line">        &#125;</span><br><span class="line">        //把剩下的结点接上去</span><br><span class="line">        next.next = p;</span><br><span class="line">        return resList.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 1 ms, 在Reverse Linked List II的Java提交中击败了94.17% 的用户<br>内存消耗 : 33.8 MB, 在Reverse Linked List II的Java提交中击败了92.92% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt; 
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode90. 子集 II</title>
    <link href="http://yoursite.com/2019/05/04/leetcode90-%E5%AD%90%E9%9B%86-II/"/>
    <id>http://yoursite.com/2019/05/04/leetcode90-子集-II/</id>
    <published>2019-05-04T13:33:52.000Z</published>
    <updated>2019-05-04T13:34:04.024Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</p><p><strong>说明：</strong> 解集不能包含重复的子集。</p><p><strong>示例:</strong></p><p><strong>输入:</strong> [1,2,2]<br><strong>输出:</strong><br>[<br>  [2],<br>  [1],<br>  [1,2,2],<br>  [2,2],<br>  [1,2],<br>  []<br>]</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>先排列数组，再遍历数组，每遍历到一个元素，就把链表的元素取出来复制，都加上这个元素再放回结果链表，重复的不放入结果链表即可。可以直接用链表的contains方法，也可以使用下标记录。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><pre><code>class Solution {    public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) {        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;();        Arrays.sort(nums);        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();        res.add(list);        int l, r, len = 0;        for(int i = 0; i &lt; nums.length; i ++) {            r = res.size();            //减去上一次新增的链表数量，即上一次增加的链表才需要取出来            if(i != 0 &amp;&amp; nums[i] == nums[i-1]) l = r-len;            //不是重复的则res的所有都需要拿出来            else l = 0;            //新增的链表数量            len = r - l;            for(int j = l; j &lt; r; j ++) {                list = new ArrayList&lt;&gt;(res.get(j));                list.add(nums[i]);                res.add(list);            }        }        return res;        }}</code></pre><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 3 ms, 在Subsets II的Java提交中击败了94.02% 的用户<br>内存消耗 : 38 MB, 在Subsets II的Java提交中击败了60.93% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt; 解
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>
leetcode82. 删除排序链表中的重复元素 II</title>
    <link href="http://yoursite.com/2019/04/30/leetcode82-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0-II/"/>
    <id>http://yoursite.com/2019/04/30/leetcode82-删除排序链表中的重复元素-II/</id>
    <published>2019-04-30T13:05:22.000Z</published>
    <updated>2019-04-30T13:05:49.598Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。</p><p><strong>示例 1:</strong></p><p><strong>输入:</strong> 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5<br><strong>输出:</strong> 1-&gt;2-&gt;5<br><strong>示例 2:</strong></p><p><strong>输入:</strong> 1-&gt;1-&gt;1-&gt;2-&gt;3<br><strong>输出:</strong> 2-&gt;3</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>使用双指针，判断结点是否重复，不重复则加入链表，重复则跳过即可。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode deleteDuplicates(ListNode head) &#123;</span><br><span class="line">        if(head == null) return null;</span><br><span class="line">if(head.next == null) return head;</span><br><span class="line">ListNode root = new ListNode(0);</span><br><span class="line">ListNode index = root;//合适的结点放入的位置</span><br><span class="line">ListNode p = head;</span><br><span class="line">ListNode q = head.next;</span><br><span class="line">while(q != null) &#123;</span><br><span class="line">while(q!=null &amp;&amp; p.val == q.val) &#123;</span><br><span class="line">q = q.next;</span><br><span class="line">&#125; </span><br><span class="line">            if(q == null)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">if(p.next == q) &#123;</span><br><span class="line">index.next = p;</span><br><span class="line">index = index.next;</span><br><span class="line">&#125;</span><br><span class="line">if(q.next == null) &#123;</span><br><span class="line">index.next = q;</span><br><span class="line">index = index.next;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">p = q;</span><br><span class="line">q = q.next;</span><br><span class="line">&#125;</span><br><span class="line">index.next = null;//去掉尾巴</span><br><span class="line">return root.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 2 ms, 在Remove Duplicates from Sorted List II的Java提交中击败了80.87% 的用户<br>内存消耗 : 36 MB, 在Remove Duplicates from Sorted List II的Java提交中击败了73.50% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。&lt;/p&gt;
&lt;p&gt;&lt;stron
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode81. 搜索旋转排序数组 II</title>
    <link href="http://yoursite.com/2019/04/29/leetcode81-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84-II/"/>
    <id>http://yoursite.com/2019/04/29/leetcode81-搜索旋转排序数组-II/</id>
    <published>2019-04-29T03:46:44.000Z</published>
    <updated>2019-04-29T03:46:51.400Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。</p><p>编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。</p><p><strong>示例 1:</strong></p><p><strong>输入:</strong> nums = [2,5,6,0,0,1,2], target = 0<br><strong>输出:</strong> true<br><strong>示例 2:</strong></p><p><strong>输入:</strong> nums = [2,5,6,0,0,1,2], target = 3<br><strong>输出:</strong> false</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>使用二分查找，先判断nums[mid]在旋转点的左侧或者右侧，即 <strong>nums[mid] &lt;= nums[high]</strong> 则在右侧；<strong>nums[mid] &gt;= nums[low]</strong> 则在左侧。<br>在右侧时，如果 <strong>target &gt; nums[mid] &amp;&amp; target &lt;= nums[high]</strong> target只可能在区间[mid+1, high]中；否则，target只能在区间[low,mid-1]中。<br>左侧也同理，如果 <strong>target &lt; nums[mid] &amp;&amp; target &gt;= nums[low]</strong> target只可能在区间[low, mid-1]中；否则只能在[mid+1, high]中。<br>最后的一点就是在判断nums[mid]在旋转点哪一侧时，如果有重复的数字，会导致判断错误，例如<strong>nums={1,1,3,1}，target = 3；</strong>  无法判断nums[mid]在哪一侧。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean search(int[] nums, int target) &#123;</span><br><span class="line">        if(nums == null || nums.length &lt; 1) return false;</span><br><span class="line">int low = 0, high = nums.length-1;</span><br><span class="line">while(low &lt;= high) &#123;</span><br><span class="line">//去掉重复的点，不然在下面的判断mid在旋转点左右侧会有影响 如&#123;1,1,3,1&#125;则无法判断mid的位置</span><br><span class="line">while(low+1 &lt;= high &amp;&amp; nums[low+1] == nums[low]) low++;</span><br><span class="line">while(high-1 &gt;= low &amp;&amp; nums[high-1] == nums[high]) high--;</span><br><span class="line">int mid = (low + high) &gt;&gt; 1;</span><br><span class="line">if(target == nums[mid])&#123;</span><br><span class="line">return true;</span><br><span class="line">&#125; else if(nums[mid] &lt;= nums[high]) &#123;</span><br><span class="line">//mid在旋转点右边</span><br><span class="line">if(target &gt; nums[mid] &amp;&amp; target &lt;= nums[high]) &#123;</span><br><span class="line">low = mid + 1;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">high = mid - 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125; else if(nums[mid] &gt;= nums[low]) &#123;</span><br><span class="line">//mid在旋转点左边</span><br><span class="line">if(target &lt; nums[mid] &amp;&amp; target &gt;= nums[low]) &#123;</span><br><span class="line">high = mid - 1;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">low = mid + 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 2 ms, 在Search in Rotated Sorted Array II的Java提交中击败了91.00% 的用户<br>内存消耗 : 37.4 MB, 在Search in Rotated Sorted Array II的Java提交中击败了52.09% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;假设按照升序排序的数组在预先未知的某个点上进行了旋转。&lt;/p&gt;
&lt;p&gt;( 例如，数组 [0,0,1,2,2,5,6
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode80. 删除排序数组中的重复项 II</title>
    <link href="http://yoursite.com/2019/04/29/leetcode80-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9-II/"/>
    <id>http://yoursite.com/2019/04/29/leetcode80-删除排序数组中的重复项-II/</id>
    <published>2019-04-29T03:46:08.000Z</published>
    <updated>2019-04-29T03:46:26.871Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p><p><strong>示例 1:</strong></p><p>给定 nums = [1,1,1,2,2,3],</p><p>函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。</p><p>你不需要考虑数组中超出新长度后面的元素。<br><strong>示例 2:</strong></p><p>给定 nums = [0,0,1,1,1,1,2,3,3],</p><p>函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。</p><p>你不需要考虑数组中超出新长度后面的元素。<br><strong>说明:</strong></p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><p>// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝 int len = removeDuplicates(nums);</p><p>// 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。 for (int<br>i = 0; i &lt; len; i++) {<br>    print(nums[i]); }</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>定义一个变量cnt计算当前数字的个数，用一个指针表示符合的元素的位置（最后返回的长度），另一个指针则遍历数组。<br>如果<strong>nums[i-1] == nums[i] &amp;&amp; cnt==2</strong>则直接说明这个元素已经放入2个了，直接继续；<br>如果<strong>nums[i-1] == nums[i] &amp;&amp; cnt == 1</strong>则把元素放到nums[index]，cnt+1；<br>其他的直接放到nums[index]并把cnt置1。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int removeDuplicates(int[] nums) &#123;</span><br><span class="line">        if(nums.length == 0) return 0;</span><br><span class="line">if(nums.length == 1) return 1;</span><br><span class="line">        int index = 1, cnt = 1;</span><br><span class="line">        for(int i = 1; i &lt; nums.length; i ++) &#123;</span><br><span class="line">        if(nums[i-1] == nums[i] &amp;&amp; cnt == 2) &#123;</span><br><span class="line">                ;</span><br><span class="line">        &#125; else if(nums[i-1] == nums[i] &amp;&amp; cnt == 1) &#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        nums[index++] = nums[i];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        cnt = 1;</span><br><span class="line">        nums[index++] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 2 ms, 在Remove Duplicates from Sorted Array II的Java提交中击败了98.91% 的用户<br>内存消耗 : 37.9 MB, 在Remove Duplicates from Sorted Array II的Java提交中击败了90.08% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。&lt;/p&gt;
&lt;p
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode79. 单词搜索</title>
    <link href="http://yoursite.com/2019/04/29/leetcode79-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/"/>
    <id>http://yoursite.com/2019/04/29/leetcode79-单词搜索/</id>
    <published>2019-04-29T03:45:59.000Z</published>
    <updated>2019-04-29T03:46:17.102Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个二维网格和一个单词，找出该单词是否存在于网格中。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。<br><strong>示例:</strong> board = [   [‘A’,’B’,’C’,’E’],   [‘S’,’F’,’C’,’S’],   [‘A’,’D’,’E’,’E’] ] 给定 word = “ABCCED”, 返回 true. 给定 word = “SEE”, 返回<br>true. 给定 word = “ABCB”, 返回 false.</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>使用深度搜索，遍历数组，如果是word的第一个字符，则进行深度查找，每次都判断上下左右是否符合下一个字符，注意好<strong>下标越界问题</strong>和<strong>判断这个位置是否走过</strong>就好了。不走重复位置的话，我是把board[i][j] 设为0。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean exist(char[][] board, String word) &#123;</span><br><span class="line">        for(int i = 0; i &lt; board.length; i ++) &#123;</span><br><span class="line">        for(int j = 0; j &lt; board[0].length; j++) &#123;</span><br><span class="line">        if(board[i][j] != word.charAt(0)) continue;</span><br><span class="line">        if(dfs(board, word, i, j, 0)) &#123;</span><br><span class="line">        return true;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">public boolean dfs(char[][] board,  String word, int i, int j, int index) &#123;</span><br><span class="line">if(word.length() == index) &#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">if(i &gt;= board.length || i &lt; 0 || j &lt; 0 || j &gt;= board[0].length || board[i][j] == &apos;0&apos;) &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">if(board[i][j] == word.charAt(index)) &#123;</span><br><span class="line">char tmp = board[i][j];</span><br><span class="line">board[i][j] = &apos;0&apos;;</span><br><span class="line">if(dfs(board, word, i+1, j, index+1) </span><br><span class="line">|| dfs(board, word, i-1, j, index+1)</span><br><span class="line">|| dfs(board, word, i, j+1, index+1)</span><br><span class="line">|| dfs(board, word, i, j-1, index+1)) &#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">board[i][j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 12 ms, 在Word Search的Java提交中击败了75.59% 的用户<br>内存消耗 : 43.6 MB, 在Word Search的Java提交中击败了83.83% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个二维网格和一个单词，找出该单词是否存在于网格中。&lt;/p&gt;
&lt;p&gt;单词必须按照字母顺序，通过相邻的单元格内的
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
</feed>
