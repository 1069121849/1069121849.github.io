<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>白哥的博客</title>
  
  <subtitle>白哥的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-07-09T15:01:16.748Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>白哥</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode318. 最大单词长度乘积</title>
    <link href="http://yoursite.com/2019/07/09/leetcode318.%20%E6%9C%80%E5%A4%A7%E5%8D%95%E8%AF%8D%E9%95%BF%E5%BA%A6%E4%B9%98%E7%A7%AF/"/>
    <id>http://yoursite.com/2019/07/09/leetcode318. 最大单词长度乘积/</id>
    <published>2019-07-09T11:27:25.017Z</published>
    <updated>2019-07-09T15:01:16.748Z</updated>
    
    <content type="html"><![CDATA[<p>﻿## 题目</p><blockquote><p>给定一个字符串数组 words，找到 length(word[i]) * length(word[j])<br>的最大值，并且这两个单词不含有公共字母。你可以认为每个单词只包含小写字母。如果不存在这样的两个单词，返回 0。</p><p><strong>示例 1:</strong></p><p><strong>输入:</strong> [“abcw”,”baz”,”foo”,”bar”,”xtfn”,”abcdef”]<br><strong>输出:</strong> 16  解释: 这两个单词为 “abcw”, “xtfn”。<br><strong>示例 2:</strong></p><p><strong>输入:</strong> [“a”,”ab”,”abc”,”d”,”cd”,”bcd”,”abcd”]<br><strong>输出:</strong> 4<br><strong>解释:</strong> 这两个单词为 “ab”, “cd”。<br><strong>示例 3:</strong></p><p><strong>输入:</strong> [“a”,”aa”,”aaa”,”aaaa”]<br><strong>输出:</strong> 0<br><strong>解释:</strong> 不存在这样的两个单词。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/maximum-product-of-word-lengths" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-product-of-word-lengths</a></p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>第一步：判断2个单词是否存在相同的字符<br>第二步：计算所有的2个字符长度相乘结果，得出最长的结果</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxProduct(String[] words) &#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        int[] val = new int[words.length];</span><br><span class="line">        for (int i = 0; i &lt; val.length; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; words[i].length(); j++) &#123;</span><br><span class="line">                val[i] |= 1 &lt;&lt; words[i].charAt(j)-&apos;a&apos;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; words.length; i++) &#123;</span><br><span class="line">            for (int j = i + 1; j &lt; words.length; j++) &#123;</span><br><span class="line">                if ((val[i] &amp; val[j]) &gt; 0) continue;</span><br><span class="line">                    res = Math.max(res, words[i].length() * words[j].length());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p><img src="https://img-blog.csdnimg.cn/20190709192712578.png" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;﻿## 题目&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个字符串数组 words，找到 length(word[i]) * length(word[j])&lt;br&gt;的最大值，并且这两个单词不含有公共字母。你可以认为每个单词只包含小写字母。如果不存在这样的两个单词，返回 0
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode313. 超级丑数</title>
    <link href="http://yoursite.com/2019/07/07/leetcode313.%20%E8%B6%85%E7%BA%A7%E4%B8%91%E6%95%B0/"/>
    <id>http://yoursite.com/2019/07/07/leetcode313. 超级丑数/</id>
    <published>2019-07-07T09:10:11.116Z</published>
    <updated>2019-07-07T09:10:03.659Z</updated>
    
    <content type="html"><![CDATA[<p>﻿## 题目</p><blockquote><p>编写一段程序来查找第 n 个超级丑数。</p><p>超级丑数是指其所有质因数都是长度为 k 的质数列表 primes 中的正整数。</p><p><strong>示例:</strong></p><p><strong>输入:</strong> n = 12, primes = [2,7,13,19]<br><strong>输出:</strong> 32<br><strong>解释:</strong> 给定长度为 4 的质数列表 primes = [2,7,13,19]，前 12 个超级丑数序列为：[1,2,4,7,8,13,14,16,19,26,28,32] 。<br><strong>说明:</strong></p><p>1 是任何给定 primes 的超级丑数。  给定 primes 中的数字以升序排列。 0 &lt; k ≤ 100, 0 &lt; n ≤ 106,<br>0 &lt; primes[i] &lt; 1000 。 第 n 个超级丑数确保在 32 位有符整数范围内。</p><p>来源：力扣（LeetCode） 链接：<a href="https://leetcode-cn.com/problems/super-ugly-number" target="_blank" rel="noopener">https://leetcode-cn.com/problems/super-ugly-number</a></p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>第一步：根据超级丑数都是质数相乘而来，定义一个结果数组res，res[0]=1；<br>第二步：为每个质数记录一个下标，<strong>该小标表示：乘对应质数能得到的最小值的下标</strong>；<br>第三步：比较所有质数所能得到最小值，得出最小的一个，取出；一直查找直到找到第n个。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int nthSuperUglyNumber(int n, int[] primes) &#123;</span><br><span class="line">        int[] res = new int[n];</span><br><span class="line">        //存储对应质数所到达的下标</span><br><span class="line">        int[] indexs = new int[primes.length];</span><br><span class="line">        res[0] = 1;</span><br><span class="line">        for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">            int min = Integer.MAX_VALUE;</span><br><span class="line">            for (int j = 0; j &lt; primes.length; j++) &#123;</span><br><span class="line">                if (primes[j] * res[indexs[j]] &lt; min) &#123;</span><br><span class="line">                    min = primes[j] * res[indexs[j]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res[i] = min;</span><br><span class="line">            //因为得到最小的可能有多个值，所以把全部可达最小值的质数对应下标加一</span><br><span class="line">            for (int j = 0; j &lt; primes.length; j++) &#123;</span><br><span class="line">                if (primes[j] * res[indexs[j]] == min) &#123;</span><br><span class="line">                    indexs[j]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res[n-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p><img src="https://img-blog.csdnimg.cn/2019070711462681.png" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;﻿## 题目&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;编写一段程序来查找第 n 个超级丑数。&lt;/p&gt;
&lt;p&gt;超级丑数是指其所有质因数都是长度为 k 的质数列表 primes 中的正整数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>java异常</title>
    <link href="http://yoursite.com/2019/07/06/Java%E5%BC%82%E5%B8%B8/"/>
    <id>http://yoursite.com/2019/07/06/Java异常/</id>
    <published>2019-07-06T02:20:08.924Z</published>
    <updated>2019-07-06T02:21:16.453Z</updated>
    
    <content type="html"><![CDATA[<p>﻿## Error和Exception的区别</p><h3 id="从概念角度解析java的异常处理机制"><a href="#从概念角度解析java的异常处理机制" class="headerlink" title="从概念角度解析java的异常处理机制"></a>从概念角度解析java的异常处理机制</h3><ul><li>Error：程序无法处理的系统错误，编译器不做坚持</li><li>Exception：程序可以处理的异常，捕获后可能恢复</li></ul><h3 id="Java的异常体系"><a href="#Java的异常体系" class="headerlink" title="Java的异常体系"></a>Java的异常体系</h3><p>从责任角度看：</p><ol><li>Error属于JVM需要负担的责任</li><li>RuntimeException是程序应该负担的责任</li><li>CheckedException可检测异常是Java编译器应该承担的责任</li></ol><p>Check Exception必须try catch或者抛出</p><p>抛出错误之后就结束程序运行</p><h2 id="常见Error以及Exception"><a href="#常见Error以及Exception" class="headerlink" title="常见Error以及Exception"></a>常见Error以及Exception</h2><h3 id="RuntimeException"><a href="#RuntimeException" class="headerlink" title="RuntimeException"></a>RuntimeException</h3><ol><li>NullPointException - 空指针引用异常</li><li>ClassCastException - 类型强制转换异常</li><li>IllegalArgumentException - 传递非法参数异常</li><li>IndexOutOfBoundsException - 下标越界异常</li><li>NumberFormatException - 数字格式异常</li></ol><h3 id="非RuntimeException"><a href="#非RuntimeException" class="headerlink" title="非RuntimeException"></a>非RuntimeException</h3><ol><li>ClassNotFoundException - 找不到指定clas的异常</li><li>IOException - IO操作异常</li></ol><h3 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h3><ol><li>NoClassDefFoundError - 找不到class定义的异常</li><li>StackOverflowError - 深度递归导致栈被耗尽而抛出的异常</li><li>OutOfMemoryError - 内存溢出异常</li></ol><p>NoClassDefFoundError的成因</p><ol><li>类依赖的class或者jar不存在</li><li>类文件存在，但是存在不同的域中</li><li>大小写问题，javac编译的时候是无视大小写的，很有可能编译出来的class文件就与想要的不一样</li></ol><h2 id="Java的异常处理机制"><a href="#Java的异常处理机制" class="headerlink" title="Java的异常处理机制"></a>Java的异常处理机制</h2><ul><li>抛出异常：创建异常对象，交由运行时系统处理</li><li>捕获异常：寻找合适的异常处理器处理异常，否则终止运行</li></ul><h3 id="Java异常处理消耗性能的地方"><a href="#Java异常处理消耗性能的地方" class="headerlink" title="Java异常处理消耗性能的地方"></a>Java异常处理消耗性能的地方</h3><ul><li>try-catch块影响JVM的优化</li><li>异常对象实例需要保存栈快照等信息，开销较大</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;﻿## Error和Exception的区别&lt;/p&gt;
&lt;h3 id=&quot;从概念角度解析java的异常处理机制&quot;&gt;&lt;a href=&quot;#从概念角度解析java的异常处理机制&quot; class=&quot;headerlink&quot; title=&quot;从概念角度解析java的异常处理机制&quot;&gt;&lt;/a&gt;从概
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Linux学习笔记</title>
    <link href="http://yoursite.com/2019/07/05/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%A4%A7%E4%B8%89%E6%9C%9F%E6%9C%AB/"/>
    <id>http://yoursite.com/2019/07/05/Linux学习笔记-大三期末/</id>
    <published>2019-07-05T01:51:32.130Z</published>
    <updated>2019-07-05T01:52:51.241Z</updated>
    
    <content type="html"><![CDATA[<p>﻿# Linux学习笔记</p><h2 id="Linux简介"><a href="#Linux简介" class="headerlink" title="Linux简介"></a>Linux简介</h2><p>Ken Thompson 与Dennis Ritchle用C语言重写了Unix的第三版内核。</p><h2 id="Linux系统安装"><a href="#Linux系统安装" class="headerlink" title="Linux系统安装"></a>Linux系统安装</h2><p><strong>分区</strong>：Linux规定每一个硬盘设备最多能有4个主分区（其中包含扩展分区）。</p><p>现在基本上都是SATA接口，所以一般是/dev/sda1</p><p>1234是主分区保留的，逻辑分区只能从5开始。</p><p><strong>格式化</strong>：</p><p>根据写入文件系统，把硬盘分成一个个带下的block，同时也建立一个iNode table。</p><p><strong>扇区sector</strong>：每个扇区512byte。</p><p><strong>块block</strong>：多个扇区组成，文件存取的最小单位，最常见的是4kB，即8个连续sector组成一个block，文件数据都存储在块中。</p><p><strong>iNode</strong>：储存文件元信息的地方，iNode也叫“索引节点”</p><p>查看文件的iNode命令：stat 文件名</p><p>iNode的大小：</p><p>格式化时候，操作系统自动将硬盘分成两个区域：</p><ol><li>数据区，存放文件数据</li><li>iNode区，存放iNode包含的信息</li></ol><p>iNode节点大小：128或256byte，iNode节点总数，在格式化就给定，一般是每1kb或者2kb设计一个iNode</p><p>查看每个硬盘分区的iNode总数和已经使用的数量，可以使用df命令：df -i</p><p>每个iNode节点大小可以用如下命令：dumpe2fs -h /dev/had | grep “inode size”</p><p>iNode的号码：</p><p>每个iNode都有一个号码，操作系统用iNode号码来识别不同的文件，文件名是iNode号码便于识别的别称或绰号，表面上，用户通过文件名，区分文件。实际上，系统内部这个过程分成三步：首先，系统找到这个文件名对应的iNode号码；其次，通过iNode号码，获取iNode信息；最后，根据iNode信息，找到文件数据所在的block，读出数据。</p><p>使用ls -i命令，可以查看文件名对应的iNode号码。</p><p><strong>硬链接和软连接</strong>：</p><p>多个文件名指向同一个iNode号码：硬链接</p><p>文件A和文件B的iNode号码不一样，但是文件A的内容是B的路径。读取A的时候，系统自动将访问导向文件B，因此，不管打开哪个文件，最后读取的都是文件B。这时，文件A就是文件B的“软链接”或者“符号链接”。</p><p><strong>挂载</strong>：把文件系统挂载到某个分区上，建立一个映射关系。挂载点必须是空目录</p><p>分区：</p><p>必须分区： /（根分区）；swap分区（交换分区，内存2倍，不超过2Gb）</p><p>推荐分区：/boot（启动分区200MB）</p><h2 id="Linux学习"><a href="#Linux学习" class="headerlink" title="Linux学习"></a>Linux学习</h2><h3 id="linux学习注意事项"><a href="#linux学习注意事项" class="headerlink" title="linux学习注意事项"></a>linux学习注意事项</h3><ol><li>Linux严格区分大小写</li><li>linux中所有内容都是以文件的形式保存</li><li>linux不靠扩展名区分文件类型，但是有一些约定，方便管理员识别，不是必须的，linux能够通过颜色来帮助说明</li><li>linux所有的存储设备都必须挂载之后用户才能使用。</li></ol><h3 id="服务器管理和维护建议"><a href="#服务器管理和维护建议" class="headerlink" title="服务器管理和维护建议"></a>服务器管理和维护建议</h3><p>linux各个目录的作用：</p><p>/bin /sbin区别：s表示super，只有root用户才能执行该目录的命令或程序</p><p>/boot：引导linux的重要文件，包括grub和内核文件等</p><p>/dev：所有的设备资源</p><p>/etc：默认系统配置文件</p><p>/home：普通用户的家目录</p><p>/mnt，/media，/misc：用于挂载文件，空目录才能挂载，一般采用/mnt，当然也可以自己随意设置一个挂载点</p><p>/opt：第三方软件可选程序安装目录，通常现在使用/usr/local代替</p><p>/proc和/sys：用于存放系统和内核信息，存放在内存中，随时可能消失</p><p>/root：超级用户的家目录</p><p>/srv：服务数据目录</p><p>/usr：系统资源目录</p><p>/var：动态数据保存目录</p><h3 id="linux常用命令"><a href="#linux常用命令" class="headerlink" title="linux常用命令"></a>linux常用命令</h3><h4 id="文件处理命令"><a href="#文件处理命令" class="headerlink" title="文件处理命令"></a>文件处理命令</h4><h5 id="命令格式与目录处理命令ls"><a href="#命令格式与目录处理命令ls" class="headerlink" title="命令格式与目录处理命令ls"></a>命令格式与目录处理命令ls</h5><p>命令格式：命令 【-选项】 【参数】</p><p>目录处理命令：ls</p><p>详细信息：</p><ol><li>权限信息：-rw-r–r–，一共10个标记，文件类型：（-表示二进制文件，d表示目录，l表示软连接文件）</li><li>硬链接个数，引用计数</li><li>所有者：linux把用户分成三类，所有者（u），用户组（g），其他人（o）</li><li>所属组</li><li>大小</li><li>最后修改时间</li><li>文件名</li></ol><h5 id="目录处理命令：mkdir，cd，pwd，rmdir，cp，mv，rm"><a href="#目录处理命令：mkdir，cd，pwd，rmdir，cp，mv，rm" class="headerlink" title="目录处理命令：mkdir，cd，pwd，rmdir，cp，mv，rm"></a>目录处理命令：mkdir，cd，pwd，rmdir，cp，mv，rm</h5><p><strong>命令名称：mkdir</strong></p><p>创建新目录，可以同时建立多个目录</p><p>-p，递归创建</p><p><strong>命令名称：cd</strong></p><p>功能描述：切换目录</p><p><strong>命令名称：pwd</strong></p><p>功能描述：显示当前目录的绝对路径</p><p><strong>命令名称：rmdir</strong></p><p>功能描述：删除空目录</p><p><strong>命令名称：cp</strong></p><p>功能描述：复制文件或目录，复制时可以直接就修改名字</p><p><strong>命令名称：mv</strong></p><p>功能描述：剪切文件、改名</p><p><strong>命令名称：rm（不要随意删除系统文件，删除时注意，linux没有回收站）</strong></p><p>功能描述：删除文件</p><h5 id="文件处理命令（touch，cat，more，less，head，tail）"><a href="#文件处理命令（touch，cat，more，less，head，tail）" class="headerlink" title="文件处理命令（touch，cat，more，less，head，tail）"></a>文件处理命令（touch，cat，more，less，head，tail）</h5><p>命令名称：touch</p><p>功能描述：创建空文件（可以同时创建多个文件，用空格分开，不建议用特殊符号给文件命名，尤其是空格）</p><p><strong>命令名称：cat</strong></p><p>功能描述：显示文件内容</p><p>​              -n 显示行号</p><p><strong>命令名称：more</strong></p><p>语法：more 【文件名】</p><p>​              空格或者f：进行翻页</p><p>​              回车：换行</p><p>​              Q或q：退出</p><p>功能描述：分页显示文件内容，没法向上翻页</p><p><strong>命令名称：less</strong></p><p>语法：less 【文件名】</p><p>​              Page up/down：进行翻页</p><p>​              上下：换行</p><p>​              Q或q：退出</p><p>​              /内容：可以查找内容，n：下一个</p><p>功能描述：分页显示文件内容，可以向上翻页，可进行搜索</p><p><strong>命令名称：head</strong></p><p>语法：head  -n 行数【文件名】</p><p>功能描述：显示文件内容，只显示前几行</p><p><strong>命令名称：tail</strong></p><p>语法：tail -n 行数【文件名】</p><p>功能描述：显示文件内容，只显示末尾几行</p><h5 id="链接命令（ln）"><a href="#链接命令（ln）" class="headerlink" title="链接命令（ln）"></a>链接命令（ln）</h5><p><strong>命令名称：ln</strong></p><p>语法：ln  -s 【源文件】 【目标文件】</p><p>​              -s 创建软连接</p><p>功能描述：生成链接文件</p><h5 id="权限管理（chmod-chown-chgrp-umask）"><a href="#权限管理（chmod-chown-chgrp-umask）" class="headerlink" title="权限管理（chmod chown chgrp umask）"></a>权限管理（chmod chown chgrp umask）</h5><p><strong>权限管理命令：chmod</strong></p><p>命令英文原意：change the permissions mode of a file</p><p>语法：chmod  【{ugoa}  {+-=}  {rwx}】 【文件或目录】</p><p>​        chmod 【mode=421】 【文件或目录】</p><p>​              -R 递归修改</p><p>功能描述：修改文件或目录权限</p><p><strong>只有两个人可修改：拥有者，或者root</strong></p><p><strong>修改所有者权限管理命令：chown</strong></p><p>语法：chown 【用户】 【文件或目录】</p><p>功能描述：改变文件或目录的所有者</p><p>前提：<strong>root用户才能修改</strong>，用户要先存在</p><p><strong>修改所属组权限管理命令：chgrp</strong></p><p>语法：chgrp【用户组】 【文件或目录】</p><p>功能描述：改变文件或目录的所属组</p><p>前提：root用户才能修改</p><p><strong>缺省权限管理命令：umask</strong></p><p><strong>默认创建的目录权限是rwxr-xr-x，文件比目录都少x，就是rw-r—r–（出于安全考虑）</strong></p><p>0222即用异或（减）的方法表示755</p><h5 id="文件搜索命令（find，locate，which，whereis，grep）"><a href="#文件搜索命令（find，locate，which，whereis，grep）" class="headerlink" title="文件搜索命令（find，locate，which，whereis，grep）"></a>文件搜索命令（find，locate，which，whereis，grep）</h5><p><strong>命令名称：find</strong></p><p><strong>语法：find</strong> <strong>【搜索范围】</strong> <strong>【匹配条件】</strong></p><p>功能描述：文件搜索</p><p><strong>-iname</strong>：表示忽略大小写</p><p>?: 表示一个字符的通配符</p><p>*：表示多个字符的通配符</p><p>-size：制定文件大小，+n表示大于n， -n表示小于n，以数据块为单位，512字节</p><p>-user：根据所有者查找</p><p>-group：根据所属组查找</p><p>-cmin，-amin，-mmin，根据时间属性查找，文件属性被改，文件访问，文件内容被修改，如 find  /etc  –cmin  -5 表示查找5分钟内被修改文件属性的文件和目录</p><p>-a：链接符，同时满足多个条件</p><p>-o：连接符，满足其中一个</p><p><strong>文件搜索命令：locate</strong></p><p>语法：locate 文件名</p><p>功能描述：在<strong>文件资料库</strong>进行文件搜索</p><p>注：locate是在文件资料库查找，对于刚刚更新的文件可能查找不到，可以手动更新文件资料库：updatedb，对于/tmp目录的文件不在文件资料库的保存范围，所以可能搜不到，忽略大小写可以用-i</p><p><strong>文件搜索命令：which（查找的是命令）</strong></p><p>语法：which <strong>命令</strong></p><p>功能描述：搜索命令所在路径以及<strong>别名信息</strong></p><p><strong>文件搜索命令：whereis</strong></p><p>语法：whereis 【命令名称】</p><p>功能描述：搜索命令所在路径以及<strong>帮助文档</strong>坐在路径</p><p><strong>文件搜索命令：grep</strong></p><p>命令名称：grep</p><p>语法：grep  -iv【指定字符串】【文件名】</p><p>功能描述：在文件中搜索字符串匹配的行并输出</p><p>​                     -i 不区分大小写</p><p>​                     -v 排查指定字符串</p><h4 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h4><p><strong>命令名称：man</strong></p><p>语法：man 【命令或配置文件】</p><p>功能描述：获取帮助信息，优先查看命令帮助信息</p><h4 id="用户管理命令"><a href="#用户管理命令" class="headerlink" title="用户管理命令"></a>用户管理命令</h4><p><strong>命令名称：useradd</strong></p><p>执行权限：root</p><p>语法：useradd 用户名</p><p>功能描述：添加新用户</p><p><strong>命令名称：passwd</strong></p><p>语法：passwd 用户名</p><p>功能描述：设置用户密码</p><p>root 可以修改所有用户的密码，用户只能修改自己的密码，用户自己修改时密码不能过于简单</p><p><strong>命令名称：who</strong></p><p>语法：who</p><p>功能描述：查案登录用户信息</p><p><strong>命令名称：w</strong></p><p>语法：w</p><p>功能描述：查案登录用户详细信息</p><h4 id="压缩解压命令"><a href="#压缩解压命令" class="headerlink" title="压缩解压命令"></a>压缩解压命令</h4><p>对于.gz结尾的文件：</p><p><strong>命令名称：gzip</strong></p><p>语法：gzip 【文件】</p><p>功能描述：压缩文件</p><p><strong>解压缩：gunzip</strong> <strong>【文件】或者gzip  -d</strong>  【文件】</p><p>注：gzip 只能解压缩文件，不能解压缩<strong>目录</strong>；gzip解压缩<strong>不保留源文件</strong>，这个要注意</p><p>对于<strong>目录文件</strong>，需要打包或者压缩：<strong>tar</strong>命令</p><p><strong>命令名称：tar</strong></p><p>语法：tar  选项【-zcfv】【压缩后的文件名】 【要打包或压缩的目录】</p><p>​                     -c 打包</p><p>​                     -x 解压缩</p><p>​                     -f 指定文件名</p><p>​                     -z打包同时压缩</p><p>功能描述：打包目录</p><p>压缩后文件格式：.tar.gz</p><p><strong>命令名称：zip（.zip文件，window和linux通用的格式），能保留源文件</strong></p><p>语法：zip 选项【-r】 【压缩后的文件名】 【文件或目录】</p><p>​              -r 压缩目录</p><p>功能描述：压缩文件或目录，压缩后文件格式.zip</p><p>解压缩：unzip 【文件名】</p><p>对于bz2：</p><p><strong>命令名称：bzip2</strong></p><p>语法：bzip2  选项【-k】 【要打包或压缩的目录】</p><p>​                     -k 保留源文件</p><p>功能描述：打包目录</p><p>压缩后文件格式：bz2</p><h4 id="网络配置命令"><a href="#网络配置命令" class="headerlink" title="网络配置命令"></a>网络配置命令</h4><p><strong>网络命令名称：write</strong></p><p>语法：write 【用户名】</p><p>功能描述：给用户发信息，以ctrl+D保存结束，前提条件，用户要在线</p><p><strong>网络命令名称：wall</strong></p><p>语法：wall【message】</p><p>功能描述：给所有在线用户发信息，以ctrl+D保存结束，前提条件，用户要在线</p><p><strong>网络命令名称：ping</strong></p><p>语法：ping 【选项】 【IP地址】</p><p>​             -c  指定发送次数</p><p>功能描述：测试网络连通性</p><p><strong>网络命令名称：mail</strong></p><p>语法：mail 【用户名】</p><p>功能描述：发送邮件，不要求用户在线，ctrl+D保存并发送</p><p><strong>网络命令名称：last</strong></p><p>语法：last</p><p>功能描述：列出目前与过去登入系统的用户信息，是比较重要的日志查询命令</p><p><strong>网络命令名称：lastlog</strong></p><p>语法：last</p><p>功能描述：列出目前与过去登入系统的用户最后一次登录信息，是比较重要的日志查询命令</p><p><strong>网络命令名称：traceroute</strong></p><p>语法：traceroute</p><p>功能描述：显示数据包到主机间的路径，可以用来测试网络故障节点在哪里</p><p><strong>网络命令名称：netstat</strong></p><p>指令所在路径：/bin/netstat</p><p>执行权限：所有用户</p><p>语法：netstat 【选项】</p><p>​             -t ：tcp协议</p><p>​             -u：udp协议</p><p>​             -l：监听</p><p>​             -r：路由</p><p>​             -n：显示IP地址和端口号</p><p>功能描述：显示网络相关信息，也是一个非常重要的命令</p><p><strong>网络命令名称：mount</strong></p><p>语法：mount 【-t 文件系统】 【设备文件挂载点】</p><p>功能描述：挂载设备，进行映射</p><h4 id="关机重启命令"><a href="#关机重启命令" class="headerlink" title="关机重启命令"></a>关机重启命令</h4><p>shutdown 命令：shutdown 【选项】 时间</p><p>选项：</p><p>​      -c： 取消前一个关机命令</p><p>​      -h： 关机</p><p>​      -r： 重启</p><p>init 0关机，init 6重启</p><h2 id="vim编辑器"><a href="#vim编辑器" class="headerlink" title="vim编辑器"></a>vim编辑器</h2><p>Vim编辑器简介：vim是一个功能强大的全屏幕文本编辑器，是linux/unix上最常用的文本编辑器，它的作用是建立、编辑和显示文本文件。</p><p>Vim的工作模式有三种：<strong>命令模式，插入模式，编辑模式</strong></p><p>进入命令模式：vi 【文件名】</p><p>在命令模式下输入i或a或o进入插入模式，按esc回到命令模式</p><p>在命令模式下按：冒号进入编辑模式，编辑模式是输入命令如：wq是写入保存退出</p><h2 id="软件包管理"><a href="#软件包管理" class="headerlink" title="软件包管理"></a>软件包管理</h2><h4 id="软件包简介"><a href="#软件包简介" class="headerlink" title="软件包简介"></a>软件包简介</h4><p><strong>软件包分类</strong></p><ul><li><p>源码包：脚本安装包，通常以压缩包tar.gz方式压缩，绝大多数以C语言编写，安装过程容易报错。</p></li><li><p>二进制包（rpm包，系统默认包），<strong>已经经过编译的</strong>，rpm格式相当于window的EXE文件，在redhat上是rpm，在Debian版本上是deb。Rpm包可以在安装光盘中的packages中。</p></li></ul><p><strong>源码包优点：</strong></p><ul><li><p>开源，能看到源代码，可以学习顶级程序员开发的源代码</p></li><li><p>可以自由选择所需要的安装功能</p></li><li><p>软件是先编译安装的，更加适合自己系统，更加稳定和有效率</p></li><li><p>卸载也十分方便</p></li></ul><p><strong>RPM安装</strong></p><p>rpm  -ivh  包全名（需要注意包的路径）</p><p>选项：  -i（install） 安装</p><p>​              -v（verbose） 显示详细信息</p><p>​              -h（hash） 显示进度</p><p>​              –nodeps  不检测依赖性</p><p><strong>RMP升级</strong></p><p>rpm  -Uvh  包全名</p><p><strong>RPM卸载</strong></p><p>rpm  -e  包名（/var/lib/rpm下）</p><p>选项： -e（erase）  卸载</p><p>​             –nodeps   不检测依赖性</p><h4 id="rpm包的查询方法"><a href="#rpm包的查询方法" class="headerlink" title="rpm包的查询方法"></a>rpm包的查询方法</h4><ol><li>查询软件包是否安装：rpm -q 包名</li><li>查询软件包详细信息：<ol><li>rpm -qi 包名 #已安装的软件包</li><li>rpm -qip 包名 #未安装的软件包</li></ol></li><li>查询软件包的安装位置：<ol><li>rpm -ql 包名 #已安装</li><li>rpm -qlp 包名  #未安装</li></ol></li><li>查询系统文件属于哪个软件包：rpm -qf 系统文件名</li><li>查询软件包的依赖性：<ol><li>rpm -qR 包名 #已安装 </li><li>rpm -qRp 包名  #未安装</li></ol></li></ol><h4 id="rpm包的校验和文件提取"><a href="#rpm包的校验和文件提取" class="headerlink" title="rpm包的校验和文件提取"></a>rpm包的校验和文件提取</h4><ol><li><p>包校验：用于检查安装的包修改了哪些文件 rpm -V 已安装的包名</p></li><li><p>rpm包文件提取（用于丢失某个子文件，或者误删除，不能全部重新安装，只需要把文件提取放回去）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm2cpop 包全名 | cpio -idv ./文件绝对路径</span><br></pre></td></tr></table></figure></li></ol><h4 id="rpm包管理-yum-在线管理"><a href="#rpm包管理-yum-在线管理" class="headerlink" title="rpm包管理 -yum 在线管理"></a>rpm包管理 -yum 在线管理</h4><p>yum命令：</p><ol><li><p>查询在线所有可用软件包列表：yum list java*</p></li><li><p>搜索服务器上所有和关键字相关的包：yum search 【关键字】</p></li><li><p>安装软件包：yum -y install 【包名】</p></li><li><p>升级软件包：yum -y update 【包名】</p></li><li><p>卸载：yum -y remove 【包名】</p></li><li><p>查询所有可用软件组：yum grouplist</p></li><li><p>安装/删除软件组： yum install/remove 【软件组名】</p><p>软件组名有空格需要双引号，注意安装时输入英文不是中文</p></li></ol><h4 id="源码包安装"><a href="#源码包安装" class="headerlink" title="源码包安装"></a>源码包安装</h4><ol><li><p>与rpm包不同，安装的位置不是不同的，rpm包有默认的安装位置，<strong>而源码包可以安装在指定的位置上，一般建议放在/usr/local/软件名/</strong></p></li><li><p>源码包安装与rpm包安装对服务的管理不同：</p><ol><li>rpm包安装的服务可以使用系统服务管理命令（service）来管理</li><li>通过源码包安装的服务不能被服务管理命令管理，因为没有安装到默认的路径中，只能用绝对路径进行服务的管理（这里的管理指start，restart，stop）。</li></ol></li><li><p>源码包的安装过程</p><ol><li><p>源码包下载</p></li><li><p>在linux服务器中解压源码包</p></li><li><p>进入解压缩包目录，查看<strong>install文件或readme文件</strong>，一般在这2个文件会详细说明安装过程</p></li><li><p>./configure：用于软件的配置和坚持（可以用./configure -help查看支持哪些选项）</p><p>设置安装位置，建议但是不强制–prefix=/usr/local/{安装目录}</p></li><li><p>使用make和make install安装</p></li></ol></li></ol><h2 id="用户和用户组管理"><a href="#用户和用户组管理" class="headerlink" title="用户和用户组管理"></a>用户和用户组管理</h2><h3 id="用户配置文件"><a href="#用户配置文件" class="headerlink" title="用户配置文件"></a><strong>用户配置文件</strong></h3><p>用户文件信息 /etc/passwd</p><p>影子文件 /etc/shadow</p><p>用户组信息文件/etc/group</p><p>组密码文件 /etc/gshadow</p><h4 id="etc-passwd"><a href="#etc-passwd" class="headerlink" title="/etc/passwd"></a>/etc/passwd</h4><p><strong>用户名称：密码标志：UID（用户ID）：GID（组ID）：用户说明：家目录：bash</strong></p><p>密码标志：x表示该用户需要密码才能登陆，如果去掉x就不需要密码了。</p><p><strong>UID</strong>：用数字标识用户，用户采用用户名记住用户，系统采用数字，所以root不一定是管理员，UID=0的才是管理员</p><p><strong>GID</strong>：用户初始组ID，这里指的是初始组，linux还有附加组概念，用户可以加入多个附加组，但是只能有一个初始组，最好不要改初始组，用户必须依赖一个初始组才能存在</p><p>家目录位置：对于普通用户来说，默认是/home/用户名/,对于超级用户来说，默认是/root/，但是可以修改，但不建议修改</p><p><strong>登录之后的Shell</strong>：命令解析器，标准shell是/bin/bash，还可以是/sbin/nologin, 不要随便改，不要无法登录系统，改成/sbin/nologin可以暂时禁用某个用户，千万不要改超级用户的。</p><h4 id="etc-shadow配置文件"><a href="#etc-shadow配置文件" class="headerlink" title="/etc/shadow配置文件"></a><strong>/etc/shadow配置文件</strong></h4><p><strong>权限为000，只有超级用户才能查看，默认的配置值在/etc/default/useradd以及/etc/login.defs中</strong></p><p><strong>9个字段</strong>：</p><p><strong>用户名称：如root等</strong></p><p>加密密码（SHA512）：如果是！！或者*表示没有密码，想临时禁用某个用户的密码可以在密码前加！</p><p>密码最后一次修改时间：用时间戳表示，从1970年1月1到现在的天数</p><p><strong>两次密码的修改时间间隔</strong>：与第三个字段相比，如果是0表示上一次修改完密码后立马可以修改，如果是10表示修改密码10天后才能再次修改</p><p><strong>密码的有效期</strong>：99999表示该密码有效期为99999天，要想强制用户隔30天修改一次密码可以把该字段设置为30</p><p><strong>密码到期之前的警告时间</strong>：7表示在密码到期前7天，用户每天登陆都会收到要求改密码的信息</p><p><strong>密码到期之后的宽限天数</strong>：与第五字段比，0或空表示密码过期后立刻失效，用户就没法登陆了，-1表示一直提示要用户改密码，密码永远不会失效</p><p><strong>账号失效时间</strong>：用时间戳表示，到这个天数，该账号就失效了，无论密码是否有效</p><p><strong>第九字段：保留</strong></p><h4 id="组信息文件-etc-group"><a href="#组信息文件-etc-group" class="headerlink" title="组信息文件/etc/group"></a><strong>组信息文件/etc/group</strong></h4><p><strong>字段说明：四个字段</strong></p><p>组名：组的密码标志：组ID（GID）：组中的附加用户（有些用户有附加组）</p><h4 id="组密码文件-etc-gshadow"><a href="#组密码文件-etc-gshadow" class="headerlink" title="组密码文件 /etc/gshadow"></a><strong>组密码文件 /etc/gshadow</strong></h4><p>组名：组密码：组管理员用户名：组中的附加用户</p><h4 id="用户管理的相关文件"><a href="#用户管理的相关文件" class="headerlink" title="用户管理的相关文件"></a><strong>用户管理的相关文件</strong></h4><p><strong>用户的家目录：</strong></p><p>普通用户：/home/用户名/,权限为700</p><p>超级用户：/root/,权限为550</p><h4 id="用户管理命令-1"><a href="#用户管理命令-1" class="headerlink" title="用户管理命令"></a><strong>用户管理命令</strong></h4><p><strong>useradd命令</strong></p><p>useradd 【选项】 用户名</p><p>–u  指定用户的UID</p><p>–d  家目录    手工指定用户的家目录</p><p>–c  用户说明  手工指定用户的说明</p><p>–g  初始组名   手工指定用户的初始组，但是不建议改</p><p>–G  组名       手工指定用户的附加组，可以加入多个已有的组</p><p>–s  shell       手工指定用户登录的shell，默认是/bin/bash</p><p><strong>passwd【选项】用户名</strong></p><p>超级用户可以修改任何用户密码，普通用户只能修改自己密码，而且普通用户修改密码时候不能太简单。</p><p><strong>修改用户信息usermod和修改用户密码状态chage命令（针对已存在用户）</strong></p><p>–u：修改UID；</p><p>-c：修改说明；</p><p>-G：加入附加组；</p><p>-L：锁定用户；</p><p>-U：解锁用户，</p><p>-g：修改初始组（不建议，怕自己搞乱）</p><p><strong>chage【选项】用户名</strong></p><p>–l：列出用户详细密码状态</p><p>–d日期：修改密码最后一次日期</p><p>–m：两次修改密码时间间隔</p><p>–M：密码有效期</p><p>–W：前多少天警告</p><p>–I：宽限多少天</p><p>功能：设置账号的最小修改密码日期</p><p><strong>删除用户命令userdel和切换用户命令su</strong></p><p>userdel  –r 用户名</p><p>-r表示删除用户并同时删除家目录</p><p><strong>su</strong> <strong>切换用户</strong></p><h4 id="用户组管理命令"><a href="#用户组管理命令" class="headerlink" title="用户组管理命令"></a><strong>用户组管理命令</strong></h4><p><strong>添加组： groupadd</strong>  <strong>【选项】</strong> <strong>组名</strong></p><p> -g ：添加组ID</p><p>如groupadd  -g  502  test</p><p><strong>修改组：groupmod</strong>  <strong>【选项】</strong> <strong>组名</strong></p><p>–g GID：    修改组ID</p><p>–n 新组名：    修改组名</p><p>如：groupmod  -n  newtest  test</p><p><strong>删除组：groupdel</strong> <strong>组名；只能删除没有初始用户的组</strong></p><p>把用户添加入组或者从组中删除用户：<strong>gpasswd 【选项】</strong> <strong>组名</strong></p><p>–a 用户名：把用户加入组</p><p>–d 用户名：把用户从组中删除</p><p>范例：gpasswd  -a  tangent  root    把tangent加入root组，也可以直接修改/etc/group的</p><h2 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h2><h3 id="ACL权限管理"><a href="#ACL权限管理" class="headerlink" title="ACL权限管理"></a>ACL权限管理</h3><h4 id="ACL权限"><a href="#ACL权限" class="headerlink" title="ACL权限"></a>ACL权限</h4><p>ACL权限是<strong>针对分区</strong>的，在利用ACL权限时我们需要检查该分区<strong>是否开启ACL功能，默认都开启</strong>，需要文件所在的分区支持ACL权限。</p><p>检查分区是否开启ACL的命令：</p><p><strong>dumpe2fs  -h  /dev/sda5</strong></p><h4 id="查看文件是否有ACL权限"><a href="#查看文件是否有ACL权限" class="headerlink" title="查看文件是否有ACL权限"></a>查看文件是否有ACL权限</h4><ol><li><p>getfacl 【文件名】</p></li><li><p>setfacl 【选项】 文件名</p><p>–m  设定ACL权限</p><p>–x  删除指定用户或用户组ACL权限</p><p>–b  删除所有ACL权限</p><p>–k  设定默认ACL 权限</p><p>–R  递归设定ACL权限</p></li></ol><h4 id="最大有效权限设置"><a href="#最大有效权限设置" class="headerlink" title="最大有效权限设置"></a>最大有效权限设置</h4><p>命令setfacl  -m m:rx  文件名</p><h4 id="删除ACL权限"><a href="#删除ACL权限" class="headerlink" title="删除ACL权限"></a>删除ACL权限</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setfacl  -x  g:group  /tmp/project  #删除用户组的ACL权限</span><br><span class="line"></span><br><span class="line">setfacl  -b /tmp/project/    删除文件所有ACL权限</span><br></pre></td></tr></table></figure><h4 id="默认ACL权限和递归ACL权限"><a href="#默认ACL权限和递归ACL权限" class="headerlink" title="默认ACL权限和递归ACL权限"></a>默认ACL权限和递归ACL权限</h4><p>递归是在父目录在设定ACL权限时，所有的子文件和子目录都遵循相同的ACL权限，命令为<strong>setfacl  -m  u：用户名：权限  -R</strong>  <strong>目录名</strong></p><p>默认ACL权限的作用是如果在父目录设定默认的ACL权限，那么父目录中所有新建的子文件都会继承父目录的ACL权限，<strong>原有已经存在的子文件不继承</strong>。</p><p>新建的file并没有拥有ACL权限，要想新建的文件都拥有默认的ACL权限就可以采用命令setfacl  -m  d:u:wangwu:rx -R  /tmp/project/</p><h3 id="文件特殊权限"><a href="#文件特殊权限" class="headerlink" title="文件特殊权限"></a>文件特殊权限</h3><h4 id="SetUID权限"><a href="#SetUID权限" class="headerlink" title="SetUID权限"></a>SetUID权限</h4><p>setUID的方法</p><p>​      chmod 4755 命令</p><p>​      chmod u+s 命令</p><p>setUID功能：只有可执行的二进制文件才能设定SUID权限</p><p>命令执行者需要对该文件拥有x（执行）权限：</p><p>可以理解为执行过程中，命令执行者拥有该文件程序的所有者身份，举例来说某个执行文件的所有者是root，如果wangwu执行时，变身为root，执行完该文件，变回来wangwu身份，但是前提是该文件要有SUID权限，类似于windows的以管理员身份运行</p><h4 id="SGID权限"><a href="#SGID权限" class="headerlink" title="SGID权限"></a>SGID权限</h4><p>SGID权限的解析和SUID很像，都是针对可执行的二进制程序，命令执行者也需拥有x权限，但是身份不是变成超级用户，而是执行者所属组临时变成该文件的所属组，只在执行过程中有效</p><p>取消删除SGID权限 chmod  g-s 【文件】或者 chmod 755 【文件】</p><p>添加SGID chmod g+s 或 chmod 2755 </p><h4 id="Sticky-BIT权限"><a href="#Sticky-BIT权限" class="headerlink" title="Sticky BIT权限"></a>Sticky BIT权限</h4><p>SBIT权限只对<strong>目录有效</strong></p><p>普通用户对该目录有w权限和x权限</p><p>具有SBIT权限的目录，普通用户只能删除自己建立的文件，但是不能删除其他用户建立的文件。超级用户不受该限制</p><p>设置粘着位  chmod  1777  /tmp/ 或chmod  o+t  /tmp/</p><p>删除粘着位 chmod  777  /tmp/ 或 chmod  o-t  /tmp/</p><h4 id="文件系统chattr权限"><a href="#文件系统chattr权限" class="headerlink" title="文件系统chattr权限"></a>文件系统chattr权限</h4><p>命令格式 chattr 【+-=】 【选项】 【文件或目录名】，如 chattr +i newfile</p><p>​        +：增加权限</p><p>​        -：删除权限</p><p>​        =：等于某个权限</p><p>选项</p><p>i：对文件设置i属性，不允许对该文件进行删除、改名，也不能添加和修改数据；相当于把文件锁起来，<strong>只能看文件内容</strong>。</p><p>​    如果对<strong>目录</strong>设置i属性，那么只能修改该目录下的文件数据，<strong>不能删除和新建</strong>文件；对root用户也生效，防止误操作</p><p>a：如果对文件设置a属性，那么<strong>只能在文件中增加数据</strong>，不能删除和修改数据；</p><p>​    如果对目录设置a属性，那么只允许在目录中<strong>建立和修改</strong>文件(修改文件的内容而不是改名)，但不允许删除</p><p><strong>查看文件系统属性</strong></p><p>lsattr  【选项】 文件名</p><p>–a：显示所有文件和目录</p><p>–d：若目标是目录，仅列出目录本身的属性，而不是子文件的</p><h4 id="sudo权限"><a href="#sudo权限" class="headerlink" title="sudo权限"></a>sudo权限</h4><p>root把本来只属于超级用户执行的命令赋予普通用户执行</p><p>sudo的操作对象是<strong>系统命令</strong></p><p>sudo使用方式</p><p>vi sudo命令  实际上修改的是/etc/sudoers文件，如下</p><p>root   ALL=（ALL）  ALL</p><p>语法</p><p><strong>用户名</strong>   <strong>被管理主机的地址</strong>=（可使用的身份）   授权命令（绝对路径）</p><p>注：被管理主机地址是本机的IP地址，而不是远程登录终端的IP地址，ALL表示本机，有时候还需要填IP/网段，这种场景用于集群服务器。</p><h2 id="文件系统管理"><a href="#文件系统管理" class="headerlink" title="文件系统管理"></a>文件系统管理</h2><h3 id="分区和文件系统"><a href="#分区和文件系统" class="headerlink" title="分区和文件系统"></a>分区和文件系统</h3><p>什么是分区？</p><p>通俗地将就是把大硬盘分成几个小硬盘，就好像把一个衣柜分成不同的部分，放不同的衣服</p><p>主分区：最多只有分四个</p><p>扩展分区：只能有一个，也算在主分区的一种，也就是说主分区加扩展分区最多有四个，但是扩展分区不能存数据和格式化，必须再划分成逻辑分区才能使用</p><p>逻辑分区：逻辑分区是在扩展分区中划分得来的</p><h3 id="文件系统常用命令"><a href="#文件系统常用命令" class="headerlink" title="文件系统常用命令"></a>文件系统常用命令</h3><p><strong>文件系统查看命令df（最常用 df  -h）</strong></p><p>df  【选项】 【挂载点】</p><p>​    –a  显示所有的文件系统信息</p><p>​    –h  使用习惯单位显示容量</p><pre><code>-T  显示文件系统类型-m  以MB为单位显示容量 -k  以KB为单位显示容量</code></pre><p><strong>du命令：统计目录或文件大小（主要统计目录总大小）</strong></p><p>du  -sh  /etc/</p><p><strong>显示磁盘状态命令  dumpe2fs</strong></p><p><strong>挂载命令</strong></p><p>mount  -l   显示已经挂载的设备</p><p>mount  -a   已经配置文件/etc/fstab的内容，自动挂载</p><p>mount 【-t 文件系统】 【-L 卷标名】 【-o 特殊选项】 设备文件名 挂载点</p><p>​    -t 文件系统： 可以为ext4（linux分区）、iso9660（光盘）等文件系统</p><p>​    -L卷标名： 挂载指定卷标分区，不是安装设备名挂载</p><p>​    -o 特殊选项：可以指定挂载的额外选项</p><p><strong>卸载命令</strong></p><p>umount  /dev/sr0   #但是不能在cdrom文件夹里执行</p><h2 id="Shell编程"><a href="#Shell编程" class="headerlink" title="Shell编程"></a>Shell编程</h2><h3 id="Shell是什么"><a href="#Shell是什么" class="headerlink" title="Shell是什么"></a>Shell是什么</h3><p>shell是一个命令行解析器，为用户提供一个向linux内核发送请求以便运行程序的界面系统级程序，用户可以用shell来启动、挂起、停止甚至是编写一些程序，shell可以直接调用linux的系统命令。</p><p>Linux支持的Shell类型，在/etc/shells文件中。</p><h3 id="shell脚本执行的方式"><a href="#shell脚本执行的方式" class="headerlink" title="shell脚本执行的方式"></a>shell脚本执行的方式</h3><h3 id="echo-输出命令"><a href="#echo-输出命令" class="headerlink" title="echo 输出命令"></a>echo 输出命令</h3><p>echo 【选项】 【输出内容】</p><p>选项： -e   支持反斜线控制的转义字符</p><p>编写helloworld.sh</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#! /bin/bash</span><br><span class="line">echo -e &quot;hello world!&quot;</span><br></pre></td></tr></table></figure><p>注：第一句不是注释 所有shell脚本开头都需要注明采用什么样的shell来运行，就是#!/bin/bash，这里我们用标准shell运行</p><p>脚本的运行：</p><ul><li>l赋予执行权限，直接运行</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> chmod 755 helloworld.sh</span><br><span class="line"></span><br><span class="line">./helloworld.sh</span><br></pre></td></tr></table></figure><ul><li>通过Bash来调用执行脚本，这个不需要执行权限</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash helloworld.sh</span><br></pre></td></tr></table></figure><p><strong>注</strong>：单引号和双引号的区别，单引号里所有特殊字符都不解析，原样输出！</p><p><strong>注</strong>：linux的shell中，回车符用$表示，与window不同</p><h3 id="历史命令保存（每个登录用户各自保存）"><a href="#历史命令保存（每个登录用户各自保存）" class="headerlink" title="历史命令保存（每个登录用户各自保存）"></a>历史命令保存（每个登录用户各自保存）</h3><p>history 【选项】 【历史命令保存文件】</p><p>选项： -c 清空历史命令； -w 把缓存中的历史命令写入历史命令保存文件当中，默认保存在家目录下的.bash_history文件中，即~/.bash_history</p><p>默认最大保存1000/etc/profile</p><h3 id="常用别名和快捷键"><a href="#常用别名和快捷键" class="headerlink" title="常用别名和快捷键"></a>常用别名和快捷键</h3><p>设定命令别名</p><p>alias 别名=‘原命令’ 如，alias  vi=‘vim’</p><p>查看命令别名：alias</p><h4 id="命令执行顺序"><a href="#命令执行顺序" class="headerlink" title="命令执行顺序"></a><strong>命令执行顺序</strong></h4><p>第一顺位执行绝对路径或者相对路径执行的命令</p><p>第二顺位执行别名</p><p>第三顺位执行Bash内部命令</p><p>第四顺位执行按照$PATH环境变量定义的目录查找顺序找到的第一个命令</p><h4 id="Bash常用快捷键"><a href="#Bash常用快捷键" class="headerlink" title="Bash常用快捷键"></a>Bash常用快捷键</h4><p>ctrl+C  强制终止当前命令</p><p>ctrl+L 清屏，相当于clear</p><p>ctrl+U 删除或剪切光标之前的命令</p><p>ctrl+K 删除或剪切光标之后的命令</p><p>ctrl+Y  粘贴ctrl+u或者ctrl+K剪切的内容</p><p>crtl+R  在历史命令中搜索，输入搜索内容就会从历史命令中国搜索</p><p>ctrl+D   退出当前终端</p><h3 id="Bash的输入输出重定向"><a href="#Bash的输入输出重定向" class="headerlink" title="Bash的输入输出重定向"></a>Bash的输入输出重定向</h3><p><img src="https://img-blog.csdnimg.cn/20190705094620386.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDQ4NTc0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190705094632582.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDQ4NTc0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2019070509464682.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDQ4NTc0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>输入重定向</strong></p><p>wc  【选项】 【文件名】</p><p>选项：</p><p>–c 统计字节数</p><p>–w 统计单词数</p><p>–l   统计行数</p><h3 id="多命令和管道符"><a href="#多命令和管道符" class="headerlink" title="多命令和管道符"></a>多命令和管道符</h3><p><strong>多命令执行符”;”</strong> </p><p>格式 ：<strong>命令1 ; 命令2</strong></p><p>作用：多个命令顺序执行，没有任何联系</p><p><strong>多命令执行符”&amp;&amp;”</strong> </p><p>格式： <strong>命令1&amp;&amp;命令2</strong></p><p>作用：逻辑与，命令1正确执行，命令2才执行。</p><p><strong>多命令执行符”||”</strong> </p><p>格式： <strong>命令1 || 命令2</strong></p><p>作用：逻辑或，命令1不正确执行，命令2才执行。</p><p><strong>管道符|</strong></p><p>作用：使管道上一个指令的输出作为下一个指令的输入</p><p>使用管道注意的要点</p><ul><li>只处理前一个命令的正确输出，如前一个命令错误，则不再处理</li><li>右边的指令必须能接收标准输入流，否则传递过程中数据会被抛弃</li><li>常用接收输入流的指令有sed, awk, grep, cut, head, top, less, more, wc, join, sort, split</li></ul><p>[外链图片转存失败(img-87elJUoc-1562290954516)(C:\Users\xin\AppData\Roaming\Typora\typora-user-images\1562164137046.png)]</p><h3 id="Bash变量"><a href="#Bash变量" class="headerlink" title="Bash变量"></a>Bash变量</h3><p>什么是变量？ 变量是计算机内存的单元，其中存放的值是可改变的。</p><h4 id="用户自定义变量"><a href="#用户自定义变量" class="headerlink" title="用户自定义变量"></a><strong>用户自定义变量</strong></h4><p>命令规则：</p><ul><li><p>跟c一样，字母数字下划线，不能以数字开头</p></li><li><p>默认字符类型都是字符串类型，如果需要数值运算，必须指定变量类型为数值型</p></li><li><p>等号两边不能有空格</p></li><li><p>变量值如果包含空格，需要用单引号或者双引号包括</p></li><li><p>可以采用\转义字符</p></li><li><p>$变量名</p></li><li><p>可以把命令的结果作为变量值赋予给变量，需要$()包括命令</p></li><li><p>环境变量建议大写，</p></li></ul><p>变量定义：a=123</p><p>变量叠加：a=”$a”123;echo $a</p><h4 id="环境变量：保存和系统操作环境相关的数据"><a href="#环境变量：保存和系统操作环境相关的数据" class="headerlink" title="环境变量：保存和系统操作环境相关的数据"></a><strong>环境变量：保存和系统操作环境相关的数据</strong></h4><p>设置环境变量：<strong>export</strong> 变量名=变量值，加个export就是环境变量</p><p>查看环境变量env；删除环境变量 unset</p><h4 id="位置参数变量"><a href="#位置参数变量" class="headerlink" title="位置参数变量"></a><strong>位置参数变量</strong></h4><p>想脚本当中传递参数或数据的，变量名不能自定义，变量作用是固定的<br><img src="https://img-blog.csdnimg.cn/20190705094717834.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDQ4NTc0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a><strong>预定义变量</strong></h4><p>Bash已经定义好的变量，变量名不能自定义，变量作用也固定</p><p>$?: 最后一次执行的命令的返回状态。如果上一个命令正确执行，则返回0，反正为非0。</p><p>$$:返回当前进程的进程号（PID）</p><p>$!:后台回血的最后一个进程的进程号</p><h4 id="read命令"><a href="#read命令" class="headerlink" title="read命令"></a>read命令</h4><p>read [选项] [变量名]</p><p>选项：</p><p>​    -p “提示信息”： 在等待read输入时，输出提示信息</p><p>​    -t 秒数：read命令等待的时间，如果不指定，则一直等待</p><p>​    -n 字符数：read命令只接受指定的字符数，之后就会继续执行</p><p>​    -s：隐藏输入的数据，适合机密信息的输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#! /bin/bash</span><br><span class="line">read -t 30 -p &quot;please input your name:&quot; name</span><br><span class="line">echo &quot;$name&quot;</span><br></pre></td></tr></table></figure><h3 id="数值运算和运算符"><a href="#数值运算和运算符" class="headerlink" title="数值运算和运算符"></a>数值运算和运算符</h3><p>shell里面所有变量默认都是字符串类型</p><h4 id="declare命令"><a href="#declare命令" class="headerlink" title="declare命令"></a><strong>declare</strong>命令</h4><p>declare 【+/-】【选项】变量名</p><p>​    +：取消变量的类型属性</p><p>​    -：给变量设定类型属性</p><p>​    -i：将变量声明为整数型</p><p>​    -x：将变量声明为环境变量</p><p>​    -p：显示指定变量的类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test]# a1=11</span><br><span class="line">[root@localhost test]# declare -p a1</span><br><span class="line">declare -- a1=&quot;11&quot;</span><br><span class="line">[root@localhost test]# a2=22</span><br><span class="line">[root@localhost test]# declare -p a2</span><br><span class="line">declare -- a2=&quot;22&quot;</span><br><span class="line">[root@localhost test]# declare -i a3=$a1+$a2</span><br><span class="line">[root@localhost test]# echo $a3</span><br><span class="line">33</span><br></pre></td></tr></table></figure><h4 id="采用expr或者let运算工具"><a href="#采用expr或者let运算工具" class="headerlink" title="采用expr或者let运算工具"></a>采用expr或者let运算工具</h4><p>expr：$a1 + $a2的空格不能省略</p><p>let：$a1+$a2加号左右不能有空格</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test]# a4=$(expr $a1 + $a2)</span><br><span class="line">[root@localhost test]# echo $a4</span><br><span class="line">33</span><br><span class="line">[root@localhost test]# a4=$(expr $a1+$a2)</span><br><span class="line">[root@localhost test]# echo $a4</span><br><span class="line">11+22</span><br><span class="line">[root@localhost test]# let a4=$a1+$a2</span><br><span class="line">[root@localhost test]# echo $a4</span><br><span class="line">33</span><br><span class="line">采用$((运算式))或者$[运算式]</span><br></pre></td></tr></table></figure><h4 id="采用-运算式-或者-运算式"><a href="#采用-运算式-或者-运算式" class="headerlink" title="采用$((运算式))或者$[运算式]"></a>采用$((运算式))或者$[运算式]</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test]# a5=$(($a1+$a2))</span><br><span class="line">[root@localhost test]# echo $a5</span><br><span class="line">33</span><br><span class="line">[root@localhost test]# a6=$[$a1+$a2]</span><br><span class="line">[root@localhost test]# echo $a6</span><br><span class="line">33</span><br></pre></td></tr></table></figure><h3 id="变量测试与内容替换"><a href="#变量测试与内容替换" class="headerlink" title="变量测试与内容替换"></a>变量测试与内容替换</h3><p><img src="https://img-blog.csdnimg.cn/2019070509474218.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDQ4NTc0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="环境变量配置文件"><a href="#环境变量配置文件" class="headerlink" title="环境变量配置文件"></a>环境变量配置文件</h4><ol><li><p>source命令</p><ol><li>source配置文件</li><li>作用：让配置文件在修改完以后直接生效，不需要退出shell或者重启系统</li></ol></li><li><p>环境变量配置文件</p><ol><li>主要定义对系统的操作环境生效的系统默认环境变量，比如PATH、HISTSIZE、PS1、HOSTNAME等</li><li>用set命令查看环境变量有哪些、</li></ol></li><li><p>系统主要的环境变量配置文件</p><ol><li>/etc/profile</li><li>/etc/prfile.d/*.sh</li><li>/etc/bashrc</li><li>~/.bash_profile</li><li>~/.bashrc</li></ol><p>前三个对所有用户生效，后两个只对当前用户生效，而且是隐藏文件，但是具有优先级</p></li></ol><h3 id="字符提取命令"><a href="#字符提取命令" class="headerlink" title="字符提取命令"></a>字符提取命令</h3><ol><li><p>gerp 命令</p></li><li><p>cut 命令 （提取列）命令格式：</p><p>cut 【选项】文件名</p><p>选项：</p><p>​    -f 列号：提取第几列</p><p>​    -d 分隔符：按照指定分隔符分隔列</p></li><li><p>printf 命令（格式化输出）</p><ol><li>常用语awk命令</li><li>命令格式：printf  ‘输出类型输出格式’ 输出内容</li><li>输出类型：<ol><li>%ns：输出字符串，n是数字，代表输出几个字符</li><li>%ni：输出整数，n是数字，代表输出几个数字</li><li>%m.nf：输出浮点数，m和n都是数字，如%8.2f代表共输出8位数，其中2位小数。</li></ol></li></ol></li><li><p>awk命令（提取符合条件的列）</p><ol><li>cut命令有局限，不能区分分隔符是空格的情况</li><li>awk命令格式<ol><li>awk ‘条件1{动作1}条件2{动作2}…’ 文件名</li><li>条件（pattern）：<ol><li>关系表达式条件，如x&gt;10,x&gt;=10等</li></ol></li><li>动作：<ol><li>格式化输出</li><li>流程控制语句</li></ol></li></ol></li><li>begin条件，在运行awk前进行初始化操作</li><li>FS命令指定分隔符（awk默认识别的分隔符是制表符和空格）</li><li>end条件，在执行所有条件之后，再执行end条件，与begin相似</li></ol></li><li><p>sed命令</p><p>a) sed是一种轻量级流编辑器。sed主要用于对文本数据进行选取、替换、删除、新增等操作</p><p>b) sed 【选项】 ‘【动作】’ 文件名</p><p>​    –n：一般sed命令会将所有数据输出到屏幕，如果加入该选项，则只会把经过sed命令处理的行输出到屏幕</p><p>​    –e：允许对输入数据应用多条sed动作，动作之间用；隔开</p><p>​    –i：用sed的修改结果直接修改读取数据的文件，而不是由屏幕输出</p><p>c) 动作</p><p>​     a\ ：追加，在当前行后添加一行或多行，添加多行时，除最后一行外，每行末尾需要用“\”代表数据未完结</p><p>​    c\ ：行替换，用c后面的字符串替换原数据行，替换多行时，除最后一行外，每行末尾需用“\”代表数据未完结</p><p>​     i\ ：插入，在当期行前插入一行或多行，插入多行时，除了最后一行外，每行末尾需要用“\” 代表数据未完结</p><p>​    d：删除指定的行</p><p>​    p：打印，输出指定的行</p><p>​    s：字符串替换，用一个字符串替换另外一个字符串。格式为“行范围s/旧字符串/新字符串/g”（和vim中替换格式类似）</p></li></ol><h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a><strong>条件判断</strong></h3><ol><li>按照文件类型进行判断<ol><li>-b：判断该文件是否存在，并且是否为块设备文件，是则为真</li><li>-c：判断该文件是否存在，并且是否为字符设备文件</li><li>-d：判断该文件是否存在，并且是否为目录文件</li><li>-e：判断文件是否存在</li><li>-f：判断该文件是否存在，并且是否为普通文件</li><li>-L：判断该文件是否存在，并且是否为符号链接文件</li><li>-p：判断该文件是否存在，并且是否为管道文件</li><li>-s：判断该文件是否存在，并且是否为非空</li><li>-S：判断该文件是否存在，并且是否为套接字文件</li></ol></li><li>按照文件权限去判断<ol><li>-r：判断该文件是否存在，并且是否该文件拥有读权限</li><li>-w：判断是否存在并且是否该文件拥有写权限</li><li>-x：判断是否存在并且是否该文件拥有执行权限</li><li>-u：判断是否存在并且是否该文件拥有SUID权限</li><li>-g：判断是否存在并且是否该文件拥有SGID权限</li><li>-k：判断是否存在并且是否该文件拥有SBit权限</li></ol></li><li>两个文件之间的判断<ol><li>文件1 -nt 文件2 ：判断文件1的修改时间是否比文件2新（如果新则为真）</li><li>文件1 -ot 文件2：判断修改时间是否比文件2旧</li><li>文件1 -ef 文件2：判断2个文件是否为同一个文件（判断硬链接）</li></ol></li><li>两个数之间的判断<ol><li>数1 -eq 数2：是否相等</li><li>数1 -ne 数2：是否不相等</li><li>-gt：数1是否大于数2</li><li>-lt：数1是否小于数2</li><li>-ge：是否大于等于数2</li><li>-le：是否小于等于数2</li></ol></li><li>字符串之间的判断<ol><li>-z 字符串：判断字符串是否为空（为空则为真）</li><li>-n 字符串：判断字符串是否为非空</li><li>== 字符串：判断2字符串是否相等</li><li>!= 字符串：判断2字符串是否不相等</li></ol></li><li>多重判断<ol><li>判断1 -a 判断2：逻辑与</li><li>-o：逻辑或</li><li>！：逻辑非</li></ol></li></ol><h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a><strong>流程控制</strong></h3><ol><li><p>if语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">#统计根分区硬盘使用情况</span><br><span class="line">rate=$(df -h |grep &quot;/$&quot; |awk &#123;&apos;print $5&apos;&#125; |cut -d &quot;%&quot; -f 1)</span><br><span class="line">if [ $rate -ge 10 ]</span><br><span class="line">then</span><br><span class="line">echo &quot;Warning! / is full!!&quot;</span><br><span class="line">else</span><br><span class="line">echo &quot;/ is OK!&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>注：空格有严格要求。</p></li><li><p>case语句</p></li><li><p>for语句<br>语法一：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">#批量解压/tmp目录下的文件</span><br><span class="line">cd /tmp</span><br><span class="line"></span><br><span class="line">if [-f ls.log]</span><br><span class="line">then</span><br><span class="line">rm -rf /tmp/ls.log</span><br><span class="line">fi</span><br><span class="line">touch ls.log</span><br><span class="line">ls *.tar.gz &gt; ls.log</span><br><span class="line">for i in $(cat ls.log)</span><br><span class="line">do</span><br><span class="line">tar -zxvf $i $&gt; /dev/null</span><br><span class="line">done</span><br><span class="line">rm -rf /tmp/ls.log</span><br></pre></td></tr></table></figure><p>语法二：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">sum=0</span><br><span class="line">for((i=1;i&lt;=100;i++))</span><br><span class="line">do</span><br><span class="line">sum=$(($sum+$i))</span><br><span class="line">done</span><br><span class="line">echo $sum</span><br></pre></td></tr></table></figure><p>例子：批量添加用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">read -p &quot;Please input user name:&quot; -t 30 name</span><br><span class="line">read -p &quot;Please input number of user:&quot; -t 30 num</span><br><span class="line">read -p &quot;Please input passwd of user:&quot; -t 30 password</span><br><span class="line">if [ -n &quot;$name&quot; -a -n &quot;$num&quot; -a -n &quot;$password&quot; ]</span><br><span class="line">then</span><br><span class="line">y=$(echo $num |sed &apos;s/^[0-9]*$//g&apos;)</span><br><span class="line">#判断num输入的是否为纯数字</span><br><span class="line">if [ -z &quot;$y&quot; ]</span><br><span class="line">then</span><br><span class="line">for((i=1;i&lt;=num;i++))</span><br><span class="line">        do                                       /usr/sbin/useradd $name$i &amp;&gt; /dev/null</span><br><span class="line">echo $passwd |/usr/bin/passwd --stdin $name$i $&gt; /dev/null</span><br><span class="line">done</span><br><span class="line">fi</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li><p>while语句</p><p>例子：用while实现批量创建用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">#用while循环实现批量添加用户</span><br><span class="line">#!/bin/bash</span><br><span class="line">read -p &quot;Please input user name:&quot; -t 30 name</span><br><span class="line">read -p &quot;Please input number of user:&quot; -t 30 num</span><br><span class="line">read -p &quot;Please input passwd of user:&quot; -t 30 password</span><br><span class="line">if [ -n $name -a -n $num -a -n $password ]</span><br><span class="line">then</span><br><span class="line">y=$(echo $num |sed &apos;s/^[0-9]*$//g&apos;)</span><br><span class="line">if [ -z $y ]</span><br><span class="line">then</span><br><span class="line">i=1</span><br><span class="line">#不能直接使用&lt;=</span><br><span class="line">while [ $i -le $num ]</span><br><span class="line">do</span><br><span class="line">/usr/sbin/useradd $name$i $&gt; /dev/null</span><br><span class="line">echo $passwd |/usr/bin/passwd --stdin $name$i &amp;&gt; /dev/null</span><br><span class="line">i=$(($i+1))</span><br><span class="line">            done</span><br><span class="line">    fi</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;﻿# Linux学习笔记&lt;/p&gt;
&lt;h2 id=&quot;Linux简介&quot;&gt;&lt;a href=&quot;#Linux简介&quot; class=&quot;headerlink&quot; title=&quot;Linux简介&quot;&gt;&lt;/a&gt;Linux简介&lt;/h2&gt;&lt;p&gt;Ken Thompson 与Dennis Ritchle用C
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>数据挖掘学习笔记</title>
    <link href="http://yoursite.com/2019/06/24/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%9C%9F%E6%9C%AB/"/>
    <id>http://yoursite.com/2019/06/24/数据挖掘学习笔记-期末/</id>
    <published>2019-06-24T03:19:06.105Z</published>
    <updated>2019-07-09T15:03:06.243Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据挖掘的起源"><a href="#数据挖掘的起源" class="headerlink" title="数据挖掘的起源"></a>数据挖掘的起源</h1><h2 id="什么是数据挖掘"><a href="#什么是数据挖掘" class="headerlink" title="什么是数据挖掘"></a>什么是数据挖掘</h2><p><strong>数据挖掘</strong> 是在大型数据库中，自动发现有用的信息的过程。</p><h2 id="数据挖掘的任务"><a href="#数据挖掘的任务" class="headerlink" title="数据挖掘的任务"></a>数据挖掘的任务</h2><ul><li>预测任务</li><li>描述任务</li></ul><p><strong>预测建模</strong>：涉及以说明变量函数的方法为目标变量建立模型。</p><p><strong>关联分析</strong>：用来发现描述数据中强关联特征的模式。</p><p><strong>聚类分析</strong>：发现紧密相关的观测值组群。</p><p><strong>异常检测</strong>：识别其特征显著不同于其他数据的观测值。</p><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a><strong>数据类型</strong></h1><h2 id="数据类型-1"><a href="#数据类型-1" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="属性与度量"><a href="#属性与度量" class="headerlink" title="属性与度量"></a><strong>属性与度量</strong></h3><p><strong>属性</strong> 对象的性质或特性，它因对象而异，或随时间而变。</p><p><strong>测量标度</strong> 将数值或符号值与对象的属性相关联的规则（函数）。</p><p>属性的类型</p><p>​    1.属性的性质</p><p>​    （1）相异性</p><p>​    （2）序</p><p>​    （3）加法</p><p>​    （4）乘法</p><p>​    2.<strong>标称、序数、区间、比率</strong></p><p><strong>非对称的属性</strong> 非0属性值才重要。</p><h3 id="属性集的类型"><a href="#属性集的类型" class="headerlink" title="属性集的类型"></a><strong>属性集的类型</strong></h3><p>数据集的一般特性 </p><p>​    <strong>1.维度     2.稀疏性    3.分辨率</strong></p><h2 id="数据质量"><a href="#数据质量" class="headerlink" title="数据质量"></a>数据质量</h2><h3 id="测量和数据收集问题"><a href="#测量和数据收集问题" class="headerlink" title="测量和数据收集问题"></a>测量和数据收集问题</h3><ol><li>测量误差和数据收集误差</li><li>噪声和伪像</li><li>精度、偏倚、准确率</li><li>离群点</li><li>遗漏值</li><li>不一致的值</li><li>重复数据</li></ol><h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><h3 id="聚集"><a href="#聚集" class="headerlink" title="聚集"></a><strong>聚集</strong></h3><p>将两个或多个对象合并成单个对象。</p><h3 id="抽样"><a href="#抽样" class="headerlink" title="抽样"></a><strong>抽样</strong></h3><p>​    1.抽样方法</p><p>​        （1）无放回抽样</p><p>​        （2）有放回抽样</p><p>​        （3）分层抽样</p><p>​    2.渐进抽样  合适的样本容量可能很难确定则需要使用自适应或渐进抽样方法</p><h3 id="维归约"><a href="#维归约" class="headerlink" title="维归约"></a><strong>维归约</strong></h3><ol><li>维灾难    随着数据维度的增加，许多数据分析变得非常困难。、</li><li>维归约的线性代数技术    <ol><li>主成分分析PCA 是一种用于连续属性的线性代数拘束，它找出新的属性，这些属性是原属性的线性组合，是相互<strong>正交</strong>的，并且捕获了数据的最大变差。</li><li>奇异值分解</li></ol></li></ol><h3 id="特征子集选择"><a href="#特征子集选择" class="headerlink" title="特征子集选择"></a><strong>特征子集选择</strong></h3><ol><li><strong>嵌入方法</strong>  在数据挖掘算法运行期间，算法本身决定使用哪些属性和忽略哪些属性。</li><li><strong>过滤方法</strong>  使用某种独立于数据挖掘任务的方法，在数据挖掘算法运行前进行特征选择。</li><li><strong>包装方法</strong>  这些方法将目标数据挖掘算法作为黑盒，使用类似于前面介绍的理想算法，但通常不枚举所有可能的子集来找出最佳属性子集。</li></ol><h3 id="特征创建"><a href="#特征创建" class="headerlink" title="特征创建"></a><strong>特征创建</strong></h3><p>常常可以由原来的属性创建新的属性集，更有效的捕获数据集中的重要信息。</p><ol><li><strong>特征提取</strong>  由原始数据创建新的特征集称为特征提取。</li><li><strong>映射数据到新的空间</strong>  使用一种完全不同的视角挖掘数据可能揭示出重要和有趣的特征。（傅里叶变换）</li><li><strong>特征构造</strong>  一个或多个由原特征构造的新特征可能比原特征更有用。</li></ol><h3 id="离散化和二元化"><a href="#离散化和二元化" class="headerlink" title="离散化和二元化"></a><strong>离散化和二元化</strong></h3><ol><li>二元化  </li><li><p>连续属性离散化  </p><ol><li><p>非监督离散化  <strong>K均值聚类</strong></p></li><li><p>监督离散化  </p><p>熵 0区间只包含一个类的值  区间中值类出现的频率相等，则其熵最大。</p></li></ol></li><li><p>具有过多值的分类属性</p></li></ol><h3 id="变量变换"><a href="#变量变换" class="headerlink" title="变量变换"></a><strong>变量变换</strong></h3><p>是指用于变量的所有值的变换。</p><ol><li>简单函数</li><li>规范化或标准化  使整个值的集合具有特定的性质。</li></ol><h2 id="相似性和相异性的度量"><a href="#相似性和相异性的度量" class="headerlink" title="相似性和相异性的度量"></a>相似性和相异性的度量</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><ol><li>定义<ol><li>相似度 s ：两个对象相似程度的数值度量</li><li>相异度(距离) d ：两个对象差异程度的数值度量</li></ol></li><li>变换   <ol><li>相似度/相异度变换到[0,1]—&gt; s’ = (s - min_s) / (max_s -min_s)</li><li>从0到∞的变换考虑变换—&gt; d’ = d / (1 + d)</li><li>互相转换 <ol><li>s = -d</li><li>s = 1 / (d + 1)</li><li>s = e^-d</li><li>s = 1 - (d - min_d) / (max_d - min_d)</li></ol></li></ol></li></ol><h3 id="简单属性之间的相似度和相异度"><a href="#简单属性之间的相似度和相异度" class="headerlink" title="简单属性之间的相似度和相异度"></a>简单属性之间的相似度和相异度</h3><h3 id="数据对象之间的相异度"><a href="#数据对象之间的相异度" class="headerlink" title="数据对象之间的相异度"></a>数据对象之间的相异度</h3><p>距离的性质：</p><ol><li>非负性</li><li>对称性</li><li>三角不等式</li></ol><p>集合差、时间</p><h3 id="数据对象之间的相似度"><a href="#数据对象之间的相似度" class="headerlink" title="数据对象之间的相似度"></a>数据对象之间的相似度</h3><h3 id="邻近性度量的例子"><a href="#邻近性度量的例子" class="headerlink" title="邻近性度量的例子"></a>邻近性度量的例子</h3><p><strong>简单匹配系数</strong>：SMC = (f11+f00) / (f01 + f10 + f 11 + f00)</p><p><strong>Jaccard系数</strong>( 处理包含非对称的二元属性的对象)：J = f11 / (f01 + f10 + f11)</p><p>余弦相似度</p><h1 id="探索数据"><a href="#探索数据" class="headerlink" title="探索数据"></a>探索数据</h1><h2 id="汇总统计"><a href="#汇总统计" class="headerlink" title="汇总统计"></a>汇总统计</h2><h3 id="频率与众数"><a href="#频率与众数" class="headerlink" title="频率与众数"></a>频率与众数</h3><h3 id="百分位数"><a href="#百分位数" class="headerlink" title="百分位数"></a>百分位数</h3><h3 id="位置度量：均值和中位数"><a href="#位置度量：均值和中位数" class="headerlink" title="位置度量：均值和中位数"></a>位置度量：均值和中位数</h3><h3 id="散布度量：极差和方差"><a href="#散布度量：极差和方差" class="headerlink" title="散布度量：极差和方差"></a>散布度量：极差和方差</h3><h3 id="多元汇总统计：协方差矩阵"><a href="#多元汇总统计：协方差矩阵" class="headerlink" title="多元汇总统计：协方差矩阵"></a>多元汇总统计：协方差矩阵</h3><h1 id="分类：基本概念、决策树与模型评估"><a href="#分类：基本概念、决策树与模型评估" class="headerlink" title="分类：基本概念、决策树与模型评估"></a>分类：基本概念、决策树与模型评估</h1><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><p><strong>分类</strong>  就是通过学习得到一个目标函数f，把每个属性集x映射到一个预先定义的类标号y。</p><h2 id="解决分类问题的一般方法"><a href="#解决分类问题的一般方法" class="headerlink" title="解决分类问题的一般方法"></a>解决分类问题的一般方法</h2><h2 id="决策树归纳"><a href="#决策树归纳" class="headerlink" title="决策树归纳"></a>决策树归纳</h2><h3 id="决策树的工作原理"><a href="#决策树的工作原理" class="headerlink" title="决策树的工作原理"></a>决策树的工作原理</h3><h3 id="如何建立决策树"><a href="#如何建立决策树" class="headerlink" title="如何建立决策树"></a>如何建立决策树</h3><ol><li>Hunt算法</li></ol><h3 id="表示属性测试条件的方法"><a href="#表示属性测试条件的方法" class="headerlink" title="表示属性测试条件的方法"></a>表示属性测试条件的方法</h3><h3 id="选择最佳划分的度量"><a href="#选择最佳划分的度量" class="headerlink" title="选择最佳划分的度量"></a>选择最佳划分的度量</h3><p>熵Entropy(t) = -∑ pi log pi</p><p>Gini = 1 - ∑ (pi)²</p><p>erro = 1 - max(pi)</p><p> 斜决策树</p><h2 id="模型的过分拟合"><a href="#模型的过分拟合" class="headerlink" title="模型的过分拟合"></a>模型的过分拟合</h2><p>当决策树很小时，训练和校验误差都很大，这种情况称为<strong>模型拟合不足</strong>，原因是模型尚未学习到数据的真实结构。</p><p>树的规模变得太大，即使训练误差还在继续降低，但是校验误差开始增大，这种现象称为<strong>模型过分拟合</strong></p><h3 id="噪声导致的过分拟合"><a href="#噪声导致的过分拟合" class="headerlink" title="噪声导致的过分拟合"></a>噪声导致的过分拟合</h3><h3 id="缺乏代表性样本导致的过分拟合"><a href="#缺乏代表性样本导致的过分拟合" class="headerlink" title="缺乏代表性样本导致的过分拟合"></a>缺乏代表性样本导致的过分拟合</h3><h3 id="过分拟合与多重比较过程"><a href="#过分拟合与多重比较过程" class="headerlink" title="过分拟合与多重比较过程"></a>过分拟合与多重比较过程</h3><h3 id="泛化误差估计"><a href="#泛化误差估计" class="headerlink" title="泛化误差估计"></a><strong>泛化误差估计</strong></h3><ol><li>使用再代入估计</li><li>综合模型复杂度<ol><li>奥卡姆剃刀：给定两个具有相同泛化误差的模型，较简单的模型比较复杂的模型更可取。</li><li>最小描述长度原则</li></ol></li><li>估计统计上界</li><li>使用确认集</li></ol><h3 id="处理决策树归纳中的过分拟合"><a href="#处理决策树归纳中的过分拟合" class="headerlink" title="处理决策树归纳中的过分拟合"></a>处理决策树归纳中的过分拟合</h3><ol><li>先剪枝（提前终止规则）   在完成全增长的决策树之前就停止决策树的生长。</li><li>后剪枝    初始决策树按照最大规模生长，然后进行剪枝的步骤，按照自底向上的方式修剪完全增长的决策树。<ol><li>用新的叶结点替换子树</li><li>用子树中最长使用的分支代替子树</li></ol></li></ol><h1 id="分类：其他技术"><a href="#分类：其他技术" class="headerlink" title="分类：其他技术"></a>分类：其他技术</h1><h2 id="最近邻分类器"><a href="#最近邻分类器" class="headerlink" title="最近邻分类器"></a>最近邻分类器</h2><p><strong>Rote分类器</strong>：（消极学习）记住整个训练数据，仅当测试实例的属性和某个训练样例完全匹配时才进行分类。使该方法更灵活的一个途径就是找出和测试样例的属性相对接近的所有训练样例。这些训练样例称为<strong>最近邻</strong>，可以用来确定测试样例的类标号。</p><h3 id="最近邻分类器的特征"><a href="#最近邻分类器的特征" class="headerlink" title="最近邻分类器的特征"></a>最近邻分类器的特征</h3><ul><li>不必维护源自数据的抽象或模型。</li><li>不需要建立模型</li><li>对噪声敏感</li><li>可是生成任意形状的决策边界</li></ul><h2 id="贝叶斯分类器"><a href="#贝叶斯分类器" class="headerlink" title="贝叶斯分类器"></a>贝叶斯分类器</h2><p>P(Y | X)称为Y的后验概率，P(Y)称为Y的先验概率</p><h3 id="朴素贝叶斯分类器"><a href="#朴素贝叶斯分类器" class="headerlink" title="朴素贝叶斯分类器"></a>朴素贝叶斯分类器</h3><h3 id="贝叶斯信念网络（BBN）"><a href="#贝叶斯信念网络（BBN）" class="headerlink" title="贝叶斯信念网络（BBN）"></a>贝叶斯信念网络（BBN）</h3><h2 id="人工神经网络（ANN）"><a href="#人工神经网络（ANN）" class="headerlink" title="人工神经网络（ANN）"></a>人工神经网络（ANN）</h2><p>人工神经网络从信息处理角度对人脑神经元网络进行抽象， 建立某种简单模型，按不同的连接方式组成不同的网络。</p><h3 id="感知器"><a href="#感知器" class="headerlink" title="感知器"></a>感知器</h3><h2 id="组合方法"><a href="#组合方法" class="headerlink" title="组合方法"></a>组合方法</h2><h3 id="装袋"><a href="#装袋" class="headerlink" title="装袋"></a>装袋</h3><p>一种根据均匀概率分布从数据集中重复抽样（有放回的）的技术。</p><h3 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h3><p><strong>AdaBost</strong></p><h3 id="随机森林"><a href="#随机森林" class="headerlink" title="随机森林"></a>随机森林</h3><ol><li>Forest-RI：随机选择F个输入特征来对决策树的结点进行分裂</li><li>Forest-RC：在每个结点，产生F个这种随机组合的新特征，并且从中选择最好的来分裂结点。</li><li>在决策树的每一个结点，从F个最佳划分中随机选择一个。</li></ol><h1 id="关联分析：基本概念和算法"><a href="#关联分析：基本概念和算法" class="headerlink" title="关联分析：基本概念和算法"></a>关联分析：基本概念和算法</h1><p><strong>关联分析</strong>：用于发现隐藏在大型数据集中的有意义的联系。</p><h2 id="问题定义"><a href="#问题定义" class="headerlink" title="问题定义"></a>问题定义</h2><p>二元表示</p><p><strong>项集</strong>：在关联分析中，包含0个或者多个项的集合。如果一个项集包含k个项，则称它为k-项集。例如｛啤酒，尿布，牛奶｝是一个3-项集。</p><p><strong>支持度计数</strong>：包含特定项集的事物个数。</p><p><strong>关联规则</strong>：X → Y的蕴涵表达式，其中X和Y是不相交的项集，关联规则的强度可以用它的<strong>支持度</strong>和<strong>置信度</strong>度量。</p><p>关联规则挖掘任务：</p><ol><li>频繁项集产生：其目标是发现满足最小支持阈值的所有项集，这些项集称作频繁项集。</li><li>规则的产生：其目标是从上一步发现的频繁项集中提取所有高置信度的规则，这些规则称作<strong>强规则</strong>。</li></ol><h2 id="频繁项集的产生"><a href="#频繁项集的产生" class="headerlink" title="频繁项集的产生"></a>频繁项集的产生</h2><h3 id="先验原理"><a href="#先验原理" class="headerlink" title="先验原理"></a>先验原理</h3><p>如果一个项集是频繁的，则它的所有子集一定也是频繁的。</p><h3 id="Apriori（先验）算法的频繁项集产生"><a href="#Apriori（先验）算法的频繁项集产生" class="headerlink" title="Apriori（先验）算法的频繁项集产生"></a>Apriori（先验）算法的频繁项集产生</h3><ol><li></li><li></li></ol><h3 id="候选的产生与剪枝"><a href="#候选的产生与剪枝" class="headerlink" title="候选的产生与剪枝"></a>候选的产生与剪枝</h3><ol><li>蛮力方法：把所有的k-项集都看作可能的候选，然后使用候选剪枝除去不必要的候选。</li><li>Fk-1 * F1方法：使用Fk-1项集和F1项集组成Fk项集，需要避免产生重复的候选项集。</li><li>Fk-1 * Fk-1方法：仅当2个Fk-1项集的前k-2项都相同时，合并成Fk项。</li></ol><h3 id="支持度计数"><a href="#支持度计数" class="headerlink" title="支持度计数"></a>支持度计数</h3><p>使用Hash树</p><h2 id="规则产生"><a href="#规则产生" class="headerlink" title="规则产生"></a>规则产生</h2><p>将项集Y分为两个非空的子集X和Y-X，使得X → Y - X满足置信度阈值。</p><p>如果规则X → Y - X不满足置信度阈值，则形如X’ → Y - X’的规则一定也不满足置信度阈值，其中X’是X的子集。</p><h1 id="聚类分析：基本概念和算法"><a href="#聚类分析：基本概念和算法" class="headerlink" title="聚类分析：基本概念和算法"></a>聚类分析：基本概念和算法</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="什么是聚类分析"><a href="#什么是聚类分析" class="headerlink" title="什么是聚类分析"></a>什么是聚类分析</h3><p>聚类分析仅根据在数据中发现的描述对象及其关系的信息，将数据对象分组。其目标是，组内的对象相互之间是相似的（相关的），而不同组中的对象是不同的（不相关的）。组内的相似性（同质性）越大，组件差别越大，聚类就越好。</p><p>聚类分析为<strong>非监督分类</strong>。</p><h2 id="K均值"><a href="#K均值" class="headerlink" title="K均值"></a>K均值</h2><h3 id="基本K均值算法"><a href="#基本K均值算法" class="headerlink" title="基本K均值算法"></a><strong>基本K均值算法</strong></h3><ol><li><strong>选择K个点作为初始质心</strong></li><li><strong>repeat</strong></li><li>​    <strong>将每个点指派到最近的质心，形成K个簇</strong></li><li>​    <strong>重新计算每个簇的质心</strong></li><li><strong>until 质心不发生变化</strong></li></ol><h2 id="凝聚层次聚类"><a href="#凝聚层次聚类" class="headerlink" title="凝聚层次聚类"></a>凝聚层次聚类</h2><h3 id="基本凝聚层次聚类算法"><a href="#基本凝聚层次聚类算法" class="headerlink" title="基本凝聚层次聚类算法"></a>基本凝聚层次聚类算法</h3><ol><li>如果需要，计算邻近度矩阵</li><li>repeat</li><li>​    合并最接近的两个簇</li><li>​    更新邻近性矩阵，以及映新的簇与原来的簇之间的邻近性</li><li>until 仅剩下一个簇</li></ol><h3 id="特殊技术"><a href="#特殊技术" class="headerlink" title="特殊技术"></a>特殊技术</h3><ol><li>样本数据</li><li>单链或MIN</li><li>全链或MAN或团</li><li>组平均</li><li>Ward方法</li></ol><h2 id="DBSCAN"><a href="#DBSCAN" class="headerlink" title="DBSCAN"></a>DBSCAN</h2><h3 id="DBSCAN算法"><a href="#DBSCAN算法" class="headerlink" title="DBSCAN算法"></a>DBSCAN算法</h3><ol><li>将所有点标记为核心点、边界点、噪声点。</li><li>删除噪声点。</li><li>为距离为Eps之内的所有核心点之间赋予一条边。</li><li>每组连通的核心点形成一个簇。</li><li>将每个边界点指派到一个与之关联的核心点的簇中。</li></ol><p>SSB：<strong>簇质心</strong>到所有数据点的<strong>总均值</strong>的距离的平方和</p><p>SSE：凝聚度</p><p>TSS：每个点到数据的总均值的距离的平方和。</p><p>TSS = SSE + SSB</p><h1 id="异常检测"><a href="#异常检测" class="headerlink" title="异常检测"></a>异常检测</h1><p><strong>异常检测</strong>的目标是发现与大部分其他对象不同的对象。</p><h2 id="预备知识-1"><a href="#预备知识-1" class="headerlink" title="预备知识"></a>预备知识</h2><h3 id="异常检测方法"><a href="#异常检测方法" class="headerlink" title="异常检测方法"></a>异常检测方法</h3><ul><li>基于模型的技术</li><li>基于邻近度的技术</li><li>基于密度的技术</li></ul><h3 id="类标号的使用"><a href="#类标号的使用" class="headerlink" title="类标号的使用"></a>类标号的使用</h3><ul><li>监督的异常检测  要求存在异常类和正常类的训练集</li><li>非监督的异常检测 </li><li>半监督的异常检测</li></ul><h2 id="统计方法"><a href="#统计方法" class="headerlink" title="统计方法"></a>统计方法</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据挖掘的起源&quot;&gt;&lt;a href=&quot;#数据挖掘的起源&quot; class=&quot;headerlink&quot; title=&quot;数据挖掘的起源&quot;&gt;&lt;/a&gt;数据挖掘的起源&lt;/h1&gt;&lt;h2 id=&quot;什么是数据挖掘&quot;&gt;&lt;a href=&quot;#什么是数据挖掘&quot; class=&quot;headerlink
      
    
    </summary>
    
    
      <category term="数据挖掘" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode299. 猜数字游戏</title>
    <link href="http://yoursite.com/2019/06/15/leetcode299.%20%E7%8C%9C%E6%95%B0%E5%AD%97%E6%B8%B8%E6%88%8F/"/>
    <id>http://yoursite.com/2019/06/15/leetcode299. 猜数字游戏/</id>
    <published>2019-06-15T06:43:33.368Z</published>
    <updated>2019-06-19T02:23:55.266Z</updated>
    
    <content type="html"><![CDATA[<p>﻿## 题目</p><blockquote><p>你正在和你的朋友玩 猜数字（Bulls and  Cows）游戏：你写下一个数字让你的朋友猜。每次他猜测后，你给他一个提示，告诉他有多少位数字和确切位置都猜对了（称为“Bulls”, 公牛），有多少位数字猜对了但是位置不对（称为“Cows”, 奶牛）。你的朋友将会根据提示继续猜，直到猜出秘密数字。</p><p>请写出一个根据秘密数字和朋友的猜测数返回提示的函数，用 A 表示公牛，用 B 表示奶牛。</p><p>请注意秘密数字和朋友的猜测数都可能含有重复数字。</p><p><strong>示例 1:</strong></p><p><strong>输入:</strong> secret = “1807”, guess = “7810”</p><p><strong>输出:</strong> “1A3B”</p><p><strong>解释:</strong> 1 公牛和 3 奶牛。公牛是 8，奶牛是 0, 1 和 7。<br><strong>示例 2:</strong></p><p><strong>输入:</strong> secret = “1123”, guess = “0111”</p><p><strong>输出:</strong> “1A1B”</p><p><strong>解释:</strong> 朋友猜测数中的第一个 1 是公牛，第二个或第三个 1 可被视为奶牛。 说明: 你可以假设秘密数字和朋友的猜测数都只包含数字，并且它们的长度永远相等。</p><p>来源：力扣（LeetCode） 链接：<a href="https://leetcode-cn.com/problems/bulls-and-cows" target="_blank" rel="noopener">https://leetcode-cn.com/problems/bulls-and-cows</a></p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>使用一个countA记录A的个数，countB记录B的个数，长度为10的数组nums记录secret中不是A的数字个数<br>第一步：遍历一遍secret，如果 <strong>secret.charAt(i)==guess.charAt(i)</strong> 则countA++，如果不满足，则记录到nums中。<br>第二步：遍历一遍guess，如果<strong>secret.charAt(i)！=guess.charAt(i) &amp;&amp; nums[guess.charAt(i)- ‘0’] &gt; 0</strong> 则说明secret中有这个数字，但是位置不对，即countB++；nums[guess.charAt(i)- ‘0’]–；<br>最后countA+”A”+countB+”B”即为所求。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public String getHint(String secret, String guess) &#123;</span><br><span class="line">        int[] nums = new int[10];</span><br><span class="line">        int countA = 0, countB = 0;</span><br><span class="line">        for (int i = 0; i &lt; secret.length(); i++) &#123;</span><br><span class="line">            char tmp = secret.charAt(i);</span><br><span class="line">            if (tmp == guess.charAt(i)) &#123;</span><br><span class="line">                countA++;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[tmp-&apos;0&apos;]++;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; guess.length(); i++) &#123;</span><br><span class="line">            char tmp = guess.charAt(i);</span><br><span class="line">            if (tmp != secret.charAt(i) &amp;&amp; nums[tmp - &apos;0&apos;] &gt; 0) &#123;</span><br><span class="line">                countB++;</span><br><span class="line">                nums[tmp - &apos;0&apos;]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return countA+&quot;A&quot;+countB+&quot;B&quot;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p><img src="https://img-blog.csdnimg.cn/20190615144319367.png" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;﻿## 题目&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;你正在和你的朋友玩 猜数字（Bulls and  Cows）游戏：你写下一个数字让你的朋友猜。每次他猜测后，你给他一个提示，告诉他有多少位数字和确切位置都猜对了（称为“Bulls”, 公牛），有多少位数字猜对了但是位置不
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode274. H指数</title>
    <link href="http://yoursite.com/2019/06/13/leetcode274.%20H%E6%8C%87%E6%95%B0/"/>
    <id>http://yoursite.com/2019/06/13/leetcode274. H指数/</id>
    <published>2019-06-13T11:52:00.883Z</published>
    <updated>2019-06-19T02:23:34.816Z</updated>
    
    <content type="html"><![CDATA[<p>﻿## 题目</p><blockquote><p>给定一位研究者论文被引用次数的数组（被引用次数是非负整数）。编写一个方法，计算出研究者的 h 指数。</p><p>h 指数的定义: “h 代表“高引用次数”（high citations），一名科研人员的 h 指数是指他（她）的 （N 篇论文中）至多有<br>h 篇论文分别被引用了至少 h 次。（其余的 N - h 篇论文每篇被引用次数不多于 h 次。）”<br><strong>示例:</strong></p><p><strong>输入:</strong> citations = [3,0,6,1,5]<br><strong>输出:</strong> 3<br><strong>解释:</strong> 给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 3, 0, 6, 1, 5 次。<br>     由于研究者有 3 篇论文每篇至少被引用了 3 次，其余两篇论文每篇被引用不多于 3 次，所以她的 h 指数是 3。</p><p>来源：力扣（LeetCode） 链接：<a href="https://leetcode-cn.com/problems/h-index" target="_blank" rel="noopener">https://leetcode-cn.com/problems/h-index</a></p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>先对数组排序，努力的读懂题目，其实<strong>len-i和citations[i]中小的一个</strong>就是高引用次数，而且很容易看出len-i一直在递减，citations[i]排序后一直在递增，所以找到最大的一个h即len-i小于等于citations[i]的第一个。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int hIndex(int[] citations) &#123;</span><br><span class="line">        Arrays.sort(citations);</span><br><span class="line">        int len = citations.length;</span><br><span class="line">        for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">            int count = len - i;</span><br><span class="line">            if (count &lt;= citations[i])</span><br><span class="line">                return count;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p><img src="https://img-blog.csdnimg.cn/20190613195141427.png" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;﻿## 题目&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一位研究者论文被引用次数的数组（被引用次数是非负整数）。编写一个方法，计算出研究者的 h 指数。&lt;/p&gt;
&lt;p&gt;h 指数的定义: “h 代表“高引用次数”（high citations），一名科研人员的 h 指数是指
      
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Linux面试常考指令</title>
    <link href="http://yoursite.com/2019/06/11/Linux%E5%AD%A6%E4%B9%A0-%E9%9D%A2%E8%AF%95/"/>
    <id>http://yoursite.com/2019/06/11/Linux学习-面试/</id>
    <published>2019-06-11T08:35:05.293Z</published>
    <updated>2019-06-11T09:25:01.826Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux学习"><a href="#Linux学习" class="headerlink" title="Linux学习"></a>Linux学习</h2><p>常用指令记录</p><p><strong>find</strong></p><p>作用：在指定目录下查找文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">语法： find path [options] params</span><br></pre></td></tr></table></figure><p>find ~ -name “1.txt” ：根据文件名精确查找~下的文件</p><p>find / -name “target*” :根据文件名模糊查找/下的文件</p><p>find / -iname”target*” :根据文件名模糊查找/下的文件，但是部分大小写</p><p>man find : 更多关于find指令的使用说明</p><p><strong>grep</strong></p><p>作用：查找文本中含有目标字符的行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">语法：grep [options] pattern file</span><br></pre></td></tr></table></figure><p>grep “test” test.txt : 找出test.txt文件中含test的行</p><p>grep “test” : 接收输入流输入的字符串， 找出其中含test的行</p><p><strong>管道操作符 |</strong></p><p>作用：使管道上一个指令的输出作为下一个指令的输入</p><p>使用管道注意的要点</p><ul><li>只处理前一个命令的正确输出，如前一个命令错误，则不再处理</li><li>右边的指令必须能接收标准输入流，否则传递过程中数据会被抛弃</li><li>常用接收输入流的指令有sed, awk, grep, cut, head, top, less, more, wc, join, sort, split</li></ul><p><strong>awk</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">语法：awk [options] &apos;cmd&apos; file</span><br></pre></td></tr></table></figure><p>作用：每一行根据空格去切片，$1表示第一列，$2表示第二列</p><p>awk ‘{print $1, $4}’ netstat.txt : 输出netsta.txt中第一列和第四列的数据</p><p>awk ‘$1==”tcp” &amp;&amp; $2==1 {print $0}’ netstat.txt：输出第一列为tcp，第二列为1的行</p><p>awk -F “,” ‘{print $2}’ test.txt ： 把test.txt文件中按照，分列，输出第二列的数据</p><p>awk ‘{enginearr[$1]++}END{for(i in enginearr)print i “\t” enginearr[i]}’：使用一个数组记录第一列的数据，统计其个数</p><p><strong>sed</strong></p><p>流编辑器，适用于对文本的行内容进行处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">语法：sed [option] &apos;sed command&apos; filename</span><br></pre></td></tr></table></figure><p>sed ‘s/^Str/String/‘ replace.java ：把开头Str替换成String，不写回。</p><p>sed -i ‘s/ \.$/\;/‘ replace.java：把结尾的.替换成;并写回。</p><p>sed -i ‘s/Jack/me/‘ replace.java：把文中第一次出现的Jack替换成me</p><p>sed -i ‘s/Jack/me/g’ replace.java：把文中出现的所有Jack替换成me</p><p>sed -i ‘/Integer/d’ replace.java： 把文中出现Integer的行删除</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Linux学习&quot;&gt;&lt;a href=&quot;#Linux学习&quot; class=&quot;headerlink&quot; title=&quot;Linux学习&quot;&gt;&lt;/a&gt;Linux学习&lt;/h2&gt;&lt;p&gt;常用指令记录&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;find&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;作用：在指定目
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>leetcode230. 二叉搜索树中第K小的元素</title>
    <link href="http://yoursite.com/2019/06/10/leetcode230.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/"/>
    <id>http://yoursite.com/2019/06/10/leetcode230. 二叉搜索树中第K小的元素/</id>
    <published>2019-06-10T13:56:50.499Z</published>
    <updated>2019-06-11T04:25:18.695Z</updated>
    
    <content type="html"><![CDATA[<p>﻿## 题目</p><blockquote><p>给定一个二叉搜索树，编写一个函数 kthSmallest 来查找其中第 k 个最小的元素。</p><p><strong>说明：</strong> 你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。</p><p><strong>示例 1:</strong></p><p><strong>输入:</strong> root = [3,1,4,null,2], k = 1<br><img src="https://img-blog.csdnimg.cn/20190610215238393.png" alt="在这里插入图片描述"><br><strong>输出:</strong> 1<br><strong>示例 2:</strong></p><p><strong>输入:</strong> root = [5,3,6,2,4,null,null,1], k = 3<br>       <img src="https://img-blog.csdnimg.cn/20190610215250643.png" alt="5      / \     3   6    / \    2   4   /  1"><br><strong>输出:</strong> 3</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst" target="_blank" rel="noopener">https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst</a></p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>因为二叉搜索树的左子树的元素全部小于根节点，右子树的元素大于根节点，因此<br>第一步： 先计算出左子树的个数；<br>第二步： 判断左子树个数left跟k的关系</p><pre><code>1. left &gt;= k则说明题目所求第k小的元素在左子树上，递归调用原函数2. left+1 == k则说明所求元素为根节点元素3. 1、2不成立则在右子树上，而所求元素变为第k-left-1小的元素。</code></pre><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int kthSmallest(TreeNode root, int k) &#123;</span><br><span class="line">        int left = helper(root.left);</span><br><span class="line">        if (left &gt;= k) &#123;</span><br><span class="line">            return kthSmallest(root.left, k);</span><br><span class="line">        &#125; else if (left + 1 == k) &#123;</span><br><span class="line">            return root.val;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return kthSmallest(root.right, k - left-1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public int helper(TreeNode root) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        return 1 + helper(root.left) + helper(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p><img src="https://img-blog.csdnimg.cn/2019061021564129.png" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;﻿## 题目&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个二叉搜索树，编写一个函数 kthSmallest 来查找其中第 k 个最小的元素。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt; 你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。&lt;/p&gt;
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode229. 求众数 II</title>
    <link href="http://yoursite.com/2019/06/10/leetcode229.%20%E6%B1%82%E4%BC%97%E6%95%B0%20II/"/>
    <id>http://yoursite.com/2019/06/10/leetcode229. 求众数 II/</id>
    <published>2019-06-10T13:18:29.275Z</published>
    <updated>2019-06-11T04:25:04.227Z</updated>
    
    <content type="html"><![CDATA[<p>﻿## 题目</p><blockquote><p>给定一个大小为 n 的数组，找出其中所有出现超过 ⌊ n/3 ⌋ 次的元素。</p><p>说明: 要求算法的时间复杂度为 O(n)，空间复杂度为 O(1)。</p><p><strong>示例 1:</strong></p><p><strong>输入:</strong> [3,2,3]<br><strong>输出:</strong> [3]<br><strong>示例 2:</strong></p><p><strong>输入:</strong> [1,1,1,3,3,2,2,2]<br><strong>输出:</strong> [1,2]</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/majority-element-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/majority-element-ii</a></p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>使用摩尔投票法，得出超过⌊ n/3 ⌋ 次的元素，因为只可能有0-2个数，所以使用2个变量来保存即可。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; majorityElement(int[] nums) &#123;</span><br><span class="line">        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">        int numA = 0, numB = 0, countA = 0, countB = 0;</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            if (nums[i] == numA) &#123;</span><br><span class="line">                countA++;</span><br><span class="line">            &#125; else if (numB == nums[i]) &#123;</span><br><span class="line">                countB++;</span><br><span class="line">            &#125; else if (countA == 0) &#123;</span><br><span class="line">                numA = nums[i];</span><br><span class="line">                countA++;</span><br><span class="line">            &#125; else if (countB == 0) &#123;</span><br><span class="line">                numB = nums[i];</span><br><span class="line">                countB++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                countA--;</span><br><span class="line">                countB--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        countA = 0;</span><br><span class="line">        countB = 0;</span><br><span class="line">        for (int num: nums)&#123;</span><br><span class="line">            if (numA == num) &#123;</span><br><span class="line">                countA++;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (numB == num) &#123;</span><br><span class="line">                countB++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (countA &gt; nums.length/3)&#123;</span><br><span class="line">            res.add(numA);</span><br><span class="line">        &#125;</span><br><span class="line">        if (countB &gt; nums.length/3)&#123;</span><br><span class="line">            res.add(numB);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p><img src="https://img-blog.csdnimg.cn/20190610211817239.png" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;﻿## 题目&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个大小为 n 的数组，找出其中所有出现超过 ⌊ n/3 ⌋ 次的元素。&lt;/p&gt;
&lt;p&gt;说明: 要求算法的时间复杂度为 O(n)，空间复杂度为 O(1)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode228. 汇总区间</title>
    <link href="http://yoursite.com/2019/06/10/leetcode228.%20%E6%B1%87%E6%80%BB%E5%8C%BA%E9%97%B4/"/>
    <id>http://yoursite.com/2019/06/10/leetcode228. 汇总区间/</id>
    <published>2019-06-10T08:12:28.296Z</published>
    <updated>2019-06-11T04:25:29.879Z</updated>
    
    <content type="html"><![CDATA[<p>﻿## 题目</p><p>给定一个无重复元素的有序整数数组，返回数组区间范围的汇总。</p><p><strong>示例 1:</strong></p><p><strong>输入:</strong> [0,1,2,4,5,7]<br><strong>输出:</strong> [“0-&gt;2”,”4-&gt;5”,”7”]<br><strong>解释:</strong> 0,1,2 可组成一个连续的区间; 4,5 可组成一个连续的区间。<br><strong>示例 2:</strong></p><p><strong>输入:</strong> [0,2,3,4,6,8,9]<br><strong>输出:</strong> [“0”,”2-&gt;4”,”6”,”8-&gt;9”]<br><strong>解释:</strong> 2,3,4 可组成一个连续的区间; 8,9 可组成一个连续的区间。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/summary-ranges" target="_blank" rel="noopener">https://leetcode-cn.com/problems/summary-ranges</a></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>使用双指针，判断<strong>nums[next] - nums[pre] == next-pre</strong>即可。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><pre><code>class Solution {    public List&lt;String&gt; summaryRanges(int[] nums) {        if (nums.length &lt; 1) {            return new ArrayList&lt;&gt;();        }        List&lt;String&gt; res = new ArrayList&lt;&gt;();        if (nums.length &lt; 2) {            res.add(String.valueOf(nums[0]));            return res;        }        int pre = 0, next = 1;        while (pre &lt; nums.length) {            while (next &lt; nums.length &amp;&amp; nums[next] - nums[pre] == next-pre) {                next++;            }            if (next - 1 != pre) {                res.add(nums[pre] + &quot;-&gt;&quot; + nums[next-1]);            } else {                res.add(String.valueOf(nums[pre]));            }            pre = next;        }        return res;    }}</code></pre><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p><img src="https://img-blog.csdnimg.cn/20190610161209582.png" alt="&gt; 这里是引用"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;﻿## 题目&lt;/p&gt;
&lt;p&gt;给定一个无重复元素的有序整数数组，返回数组区间范围的汇总。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入:&lt;/strong&gt; [0,1,2,4,5,7]&lt;br&gt;&lt;strong&gt;输出:&lt;/stron
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode220. 存在重复元素 III</title>
    <link href="http://yoursite.com/2019/06/06/leetcode220.%20%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%20III/"/>
    <id>http://yoursite.com/2019/06/06/leetcode220. 存在重复元素 III/</id>
    <published>2019-06-06T03:26:32.976Z</published>
    <updated>2019-06-06T07:57:25.114Z</updated>
    
    <content type="html"><![CDATA[<p>﻿## 题目</p><blockquote><p>给定一个整数数组，判断数组中是否有两个不同的索引 i 和 j，使得 nums [i] 和 nums [j] 的差的绝对值最大为 t，并且 i<br>和 j 之间的差的绝对值最大为 ķ。</p><p><strong>示例 1:</strong></p><p><strong>输入:</strong> nums = [1,2,3,1], k = 3, t = 0<br><strong>输出:</strong> true<br><strong>示例 2:</strong></p><p><strong>输入:</strong> nums = [1,0,1,1], k = 1, t = 2<br><strong>输出</strong>: true<br><strong>示例 3:</strong></p><p><strong>输入:</strong> nums = [1,5,9,1,5,9], k = 2, t = 3<br><strong>输出:</strong> false</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>此题有2种解题思路。<br>第一种：根据数组下标，根据下标相差不超过k去找出符合条件的元素<br>第二种：根据数组元素的值，根据值不超过t去找出符合条件的元素<br><strong>思路一：</strong>  这思路比较容易想到，<br>首先，遍历数组nums[i]；<br>然后，再去找出[i,i+k]之间是否有符合题目要求的元素；<br>如果有，则返回true，没有则继续查找。<br>在此题中的样例40这种思路是ac不了的，必须加个判断条件<strong>if(k==10000) return false;</strong><br>（才能通过，这条件也是我使用第二种方法ac之后看了别人的代码才知道的。）<br><strong>思路二：</strong><br>第一步： 使用一个数组，保存每一个nums的值和对应的下标<br>第二步： 通过其中的值进行排序<br>第三步： <strong>根据nums [i] 和 nums [j] 的差的绝对值小于等于t</strong>去判断<strong>nums [i] 和 nums [j] 的下标的差是否是小于等于k</strong>，如果是则返回true，不是则继续查找。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><p>思路一<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) &#123;</span><br><span class="line">        int pre = 0, next = 1;</span><br><span class="line">        if(k==10000) return false;</span><br><span class="line">        while (pre &lt; nums.length) &#123;</span><br><span class="line">            while (next - pre &lt;= k) &#123;</span><br><span class="line">                if (next &gt;= nums.length) break;</span><br><span class="line">                if (Math.abs((long)nums[next] - nums[pre]) &lt;= t) &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">                next++;</span><br><span class="line">            &#125;</span><br><span class="line">            next = ++pre + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>思路二</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) &#123;</span><br><span class="line">        int[][] numsAndIndex = new int[nums.length][2];</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            numsAndIndex[i][0] = nums[i];</span><br><span class="line">            numsAndIndex[i][1] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        //使用匿名函数Overrides method in Comparator</span><br><span class="line">        //根据二位数组的第一位去排序</span><br><span class="line">        Arrays.sort(numsAndIndex,(a,b) -&gt; (a[0]-b[0]));</span><br><span class="line">        for (int i = 0; i &lt; numsAndIndex.length; i++) &#123;</span><br><span class="line">            for (int j = i+1; j &lt; numsAndIndex.length; j++) &#123;</span><br><span class="line">                if (Math.abs((long)numsAndIndex[j][0] - numsAndIndex[i][0]) &gt; t)&#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                if (Math.abs(numsAndIndex[j][1] - numsAndIndex[i][1]) &lt;= k)&#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p><strong>第一种</strong><br>成功<br>显示详情<br>执行用时 : 0 ms, 在Contains Duplicate III的Java提交中击败了100.00% 的用户<br>内存消耗 : 37.3 MB, 在Contains Duplicate III的Java提交中击败了81.18% 的用户<br><strong>第二种</strong><br>成功<br>显示详情<br>执行用时 : 90 ms, 在Contains Duplicate III的Java提交中击败了11.48% 的用户<br>内存消耗 : 38.8 MB, 在Contains Duplicate III的Java提交中击败了69.10% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;﻿## 题目&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个整数数组，判断数组中是否有两个不同的索引 i 和 j，使得 nums [i] 和 nums [j] 的差的绝对值最大为 t，并且 i&lt;br&gt;和 j 之间的差的绝对值最大为 ķ。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode216. 组合总和 III</title>
    <link href="http://yoursite.com/2019/05/30/leetcode216.%20%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%20III/"/>
    <id>http://yoursite.com/2019/05/30/leetcode216. 组合总和 III/</id>
    <published>2019-05-30T11:14:19.721Z</published>
    <updated>2019-06-05T12:45:49.491Z</updated>
    
    <content type="html"><![CDATA[<p>﻿## 题目</p><blockquote><p>找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。</p><p><strong>说明：</strong></p><p>所有数字都是正整数。 解集不能包含重复的组合。<br><strong>示例 1:</strong></p><p><strong>输入:</strong> k = 3, n = 7<br><strong>输出:</strong> [[1,2,4]]<br><strong>示例 2:</strong></p><p><strong>输入:</strong> k = 3, n = 9<br><strong>输出:</strong> [[1,2,6], [1,3,5], [2,3,4]]</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>就是用深度搜索进行k个(1-9)的数全排列，如果等于n，则放入结果集，注意一下去重即可。<br>去重的思路：在dfs方法传入一个参数num，每次全排列的下一个位数都从num+1开始，就可以去除重复的值了。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combinationSum3(int k, int n) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res =  new ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        dfs(res, list, n,k,0,0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void dfs(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; list, int n, int k, int sum, int num) &#123;</span><br><span class="line">        if(sum &gt; n) return;</span><br><span class="line">        if (list.size() == k)&#123;</span><br><span class="line">            if(sum == n) &#123;</span><br><span class="line">                res.add(new ArrayList&lt;&gt;(list));</span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = num+1; i &lt;= 9; i++) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">            dfs(res, list, n, k, sum+i, i);</span><br><span class="line">            list.remove(list.size()-1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 2 ms, 在Combination Sum III的Java提交中击败了67.42% 的用户<br>内存消耗 : 33.6 MB, 在Combination Sum III的Java提交中击败了29.97% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;﻿## 题目&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所有数字都是正整数。 解集不能包
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode215. 数组中的第K个最大元素</title>
    <link href="http://yoursite.com/2019/05/29/leetcode215.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/"/>
    <id>http://yoursite.com/2019/05/29/leetcode215. 数组中的第K个最大元素/</id>
    <published>2019-05-29T13:20:57.243Z</published>
    <updated>2019-05-30T01:48:25.788Z</updated>
    
    <content type="html"><![CDATA[<p>﻿## 题目</p><blockquote><p>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p><p><strong>示例 1:</strong></p><p><strong>输入:</strong> [3,2,1,5,6,4] 和 k = 2<br><strong>输出:</strong> 5<br><strong>示例 2:</strong></p><p><strong>输入:</strong> [3,2,3,1,2,4,5,5,6] 和 k = 4<br><strong>输出:</strong> 4<br><strong>说明:</strong></p><p>你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>学过算法的应该清楚这题是使用快排的思想来解决。<br>第一步：利用快排的方法，每次取一个数num，把一个数组分为左右2堆，左边的比num小，右边的比num大，返回num在数组的位置index；<br>第二步：判断index和数组长度len-k的大小，如果<strong>index &gt; nums.length-k</strong>则说明第k大的数在[l,index-1]之间，否则在[index+1,r]之间；<br>第三步：再回到第一步继续判断直到<strong>index==nums.length-k</strong>即可。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int findKthLargest(int[] nums, int k) &#123;</span><br><span class="line">        int p = 0, r = nums.length-1;</span><br><span class="line">        if(p &gt;= r) &#123;</span><br><span class="line">            return nums[p];</span><br><span class="line">        &#125;</span><br><span class="line">        int index = partition(nums, p, r);</span><br><span class="line">        while (index != nums.length-k) &#123;</span><br><span class="line">            if (index &gt; nums.length-k) &#123;</span><br><span class="line">                r = index - 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                p = index + 1;</span><br><span class="line">            &#125;</span><br><span class="line">            index = partition(nums, p, r);</span><br><span class="line">        &#125;</span><br><span class="line">        return nums[nums.length-k];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int partition(int[] nums, int l, int r) &#123;</span><br><span class="line">    //使用随机化的快速排序，会大大加快速度（leetcode的样例就是这么刁钻）</span><br><span class="line">        int random = l+(int)(Math.random()*(r-l));</span><br><span class="line">        swap(nums, l, random);</span><br><span class="line">        int x = nums[l];</span><br><span class="line">        int lo = l+1, hi = r;</span><br><span class="line">        while (lo &lt;= hi) &#123;</span><br><span class="line">            while (lo &lt;= hi &amp;&amp; nums[lo] &lt; x) &#123;</span><br><span class="line">                lo++;</span><br><span class="line">            &#125;</span><br><span class="line">            while (lo &lt;= hi &amp;&amp; nums[hi] &gt; x) &#123;</span><br><span class="line">                hi--;</span><br><span class="line">            &#125;</span><br><span class="line">            if (lo &lt;= hi) &#123;</span><br><span class="line">                swap(nums, lo++, hi--);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, l, hi);</span><br><span class="line">        return hi;</span><br><span class="line">    &#125;</span><br><span class="line">    //交换数组中的元素位置</span><br><span class="line">    public void swap(int[] nums, int n, int m) &#123;</span><br><span class="line">        if (n == m) return;</span><br><span class="line">        int tmp = nums[n];</span><br><span class="line">        nums[n] = nums[m];</span><br><span class="line">        nums[m] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 3 ms, 在Kth Largest Element in an Array的Java提交中击败了97.95% 的用户<br>内存消耗 : 39 MB, 在Kth Largest Element in an Array的Java提交中击败了67.34% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;﻿## 题目&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>JVM学习笔记</title>
    <link href="http://yoursite.com/2019/05/29/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%9D%A2%E8%AF%95/"/>
    <id>http://yoursite.com/2019/05/29/JVM学习笔记-面试/</id>
    <published>2019-05-29T07:07:54.126Z</published>
    <updated>2019-05-29T07:12:28.280Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM学习"><a href="#JVM学习" class="headerlink" title="JVM学习"></a>JVM学习</h2><h3 id="JVM如何加载-class文件"><a href="#JVM如何加载-class文件" class="headerlink" title="JVM如何加载.class文件"></a>JVM如何加载.class文件</h3><p><strong>JVM虚拟机</strong></p><p><img src="https://img-blog.csdnimg.cn/20190529150652107.png" alt="在这里插入图片描述"><br>Class Loader：以及特定格式，加载class文件到内存</p><p>Execution Engine：对命令进行解析</p><p>Native Interface：融合不同开发语言的原生库为java所用</p><p>Runtime Data Area：JVM内存空间结构模型</p><h3 id="类从编译到执行的过程"><a href="#类从编译到执行的过程" class="headerlink" title="类从编译到执行的过程"></a>类从编译到执行的过程</h3><p>编译器将java源文件编译成class字节码文件</p><p>ClassLoader将字节码转换为JVM中的Class对象</p><p>JVM利用Class对象实例化为实例对象</p><h3 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h3><p>ClassLoader在Java中有着非常重要的作用，它主要工作在Class装载的加载阶段，其主要作用是从系统外部获取Class二进制数据流。它是Java的核心组件，所有的Class都是由ClassLoader进行加载的，ClassLoader负责通过将Class文件里的二进制数据流装载进系统，然后交给Java虚拟机进行链接、初始化等操作。</p><h3 id="ClassLoader的种类"><a href="#ClassLoader的种类" class="headerlink" title="ClassLoader的种类"></a>ClassLoader的种类</h3><ul><li><p>[ ] BootStrapClassLoader：C++编写，加载核心库java.*</p></li><li><p>[ ] ExtClassLoader：Java编写，加载扩展库javax.*</p></li><li><p>[ ] AppClassLoader：Java编写，加载程序所在目录</p></li><li><p>[ ] 自定义ClassLoader：Java编写，定制化加载</p></li></ul><h3 id="类的加载方式"><a href="#类的加载方式" class="headerlink" title="类的加载方式"></a>类的加载方式</h3><p>隐式加载：new</p><p>显式加载：loadClass，forName等</p><h3 id="类的装载过程"><a href="#类的装载过程" class="headerlink" title="类的装载过程"></a>类的装载过程</h3><ol><li>加载： 通过ClassLoader加载class文件字节码，生成Class对象</li><li>链接：<ul><li>校验：检查加载的class的正确性和安全性</li><li>准备：为类变量分配存储空间并设置类变量初始值</li><li>解析：JVM将常量池内的符号引用转换为直接引用</li></ul></li><li>初始化：执行类变量赋值和静态代码块</li></ol><h3 id="loadClass和forName的区别"><a href="#loadClass和forName的区别" class="headerlink" title="loadClass和forName的区别"></a>loadClass和forName的区别</h3><p>Class.forName得到的class是已经初始化完成的</p><p>ClassLoader.loadClass得到的clas是还没有链接的</p><h3 id="JVM内存模型-JDK8"><a href="#JVM内存模型-JDK8" class="headerlink" title="JVM内存模型-JDK8"></a>JVM内存模型-JDK8</h3><p><img src="https://img-blog.csdnimg.cn/20190529150723636.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDQ4NTc0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>线程私有：程序计数器、虚拟机栈、本地方法栈</li><li>线程共享：MetaSpace、Java堆</li></ul><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><ul><li>当前线程所执行的字节码行号指示器（逻辑）</li><li>改变计数器的值来选取下一条需要执行的字节码指令</li><li>和线程是一对一的关系，即“线程私有”</li><li>对Java方法计数，如果是Native方法则计数器值为Undefined</li><li>不会发生内存泄漏</li></ul><h4 id="Java虚拟机栈（Stack）"><a href="#Java虚拟机栈（Stack）" class="headerlink" title="Java虚拟机栈（Stack）"></a>Java虚拟机栈（Stack）</h4><p><img src="https://img-blog.csdnimg.cn/20190529150740675.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDQ4NTc0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>Java方法执行的内存模型</li><li>包含多个栈帧</li></ul><h5 id="局部变量表和操作数栈"><a href="#局部变量表和操作数栈" class="headerlink" title="局部变量表和操作数栈"></a>局部变量表和操作数栈</h5><ul><li>局部变量表：包含方法执行过程中的所有变量</li><li>操作数栈：入栈、出栈、复制、交换、产生消费变量</li></ul><h5 id="递归为什么会引发java-lang-StackOverflowError异常"><a href="#递归为什么会引发java-lang-StackOverflowError异常" class="headerlink" title="递归为什么会引发java.lang.StackOverflowError异常"></a>递归为什么会引发java.lang.StackOverflowError异常</h5><p>递归过深，栈帧数超过虚拟栈深度</p><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>与虚拟机栈相似，主要作用于标注了native的方法</p><h4 id="元空间（Metaspace）："><a href="#元空间（Metaspace）：" class="headerlink" title="元空间（Metaspace）："></a>元空间（Metaspace）：</h4><p>存储已被虚拟机加载的类信息。随着JDK8的到来，JVM不再有方法区（PermGen），原方法区存储的信息被分成两部分：</p><p>1、虚拟机加载的类信息，被移动到元空间。</p><p>2、运行时常量池，被移动到了堆中<strong>（静态成员变量）</strong>。</p><h5 id="MetaSpace（元空间）相比PermGen（永久代）的优势"><a href="#MetaSpace（元空间）相比PermGen（永久代）的优势" class="headerlink" title="MetaSpace（元空间）相比PermGen（永久代）的优势"></a>MetaSpace（元空间）相比PermGen（永久代）的优势</h5><p>元数据区取代了1.7版本及以前的永久代。元数据区和永久代本质上都是方法区的实现。方法区存放虚拟机加载的类信息，静态变量，常量等数据。</p><ul><li>字符串常量池存在永久代中，容易出现性能问题和内存溢出</li><li>类和方法的信息大小难以确定，给永久代的大小指定带来困难</li><li>永久代会给GC带来不必要的复杂性</li><li>方便HotSpot与其他JVM如 Jrockit的集成</li></ul><h4 id="Java堆（Heap）"><a href="#Java堆（Heap）" class="headerlink" title="Java堆（Heap）"></a>Java堆（Heap）</h4><ul><li>对象实例的分配区域</li><li>GC管理的主要区域</li></ul><h4 id="直接内存（没有在上图体现出来）"><a href="#直接内存（没有在上图体现出来）" class="headerlink" title="直接内存（没有在上图体现出来）"></a>直接内存（没有在上图体现出来）</h4><p>jdk1.4引入了NIO，它可以使用Native函数库直接分配堆外内存。</p><h3 id="JVM三大性能调优参数-Xms-Xmx-Xss的含义"><a href="#JVM三大性能调优参数-Xms-Xmx-Xss的含义" class="headerlink" title="JVM三大性能调优参数 -Xms -Xmx -Xss的含义"></a>JVM三大性能调优参数 -Xms -Xmx -Xss的含义</h3><ul><li>-Xss：规定了每个线程虚拟机栈（堆栈）的大小</li><li>-Xms：堆的初始值</li><li>-Xmx：堆能达到的最大值</li></ul><p>一般Xms和Xmx设置为一样的值，因为扩容时会发生内存抖动。</p><h3 id="Java内存模型中堆和栈的区别——内存分配策略"><a href="#Java内存模型中堆和栈的区别——内存分配策略" class="headerlink" title="Java内存模型中堆和栈的区别——内存分配策略"></a>Java内存模型中堆和栈的区别——内存分配策略</h3><ul><li>静态存储：编译时确定每个数据目标在运行时的存储空间需求</li><li>栈式存储：数据区需求在编译时未知，运行时模块入口前确定</li><li>堆式存储：编译时或运行时模块入口都无法确定，动态分配</li></ul><h3 id="Java内存模型中堆和栈的区别"><a href="#Java内存模型中堆和栈的区别" class="headerlink" title="Java内存模型中堆和栈的区别"></a>Java内存模型中堆和栈的区别</h3><ul><li>管理方式：栈自动释放，堆需要GC</li><li>空间大小：栈比对小</li><li>碎片相关：栈产生的碎片远小于堆</li><li>分配方式：栈支持静态和动态分配，而堆仅支持动态分配</li><li>效率：栈的效率比堆高</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JVM学习&quot;&gt;&lt;a href=&quot;#JVM学习&quot; class=&quot;headerlink&quot; title=&quot;JVM学习&quot;&gt;&lt;/a&gt;JVM学习&lt;/h2&gt;&lt;h3 id=&quot;JVM如何加载-class文件&quot;&gt;&lt;a href=&quot;#JVM如何加载-class文件&quot; class=&quot;he
      
    
    </summary>
    
      <category term="笔记" scheme="http://yoursite.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode208.实现Tire</title>
    <link href="http://yoursite.com/2019/05/24/leetcode208.%20%E5%AE%9E%E7%8E%B0%20Trie%20(%E5%89%8D%E7%BC%80%E6%A0%91)/"/>
    <id>http://yoursite.com/2019/05/24/leetcode208. 实现 Trie (前缀树)/</id>
    <published>2019-05-24T12:08:06.153Z</published>
    <updated>2019-07-05T01:52:33.812Z</updated>
    
    <content type="html"><![CDATA[<h2 id="categories-算法"><a href="#categories-算法" class="headerlink" title="categories: 算法"></a>categories: 算法</h2><p>﻿## 题目</p><blockquote><p>实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。</p><p><strong>示例:</strong></p><p>Trie trie = new Trie();</p><p>trie.insert(“apple”); trie.search(“apple”);   // 返回 true<br>trie.search(“app”);     // 返回 false trie.startsWith(“app”); // 返回 true<br>trie.insert(“app”);    trie.search(“app”);     // 返回 true<br><strong>说明:</strong></p><p>你可以假设所有的输入都是由小写字母 a-z 构成的。 保证所有输入均为非空字符串。</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>创建一个结点类，每个结点有26个子结点（26个字母），一个布尔变量，表示该结点是否是某个单词的结尾。<br>然后完成题目要求即可</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">class Trie &#123;</span><br><span class="line">    public class TrieNode&#123;</span><br><span class="line">        boolean isWord;</span><br><span class="line">        TrieNode[] letters = new TrieNode[26];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TrieNode root ;</span><br><span class="line">    public Trie() &#123;</span><br><span class="line">        root = new TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line">    /** Inserts a word into the trie. */</span><br><span class="line">    public void insert(String word) &#123;</span><br><span class="line">        if (word != null) &#123;</span><br><span class="line">            char[] chars = word.toCharArray();</span><br><span class="line">            TrieNode tmp = root;</span><br><span class="line">            for (int i = 0; i &lt; chars.length; i++) &#123;</span><br><span class="line">                if(tmp.letters[chars[i]-&apos;a&apos;] == null)</span><br><span class="line">                    tmp.letters[chars[i]-&apos;a&apos;] = new TrieNode();</span><br><span class="line">                tmp = tmp.letters[chars[i]-&apos;a&apos;];</span><br><span class="line">            &#125;</span><br><span class="line">            tmp.isWord = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** Returns if the word is in the trie. */</span><br><span class="line">    public boolean search(String word) &#123;</span><br><span class="line">        if (word != null) &#123;</span><br><span class="line">            char[] chars = word.toCharArray();</span><br><span class="line">            TrieNode tmp = root;</span><br><span class="line">            for (int i = 0; i &lt; chars.length; i++) &#123;</span><br><span class="line">                if (tmp.letters[chars[i]-&apos;a&apos;] == null)</span><br><span class="line">                    return false;</span><br><span class="line">                tmp = tmp.letters[chars[i]-&apos;a&apos;];</span><br><span class="line">            &#125;</span><br><span class="line">            return tmp.isWord;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** Returns if there is any word in the trie that starts with the given prefix. */</span><br><span class="line">    public boolean startsWith(String prefix) &#123;</span><br><span class="line">        char[] chars = prefix.toCharArray();</span><br><span class="line">        TrieNode tmp = root;</span><br><span class="line">        for (int i = 0; i &lt; chars.length; i++) &#123;</span><br><span class="line">            if (tmp.letters[chars[i]-&apos;a&apos;] == null)</span><br><span class="line">                return false;</span><br><span class="line">            tmp = tmp.letters[chars[i]-&apos;a&apos;];</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 163 ms, 在Implement Trie (Prefix Tree)的Java提交中击败了88.17% 的用户<br>内存消耗 : 61.8 MB, 在Implement Trie (Prefix Tree)的Java提交中击败了76.08% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;categories-算法&quot;&gt;&lt;a href=&quot;#categories-算法&quot; class=&quot;headerlink&quot; title=&quot;categories: 算法&quot;&gt;&lt;/a&gt;categories: 算法&lt;/h2&gt;&lt;p&gt;﻿## 题目&lt;/p&gt;
&lt;blockquote&gt;

      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode207. 课程表</title>
    <link href="http://yoursite.com/2019/05/24/leetcode207.%20%E8%AF%BE%E7%A8%8B%E8%A1%A8/"/>
    <id>http://yoursite.com/2019/05/24/leetcode207. 课程表/</id>
    <published>2019-05-24T01:28:29.406Z</published>
    <updated>2019-05-24T05:40:04.017Z</updated>
    
    <content type="html"><![CDATA[<p>﻿## 题目</p><blockquote><p>现在你总共有 n 门课需要选，记为 0 到 n-1。</p><p>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]</p><p>给定课程总量以及它们的先决条件，判断是否可能完成所有课程的学习？</p><p><strong>示例 1:</strong></p><p><strong>输入:</strong> 2, [[1,0]]<br><strong>输出:</strong> true<br><strong>解释:</strong> 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。<br><strong>示例 2:</strong></p><p><strong>输入:</strong> 2, [[1,0],[0,1]]<br><strong>输出:</strong> false<br><strong>解释:</strong> 总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。<br><strong>说明:</strong></p><p>输入的先决条件是由边缘列表表示的图形，而不是邻接矩阵。详情请参见图的表示法。 你可以假定输入的先决条件中没有重复的边。<br><strong>提示:</strong></p><p>这个问题相当于查找一个循环是否存在于有向图中。如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。 通过 DFS 进行拓扑排序</p><ul><li>一个关于Coursera的精彩视频教程（21分钟），介绍拓扑排序的基本概念。 拓扑排序也可以通过 BFS 完成。</li></ul></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>我的解法是直接把图的边剪断，如果最后能够完成所有点没有相连的边即能够完成所有课程，也是故意不用提示的做法去做的。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean canFinish(int numCourses, int[][] prerequisites) &#123;</span><br><span class="line">        //存储可以选读的课程</span><br><span class="line">        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; prerequisites.length; i++) &#123;</span><br><span class="line">            if(!map.containsKey(prerequisites[i][0]))&#123;</span><br><span class="line">                map.put(prerequisites[i][0], 1);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                map.put(prerequisites[i][0], map.get(prerequisites[i][0]) + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; numCourses; i++) &#123;</span><br><span class="line">            if(!map.containsKey(i))&#123;</span><br><span class="line">                list.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int len = prerequisites.length;</span><br><span class="line">        while(!list.isEmpty()) &#123;</span><br><span class="line">            int tmp = list.remove(list.size()-1);</span><br><span class="line">            for (int i = 0; i &lt; prerequisites.length; i++) &#123;</span><br><span class="line">                if (prerequisites[i][1] == tmp) &#123;</span><br><span class="line">                    len--;</span><br><span class="line">                    if(map.get(prerequisites[i][0]) == 1)&#123;</span><br><span class="line">                        list.add(prerequisites[i][0]);</span><br><span class="line">                    &#125; else&#123;</span><br><span class="line">                        map.put(prerequisites[i][0], map.get(prerequisites[i][0])-1);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return len == 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 47 ms, 在Course Schedule的Java提交中击败了40.49% 的用户<br>内存消耗 : 43.1 MB, 在Course Schedule的Java提交中击败了79.55% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;﻿## 题目&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;现在你总共有 n 门课需要选，记为 0 到 n-1。&lt;/p&gt;
&lt;p&gt;在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]&lt;/p&gt;
&lt;p&gt;给定课程总
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode201. 数字范围按位与</title>
    <link href="http://yoursite.com/2019/05/23/leetcode201.%20%E6%95%B0%E5%AD%97%E8%8C%83%E5%9B%B4%E6%8C%89%E4%BD%8D%E4%B8%8E/"/>
    <id>http://yoursite.com/2019/05/23/leetcode201. 数字范围按位与/</id>
    <published>2019-05-23T13:50:51.069Z</published>
    <updated>2019-05-24T01:01:31.113Z</updated>
    
    <content type="html"><![CDATA[<p>﻿## 题目</p><blockquote><p>给定范围 [m, n]，其中 0 &lt;= m &lt;= n &lt;= 2147483647，返回此范围内所有数字的按位与（包含 m, n 两端点）。</p><p><strong>示例 1:</strong> </p><p><strong>输入:</strong> [5,7]<br><strong>输出:</strong> 4<br><strong>示例 2:</strong></p><p><strong>输入:</strong> [0,1]<br><strong>输出:</strong> 0</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>把n、m后面不一样的去掉，剩下一样的，因为不一样的&amp;之后的就是0，使用一个变量保存有多少个0。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int rangeBitwiseAnd(int m, int n) &#123;</span><br><span class="line">        if (m == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int tmp = 1;</span><br><span class="line">        while(n != m)&#123;</span><br><span class="line">            m &gt;&gt;= 1;</span><br><span class="line">            n &gt;&gt;= 1;</span><br><span class="line">            tmp &lt;&lt;= 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return m * tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 36 ms, 在Bitwise AND of Numbers Range的Java提交中击败了30.45% 的用户<br>内存消耗 : 36.5 MB, 在Bitwise AND of Numbers Range的Java提交中击败了10.42% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;﻿## 题目&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定范围 [m, n]，其中 0 &amp;lt;= m &amp;lt;= n &amp;lt;= 2147483647，返回此范围内所有数字的按位与（包含 m, n 两端点）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt; &lt;
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode199. 二叉树的右视图</title>
    <link href="http://yoursite.com/2019/05/21/leetcode199.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/"/>
    <id>http://yoursite.com/2019/05/21/leetcode199. 二叉树的右视图/</id>
    <published>2019-05-21T13:46:54.492Z</published>
    <updated>2019-05-21T14:18:57.470Z</updated>
    
    <content type="html"><![CDATA[<p>﻿## 题目</p><p>给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><p><strong>示例:</strong></p><p><strong>输入:</strong> [1,2,3,null,5,null,4]<br><strong>输出:</strong> [1, 3, 4]<br><strong>解释:</strong></p><p>   <img src="https://img-blog.csdnimg.cn/2019052121450834.png" alt="1            &lt;--- /   \2     3         &lt;--- \     \  5     4       &lt;---"></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p> 层次遍历，使用一个队列，每次把右结点先放入，再放入左结点，每一层的最右个结点加入结果即可。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; rightSideView(TreeNode root) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return new ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        while (!queue.isEmpty())&#123;</span><br><span class="line">            TreeNode tn = queue.peek();</span><br><span class="line">            int size = queue.size();</span><br><span class="line">            res.add(tn.val);</span><br><span class="line">            while(size &gt; 0)&#123;</span><br><span class="line">                tn = queue.remove();</span><br><span class="line">                if (tn.right != null)&#123;</span><br><span class="line">                    queue.add(tn.right);</span><br><span class="line">                &#125;</span><br><span class="line">                if (tn.left != null) &#123;</span><br><span class="line">                    queue.add(tn.left);</span><br><span class="line">                &#125;</span><br><span class="line">                size --;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 3 ms, 在Binary Tree Right Side View的Java提交中击败了69.61% 的用户<br>内存消耗 : 35.1 MB, 在Binary Tree Right Side View的Java提交中击败了44.50% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;﻿## 题目&lt;/p&gt;
&lt;p&gt;给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入:&lt;/strong&gt; [1,2,3,null,5,null,4]
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode187. 重复的DNA序列</title>
    <link href="http://yoursite.com/2019/05/21/leetcode187.%20%E9%87%8D%E5%A4%8D%E7%9A%84DNA%E5%BA%8F%E5%88%97/"/>
    <id>http://yoursite.com/2019/05/21/leetcode187. 重复的DNA序列/</id>
    <published>2019-05-21T12:56:09.221Z</published>
    <updated>2019-05-21T14:19:10.354Z</updated>
    
    <content type="html"><![CDATA[<p>﻿## 题目</p><blockquote><p>所有 DNA 由一系列缩写为 A，C，G 和 T 的核苷酸组成，例如：“ACGAATTCCG”。在研究 DNA 时，识别 DNA<br>中的重复序列有时会对研究非常有帮助。</p><p>编写一个函数来查找 DNA 分子中所有出现超多一次的10个字母长的序列（子串）。</p><p><strong>示例:</strong></p><p><strong>输入:</strong> s = “AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT”</p><p><strong>输出:</strong> [“AAAAACCCCC”, “CCCCCAAAAA”]</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>使用一个集合set，遍历一遍字符串，如果存入集合成功，则说明字符串是第一次出现，如果存入集合不成功，说明该字符串不是第一次出现，存入结果集合，最后把结果集合res转为链表返回即可。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;String&gt; findRepeatedDnaSequences(String s) &#123;</span><br><span class="line">        Set&lt;String&gt; set = new HashSet&lt;&gt;();</span><br><span class="line">        Set&lt;String&gt; res = new HashSet&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt;= s.length()-10; i++) &#123;</span><br><span class="line">            String str = s.substring(i,i+10);</span><br><span class="line">            if(!set.add(str))&#123;</span><br><span class="line">                res.add(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return new ArrayList&lt;&gt;(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 59 ms, 在Repeated DNA Sequences的Java提交中击败了42.82% 的用户<br>内存消耗 : 54.6 MB, 在Repeated DNA Sequences的Java提交中击败了19.19% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;﻿## 题目&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;所有 DNA 由一系列缩写为 A，C，G 和 T 的核苷酸组成，例如：“ACGAATTCCG”。在研究 DNA 时，识别 DNA&lt;br&gt;中的重复序列有时会对研究非常有帮助。&lt;/p&gt;
&lt;p&gt;编写一个函数来查找 DNA 分子
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
</feed>
