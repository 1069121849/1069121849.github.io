<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>白哥的博客</title>
  
  <subtitle>白哥的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-09-03T03:03:57.232Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>白哥</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>剑指offer-数组中只出现一次的数字</title>
    <link href="http://yoursite.com/2019/09/02/%E5%89%91%E6%8C%87offer-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>http://yoursite.com/2019/09/02/剑指offer-数组中只出现一次的数字/</id>
    <published>2019-09-02T11:54:47.977Z</published>
    <updated>2019-09-03T03:03:57.232Z</updated>
    
    <content type="html"><![CDATA[<p>﻿## 题目</p><p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>使用位运算。<br>如果一个数组<strong>只有一个数字出现一次</strong>，其他的出现2次，则全部异或剩下的数就是出现一次的数。同理，这题下来，剩下的数即为2个出现一次的数的异或。<br><strong>2个出现一次的数字的异或为1</strong>的位置，则说明<strong>2个数出现一次的数的该位必然不同，一个为1一个为0</strong>。<br>根据此可以把该数组分为2个部分，分别异或，则可以求出2个出现一次的数。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//num1,num2分别为长度为1的数组。传出参数</span><br><span class="line">//将num1[0],num2[0]设置为返回结果</span><br><span class="line">import java.util.*;</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public void FindNumsAppearOnce(int [] array,int num1[] , int num2[]) &#123;</span><br><span class="line">        int temp = 0;</span><br><span class="line">        //求2个出现一次的数字的异或</span><br><span class="line">        for (int i = 0; i &lt; array.length; i++) &#123;</span><br><span class="line">            temp ^= array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        //求出2个数的最后一个不同的位</span><br><span class="line">        temp -= temp &amp; (temp-1);</span><br><span class="line">        //根据这个位把数组分为2个部分，分别异或</span><br><span class="line">        for (int i = 0; i &lt; array.length; i++) &#123;</span><br><span class="line">            if ((array[i] &amp; temp) == temp) &#123;</span><br><span class="line">                num1[0] ^= array[i];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                num2[0] ^= array[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p><img src="https://img-blog.csdnimg.cn/20190902195444259.png" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;﻿## 题目&lt;/p&gt;
&lt;p&gt;一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。&lt;/p&gt;
&lt;h2 id=&quot;解题思路&quot;&gt;&lt;a href=&quot;#解题思路&quot; class=&quot;headerlink&quot; title=&quot;解题思路&quot;&gt;&lt;/a&gt;解题思路&lt;/
      
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-数组中的逆序对</title>
    <link href="http://yoursite.com/2019/09/01/%E5%89%91%E6%8C%87offer-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/"/>
    <id>http://yoursite.com/2019/09/01/剑指offer-数组中的逆序对/</id>
    <published>2019-09-01T14:04:34.795Z</published>
    <updated>2019-09-03T03:04:23.487Z</updated>
    
    <content type="html"><![CDATA[<p>﻿## 题目</p><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>使用归并排序的想法，把数组分成2个，归并时直接比对2个数组之间，即可得出多少逆序对。随即把2个数组归并排序，合并之后的比较。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public int InversePairs(int[] array) &#123;</span><br><span class="line">        int[] cnt = &#123;0&#125;;</span><br><span class="line">        InversePairsHelper(array, 0, array.length - 1, cnt);</span><br><span class="line">        return cnt[0];</span><br><span class="line">    &#125;</span><br><span class="line">//辅助函数，归并数组</span><br><span class="line">    public void InversePairsHelper(int[] array, int left, int right, int[] cnt) &#123;</span><br><span class="line">        if (left &lt; right) &#123;</span><br><span class="line">            int mid = (left + right) &gt;&gt; 1;</span><br><span class="line">            InversePairsHelper(array, left, mid, cnt);</span><br><span class="line">            InversePairsHelper(array, mid + 1, right, cnt);</span><br><span class="line">            InversePairsMeger(array, left, mid, right, cnt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void InversePairsMeger(int[] array, int left, int mid, int right, int[] cnt) &#123;</span><br><span class="line">        //把原数组分为左右2个数组</span><br><span class="line">        int[] L = Arrays.copyOfRange(array, left, mid + 1);</span><br><span class="line">        int[] R = Arrays.copyOfRange(array, mid + 1, right + 1);</span><br><span class="line">        int r = 0, l = 0;</span><br><span class="line">        //找出2个数组之间其中有多少逆序对</span><br><span class="line">        while (r &lt; R.length) &#123;</span><br><span class="line">            while (l &lt; L.length) &#123;</span><br><span class="line">                if (L[l] &gt; R[r]) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            r++;</span><br><span class="line">            cnt[0] %= 1000000007;</span><br><span class="line">            cnt[0] += L.length - l;</span><br><span class="line">        &#125;</span><br><span class="line">        //归并排序2个数组</span><br><span class="line">        l = 0;</span><br><span class="line">        r = 0;</span><br><span class="line">        while (l &lt; L.length &amp;&amp; r &lt; R.length) &#123;</span><br><span class="line">            array[left++] = L[l] &gt; R[r] ? R[r++] : L[l++];</span><br><span class="line">        &#125;</span><br><span class="line">        if (r == R.length) &#123;</span><br><span class="line">            while (left &lt;= right) &#123;</span><br><span class="line">                array[left++] = L[l++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            while (left &lt;= right) &#123;</span><br><span class="line">                array[left++] = R[r++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p><img src="https://img-blog.csdnimg.cn/20190901220419101.png" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;﻿## 题目&lt;/p&gt;
&lt;p&gt;在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007&lt;/p&gt;
&lt;h2 id=&quot;解题思路&quot;&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-第一个只出现一次的字符</title>
    <link href="http://yoursite.com/2019/08/30/%E5%89%91%E6%8C%87offer-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/"/>
    <id>http://yoursite.com/2019/08/30/剑指offer-第一个只出现一次的字符/</id>
    <published>2019-08-30T10:26:17.030Z</published>
    <updated>2019-08-30T11:55:34.074Z</updated>
    
    <content type="html"><![CDATA[<p>﻿## 题目</p><p>在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>第一步：使用2个长度52的数组，一个用来保存字符的个数，一个用来保存字符的下标<br>第二步：遍历记录个数的数组，找到个数为1，下标最小的值。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int FirstNotRepeatingChar(String str) &#123;</span><br><span class="line">        int[] chs = new int[52];</span><br><span class="line">        int[] index = new int[52];</span><br><span class="line">        for (int i = 0; i &lt; str.le ngth(); i++) &#123;</span><br><span class="line">            char c = str.charAt(i);</span><br><span class="line">            if (Character.isUpperCase(c)) &#123;</span><br><span class="line">                chs[c - &apos;A&apos; + 26]++;</span><br><span class="line">                index[c - &apos;A&apos; + 26] = i;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                chs[c - &apos;a&apos;]++;</span><br><span class="line">                index[c - &apos;a&apos;] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int min = Integer.MAX_VALUE;</span><br><span class="line">        for (int i = 0; i &lt; index.length; i++) &#123;</span><br><span class="line">            if (chs[i] == 1) &#123;</span><br><span class="line">                min = Math.min(min, index[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return min == Integer.MAX_VALUE ? -1 : min;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p><img src="https://img-blog.csdnimg.cn/20190830182603288.png" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;﻿## 题目&lt;/p&gt;
&lt;p&gt;在一个字符串(0&amp;lt;=字符串长度&amp;lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.&lt;/p&gt;
&lt;h2 id=&quot;解题思路&quot;&gt;&lt;a href=&quot;#解题思路&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-丑数</title>
    <link href="http://yoursite.com/2019/08/30/%E5%89%91%E6%8C%87offer-%E4%B8%91%E6%95%B0/"/>
    <id>http://yoursite.com/2019/08/30/剑指offer-丑数/</id>
    <published>2019-08-30T08:48:22.472Z</published>
    <updated>2019-08-30T11:55:26.318Z</updated>
    
    <content type="html"><![CDATA[<p>﻿## 题目</p><p>把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>丑数都是由2、3、5相乘得来的；之前的丑数<em>（2、3、5）所能得到的最小值即为新的丑数。<br>例如：第一个丑数是1，第一个丑数 </em>（2、3、5）中最小的2，即为新的丑数，即第二个丑数。<br>第一步：使用一个数组保存丑数，3个元素保存2、3、5所乘能得到的最小值的下标<br>第二步：找出2、3、5乘丑数序列所得到的最小值<br>第三步：得到最小值的下标+1</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public int GetUglyNumber_Solution(int index) &#123;</span><br><span class="line">        if (index == 0) return 0;</span><br><span class="line">        int[] getUglyNumber = new int[index];</span><br><span class="line">        getUglyNumber[0] = 1;</span><br><span class="line">        int nums[] = new int[3];</span><br><span class="line">        for (int i = 1; i &lt; index; i++) &#123;</span><br><span class="line">            getUglyNumber[i] = Math.min(</span><br><span class="line">                    Math.min(getUglyNumber[nums[0]] * 2, getUglyNumber[nums[1]] * 3),</span><br><span class="line">                    getUglyNumber[nums[2]] * 5);</span><br><span class="line">            if (getUglyNumber[nums[0]] * 2 == getUglyNumber[i]) &#123;</span><br><span class="line">                nums[0]++;</span><br><span class="line">            &#125;</span><br><span class="line">            if (getUglyNumber[nums[1]] * 3 == getUglyNumber[i]) &#123;</span><br><span class="line">                nums[1]++;</span><br><span class="line">            &#125;</span><br><span class="line">            if ( getUglyNumber[nums[2]] * 5 == getUglyNumber[i]) &#123;</span><br><span class="line">                nums[2]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return getUglyNumber[index-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p><img src="https://img-blog.csdnimg.cn/20190830164809609.png" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;﻿## 题目&lt;/p&gt;
&lt;p&gt;把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。&lt;/p&gt;
&lt;h2 id=&quot;解题思路&quot;&gt;&lt;a href=&quot;#解题思
      
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-最小的K个数</title>
    <link href="http://yoursite.com/2019/08/27/%E5%89%91%E6%8C%87offer-%E6%9C%80%E5%B0%8F%E7%9A%84K%E4%B8%AA%E6%95%B0/"/>
    <id>http://yoursite.com/2019/08/27/剑指offer-最小的K个数/</id>
    <published>2019-08-27T13:27:42.808Z</published>
    <updated>2019-08-30T11:55:50.832Z</updated>
    
    <content type="html"><![CDATA[<p>﻿## 题目</p><p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>用快速选择找出第k大的数，前面的就是最小的k个数。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public ArrayList&lt;Integer&gt; GetLeastNumbers_Solution(int[] input, int k) &#123;</span><br><span class="line">      if (input.length == 0) return new ArrayList&lt;&gt;();</span><br><span class="line">        if (k &gt; input.length) return new ArrayList&lt;&gt;();</span><br><span class="line">        return GetLeastNumbers_Solution(input, 0, input.length,k-1);</span><br><span class="line">    &#125;</span><br><span class="line">    public ArrayList&lt;Integer&gt; GetLeastNumbers_Solution(int[] input, int l, int r, int k)&#123;</span><br><span class="line">        int index  = partition(input, l, r);</span><br><span class="line">        if (index == k) &#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">            for (int i = 0; i &lt;= k; i++) &#123;</span><br><span class="line">                list.add(input[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            return list;</span><br><span class="line">        &#125; else if (index &lt; k) &#123;</span><br><span class="line">            return GetLeastNumbers_Solution(input, index+1,r,k);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return GetLeastNumbers_Solution(input, l, index, k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public int partition(int[] input, int l, int r) &#123;</span><br><span class="line">        int x = input[l];</span><br><span class="line">        int lo = l + 1, hi = r-1;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            while (lo &lt;= hi &amp;&amp; input[lo] &lt; x) &#123;</span><br><span class="line">                lo++;</span><br><span class="line">            &#125;</span><br><span class="line">            while (lo &lt;= hi &amp;&amp; input[hi] &gt; x) &#123;</span><br><span class="line">                hi--;</span><br><span class="line">            &#125;</span><br><span class="line">            if (lo &gt;= hi) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(input, lo, hi);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(input, l, lo-1);</span><br><span class="line">        return hi;</span><br><span class="line">    &#125;</span><br><span class="line">    public void swap(int[] arr, int i, int j) &#123;</span><br><span class="line">        int temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p><img src="https://img-blog.csdnimg.cn/20190827212738415.png" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;﻿## 题目&lt;/p&gt;
&lt;p&gt;输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。&lt;/p&gt;
&lt;h2 id=&quot;解题思路&quot;&gt;&lt;a href=&quot;#解题思路&quot; class=&quot;headerlink&quot; title=&quot;解
      
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-二叉搜索树与双向链表</title>
    <link href="http://yoursite.com/2019/08/13/%E5%89%91%E6%8C%87offer-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2019/08/13/剑指offer-二叉搜索树与双向链表/</id>
    <published>2019-08-13T13:13:03.305Z</published>
    <updated>2019-08-13T17:14:53.874Z</updated>
    
    <content type="html"><![CDATA[<p>﻿## 题目</p><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>第一步：二叉搜索树转为<strong>排序</strong>的双向链表，必然是使用中序遍历。<br>第二步：使用一个指针，用来从最小值遍历到最大值。<br>第三步：使用递归的中序遍历，之后使当前的值指向下一个值，下一个值指向当前值则可以使其转为双向链表</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public TreeNode Convert(TreeNode pRootOfTree) &#123;</span><br><span class="line">        if (pRootOfTree == null) return null;</span><br><span class="line">        helper(pRootOfTree);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode head = null;</span><br><span class="line">    TreeNode res = null;</span><br><span class="line">    public void helper(TreeNode root) &#123;</span><br><span class="line">        if (root == null) return;</span><br><span class="line">        helper(root.left);</span><br><span class="line">        //找到最小值，即最左的结点</span><br><span class="line">        if (head == null) &#123;</span><br><span class="line">            head = root;</span><br><span class="line">            res = root;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            head.right = root;</span><br><span class="line">            root.left = head;</span><br><span class="line">            head = root;</span><br><span class="line">        &#125;</span><br><span class="line">        helper(root.right);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p><img src="https://img-blog.csdnimg.cn/20190813211302822.png" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;﻿## 题目&lt;/p&gt;
&lt;p&gt;输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。&lt;/p&gt;
&lt;h2 id=&quot;解题思路&quot;&gt;&lt;a href=&quot;#解题思路&quot; class=&quot;headerlink&quot; title=&quot;解题思路&quot;
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="剑指offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-二叉树中和为某一值的路径</title>
    <link href="http://yoursite.com/2019/08/13/%E5%89%91%E6%8C%87offer-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
    <id>http://yoursite.com/2019/08/13/剑指offer-二叉树中和为某一值的路径/</id>
    <published>2019-08-13T11:25:38.016Z</published>
    <updated>2019-08-13T17:14:38.688Z</updated>
    
    <content type="html"><![CDATA[<p>﻿## 题目</p><p>输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>直接深度遍历，每次减去当前节点的值，直到叶子节点，判断val是否target，是则说明是一条路径，否则不是。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root, int target) &#123;</span><br><span class="line">        //为空，直接返回</span><br><span class="line">        if (root == null) return new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">        DFS(res, new ArrayList&lt;Integer&gt;(), root, target);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void DFS(ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res, ArrayList&lt;Integer&gt; list, TreeNode root, int target) &#123;</span><br><span class="line">        //到达叶子节点时，进行判断</span><br><span class="line">        if (root.left == null &amp;&amp; root.right == null &amp;&amp; target == root.val) &#123;</span><br><span class="line">            list.add(root.val);</span><br><span class="line">            res.add(new ArrayList&lt;&gt;(list));</span><br><span class="line">            list.remove(list.size() - 1);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //不是叶结点时，放入链表</span><br><span class="line">        list.add(root.val);</span><br><span class="line">        //深度搜索</span><br><span class="line">        if (root.left != null) DFS(res, list, root.left, target - root.val);</span><br><span class="line">        if (root.right != null) DFS(res, list, root.right, target - root.val);</span><br><span class="line">        //进行回溯</span><br><span class="line">        list.remove(list.size() - 1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p><img src="https://img-blog.csdnimg.cn/20190813192536350.png" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;﻿## 题目&lt;/p&gt;
&lt;p&gt;输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)&lt;/p&gt;
&lt;h2 id=&quot;解题思路&quot;&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="剑指offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>String源码学习</title>
    <link href="http://yoursite.com/2019/08/09/String%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2019/08/09/String源码学习/</id>
    <published>2019-08-09T14:34:42.120Z</published>
    <updated>2019-08-31T15:56:04.793Z</updated>
    
    <content type="html"><![CDATA[<h1 id="String源码学习"><a href="#String源码学习" class="headerlink" title="String源码学习"></a>String源码学习</h1><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串存储于该字符数组，因为是private final所以不能继承</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line"><span class="comment">//hash值，默认为0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> hash; </span><br><span class="line"><span class="comment">//序列化，类字符串是序列化流协议中的特殊字符串。（用处）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectStreamField[] serialPersistentFields = <span class="keyword">new</span> ObjectStreamField[<span class="number">0</span>];</span><br><span class="line"><span class="comment">//创建一个比较器Comparator内部类对象，重写了其compare方法。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Comparator&lt;String&gt; CASE_INSENSITIVE_ORDER = <span class="keyword">new</span> CaseInsensitiveComparator();</span><br></pre></td></tr></table></figure><p>CaseInsensitiveComparator重写的compare方法：不区分大小写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> n1 = s1.length();</span><br><span class="line">       <span class="keyword">int</span> n2 = s2.length();</span><br><span class="line">       <span class="keyword">int</span> min = Math.min(n1, n2);</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; min; i++) &#123;</span><br><span class="line">           <span class="keyword">char</span> c1 = s1.charAt(i);</span><br><span class="line">           <span class="keyword">char</span> c2 = s2.charAt(i);</span><br><span class="line">           <span class="keyword">if</span> (c1 != c2) &#123;</span><br><span class="line">               <span class="comment">//不区分大小写的比较</span></span><br><span class="line">               c1 = Character.toUpperCase(c1);</span><br><span class="line">               c2 = Character.toUpperCase(c2);</span><br><span class="line">               <span class="keyword">if</span> (c1 != c2) &#123;</span><br><span class="line">                   c1 = Character.toLowerCase(c1);</span><br><span class="line">                   c2 = Character.toLowerCase(c2);</span><br><span class="line">                   <span class="keyword">if</span> (c1 != c2) &#123;</span><br><span class="line">                       <span class="keyword">return</span> c1 - c2;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> n1 - n2;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无参构造为空字符串</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = <span class="string">""</span>.value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//带有String的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String original)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = original.value;</span><br><span class="line">        <span class="keyword">this</span>.hash = original.hash;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//带有char数组的构造方法，把字符数组转为字符串，深拷贝该数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = Arrays.copyOf(value, value.length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//参数：字符数组， 开始下标， 字符的数量</span></span><br><span class="line"><span class="comment">//从字符数组的offset开始，复制count个字符</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[], <span class="keyword">int</span> offset, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//开始下标小于0，抛出下标越界异常</span></span><br><span class="line">    <span class="keyword">if</span> (offset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(offset);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果count&lt;=0,而且offset合法，则定义一个空字符串""</span></span><br><span class="line">    <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (offset &lt;= value.length) &#123;</span><br><span class="line">            <span class="keyword">this</span>.value = <span class="string">""</span>.value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// count越界异常</span></span><br><span class="line">    <span class="keyword">if</span> (offset &gt; value.length - count) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(offset + count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果合法，则复制到字符串的char数组中</span></span><br><span class="line">    <span class="keyword">this</span>.value = Arrays.copyOfRange(value, offset, offset+count);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//参数：int数组，开始下标，数量</span></span><br><span class="line"><span class="comment">//作用：把一个Unicode的int数组转为字符串</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">int</span>[] codePoints, <span class="keyword">int</span> offset, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断都于char数组的构造方法一致</span></span><br><span class="line">    <span class="keyword">if</span> (offset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(offset);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (offset &lt;= codePoints.length) &#123;</span><br><span class="line">            <span class="keyword">this</span>.value = <span class="string">""</span>.value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (offset &gt; codePoints.length - count) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(offset + count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> end = offset + count;</span><br><span class="line">    <span class="keyword">int</span> n = count;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = offset; i &lt; end; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = codePoints[i];</span><br><span class="line">        <span class="comment">//如果是在BMP范围内，则直接继续</span></span><br><span class="line">        <span class="keyword">if</span> (Character.isBmpCodePoint(c))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//如果不在BMP范围内，则16位存储不了，n++；</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Character.isValidCodePoint(c))</span><br><span class="line">            n++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(Integer.toString(c));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过上面的计算，得到Unicode数组转为char数组的长度n</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">char</span>[] v = <span class="keyword">new</span> <span class="keyword">char</span>[n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = offset, j = <span class="number">0</span>; i &lt; end; i++, j++) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = codePoints[i];</span><br><span class="line">        <span class="keyword">if</span> (Character.isBmpCodePoint(c))</span><br><span class="line">            v[j] = (<span class="keyword">char</span>)c;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//不在BMP范围内，需要多一位存储</span></span><br><span class="line">            Character.toSurrogates(c, v, j++);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//最后把value指向v数组</span></span><br><span class="line">    <span class="keyword">this</span>.value = v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//参数：byte数组，开始下标，长度，编码格式名称</span></span><br><span class="line"><span class="comment">//作用：通过编码格式来解码指定的byte数组，默认的编码格式为ISO-8859-1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span> bytes[], <span class="keyword">int</span> offset, <span class="keyword">int</span> length, String charsetName)</span> <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (charsetName == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"charsetName"</span>);</span><br><span class="line">    checkBounds(bytes, offset, length);</span><br><span class="line">    <span class="keyword">this</span>.value = StringCoding.decode(charsetName, bytes, offset, length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//同上，把整个byte数组转为字符串</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span> bytes[], String charsetName)</span> <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(bytes, <span class="number">0</span>, bytes.length, charsetName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//直接传入编码，按照该格式转为字符串</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span> bytes[], <span class="keyword">int</span> offset, <span class="keyword">int</span> length, Charset charset)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (charset == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"charset"</span>);</span><br><span class="line">    checkBounds(bytes, offset, length);</span><br><span class="line">    <span class="keyword">this</span>.value =  StringCoding.decode(charset, bytes, offset, length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//同上</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span> bytes[], Charset charset)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(bytes, <span class="number">0</span>, bytes.length, charset);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//同上</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span> bytes[], <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    checkBounds(bytes, offset, length);</span><br><span class="line">    <span class="keyword">this</span>.value = StringCoding.decode(bytes, offset, length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将StringBuffer转为String，使用了synchronized锁住变量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(StringBuffer buffer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(buffer) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = Arrays.copyOf(buffer.getValue(), buffer.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//StringBuilder转为String</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(StringBuilder builder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = Arrays.copyOf(builder.getValue(), builder.length());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//私有的构造方法，直接共享2个字符数组，节省资源，性能更好，但是可能出现内存泄漏</span></span><br><span class="line">String(<span class="keyword">char</span>[] value, <span class="keyword">boolean</span> share) &#123;</span><br><span class="line">    <span class="comment">// assert share : "unshared not supported";</span></span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>BMP（Basic Multilingual Plane，基本多文种平面）：</strong><br>只需要知道BMP代表了一个字符范围，在BMP范围内的字符，可以用16位表示，而在BMP以外的字符，需要4个字节（即32位，不止16位）表示。</p><h2 id="普通方法"><a href="#普通方法" class="headerlink" title="普通方法"></a>普通方法</h2><h3 id="checkBounds"><a href="#checkBounds" class="headerlink" title="checkBounds"></a>checkBounds</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检查越界方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkBounds</span><span class="params">(<span class="keyword">byte</span>[] bytes, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (length &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(length);</span><br><span class="line">    <span class="keyword">if</span> (offset &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(offset);</span><br><span class="line">    <span class="keyword">if</span> (offset &gt; bytes.length - length)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(offset + length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="length"><a href="#length" class="headerlink" title="length()"></a>length()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回字符串的长度，即字符数组的长度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="isEmpty"><a href="#isEmpty" class="headerlink" title="isEmpty()"></a>isEmpty()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value.length == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="charAt"><a href="#charAt" class="headerlink" title="charAt"></a>charAt</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数：一个下标index</span></span><br><span class="line"><span class="comment">//作用：返回字符串中该位置的字符</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//越界检查</span></span><br><span class="line">    <span class="keyword">if</span> ((index &lt; <span class="number">0</span>) || (index &gt;= value.length)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="getChars"><a href="#getChars" class="headerlink" title="getChars"></a>getChars</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数：目标数组，开始下标</span></span><br><span class="line"><span class="comment">//作用：把字符串的所有字符复制到字符数组中的开始下标直到字符串结束</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getChars</span><span class="params">(<span class="keyword">char</span> dst[], <span class="keyword">int</span> dstBegin)</span> </span>&#123;</span><br><span class="line">    System.arraycopy(value, <span class="number">0</span>, dst, dstBegin, value.length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//参数: 开始下标，结束下标，目标字符数组， 目标数组开始下标</span></span><br><span class="line"><span class="comment">//作用：把字符串从开始下标到结束下标的多个字符，赋值到目标数组的 开始下标 到 目标开始下标+（结束下标-开始下标）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getChars</span><span class="params">(<span class="keyword">int</span> srcBegin, <span class="keyword">int</span> srcEnd, <span class="keyword">char</span> dst[], <span class="keyword">int</span> dstBegin)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//越界检查</span></span><br><span class="line">    <span class="keyword">if</span> (srcBegin &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(srcBegin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (srcEnd &gt; value.length) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(srcEnd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (srcBegin &gt; srcEnd) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(srcEnd - srcBegin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把value数组中，从srcBegin开始的字符，复制到dst，从dstBegin开始，长度为srcEnd-srcBegin</span></span><br><span class="line">    System.arraycopy(value, srcBegin, dst, dstBegin, srcEnd - srcBegin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getBytes</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定解码格式获取字符串的byte数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] getBytes(String charsetName) <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">    <span class="keyword">if</span> (charsetName == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">return</span> StringCoding.encode(charsetName, value, <span class="number">0</span>, value.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断字符串和传入的Object是否相等</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判读anObject是否是字符串</span></span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        String anotherString = (String)anObject;</span><br><span class="line">        <span class="keyword">int</span> n = value.length;</span><br><span class="line">        <span class="comment">//2个字符串相等，其value数组长度一定相等</span></span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            <span class="keyword">char</span> v1[] = value;</span><br><span class="line">            <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//比较2个数组的每一个字符，如果有不相等的直接return false,如果全部相等则为true</span></span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非同步的equals，参数是一个AbstractStringBuilder，比较的方式和equals一样</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">nonSyncContentEquals</span><span class="params">(AbstractStringBuilder sb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> v1[] = value;</span><br><span class="line">    <span class="keyword">char</span> v2[] = sb.getValue();</span><br><span class="line">    <span class="keyword">int</span> n = v1.length;</span><br><span class="line">    <span class="keyword">if</span> (n != sb.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v1[i] != v2[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用于判断与CharSequence是否相等</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contentEquals</span><span class="params">(CharSequence cs)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断cs是不是一个StringBuffer，StringBuilder</span></span><br><span class="line">    <span class="keyword">if</span> (cs <span class="keyword">instanceof</span> AbstractStringBuilder) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cs <span class="keyword">instanceof</span> StringBuffer) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(cs) &#123;</span><br><span class="line">               <span class="keyword">return</span> nonSyncContentEquals((AbstractStringBuilder)cs);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> nonSyncContentEquals((AbstractStringBuilder)cs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//是String的话直接使用equals</span></span><br><span class="line">    <span class="keyword">if</span> (cs <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="keyword">return</span> equals(cs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 是CharSequence的话</span></span><br><span class="line">    <span class="keyword">char</span> v1[] = value;</span><br><span class="line">    <span class="keyword">int</span> n = v1.length;</span><br><span class="line">    <span class="keyword">if</span> (n != cs.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v1[i] != cs.charAt(i)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用于是判断与StringBuffer是否相等</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contentEquals</span><span class="params">(StringBuffer sb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> contentEquals((CharSequence)sb);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//忽略大小写的比较</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equalsIgnoreCase</span><span class="params">(String anotherString)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == anotherString) ? <span class="keyword">true</span></span><br><span class="line">            : (anotherString != <span class="keyword">null</span>)</span><br><span class="line">            &amp;&amp; (anotherString.value.length == value.length)</span><br><span class="line">            &amp;&amp; regionMatches(<span class="keyword">true</span>, <span class="number">0</span>, anotherString, <span class="number">0</span>, value.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="补充：charSequence"><a href="#补充：charSequence" class="headerlink" title="补充：charSequence"></a>补充：charSequence</h3><p>charSequence是一个接口，表示char值的一个可读序列。此接口对许多不同种类的char序列提供统一的自读访问。此接口不修改该equals和hashCode方法的常规协定，因此，通常未定义比较实现 CharSequence 的两个对象的结果。他有几个实现类：CharBuffer、String、StringBuffer、StringBuilder。</p><p>　　CharSequence与String都能用于定义字符串，但CharSequence的值是可读可写序列，而String的值是只读序列。</p><p>　　对于一个抽象类或者是接口类，不能使用new来进行赋值，但是可以通过以下的方式来进行实例的创建：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　CharSequence cs=”hello”;</span><br></pre></td></tr></table></figure></p><h3 id="compareTo"><a href="#compareTo" class="headerlink" title="compareTo"></a>compareTo</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String anotherString)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = value.length;</span><br><span class="line">    <span class="keyword">int</span> len2 = anotherString.value.length;</span><br><span class="line">    <span class="keyword">int</span> lim = Math.min(len1, len2);</span><br><span class="line">    <span class="keyword">char</span> v1[] = value;</span><br><span class="line">    <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; lim) &#123;</span><br><span class="line">        <span class="keyword">char</span> c1 = v1[k];</span><br><span class="line">        <span class="keyword">char</span> c2 = v2[k];</span><br><span class="line">        <span class="comment">//比较2个字符串的每个字符，如果不相同，则返回c1-c2，即字母表排序大的大</span></span><br><span class="line">        <span class="keyword">if</span> (c1 != c2) &#123;</span><br><span class="line">            <span class="keyword">return</span> c1 - c2;</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果长度不一，而且长和短的前面全部重合，则长的长。</span></span><br><span class="line">    <span class="keyword">return</span> len1 - len2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//忽略大小写的比较，直接调用的是定义的静态内部类的compare方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareToIgnoreCase</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> CASE_INSENSITIVE_ORDER.compare(<span class="keyword">this</span>, str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//作用：判断2个字符串从tooffset开始，与other的ooffset开始，长度为len的子字符串想否相等。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">regionMatches</span><span class="params">(<span class="keyword">int</span> toffset, String other, <span class="keyword">int</span> ooffset,<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ta[] = value;</span><br><span class="line">    <span class="keyword">int</span> to = toffset;</span><br><span class="line">    <span class="keyword">char</span> pa[] = other.value;</span><br><span class="line">    <span class="keyword">int</span> po = ooffset;</span><br><span class="line">    <span class="comment">// 越界检测.</span></span><br><span class="line">    <span class="keyword">if</span> ((ooffset &lt; <span class="number">0</span>) || (toffset &lt; <span class="number">0</span>)</span><br><span class="line">            || (toffset &gt; (<span class="keyword">long</span>)value.length - len)</span><br><span class="line">            || (ooffset &gt; (<span class="keyword">long</span>)other.value.length - len)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历2个子串，如果不相等则为false</span></span><br><span class="line">    <span class="keyword">while</span> (len-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ta[to++] != pa[po++]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//作用：判断从tooffset开始，与other的ooffset开始，长度为len的字符串想否相等。ignoreCase如果为true，则无视大小写</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">regionMatches</span><span class="params">(<span class="keyword">boolean</span> ignoreCase, <span class="keyword">int</span> toffset,String other, <span class="keyword">int</span> ooffset, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ta[] = value;</span><br><span class="line">    <span class="keyword">int</span> to = toffset;</span><br><span class="line">    <span class="keyword">char</span> pa[] = other.value;</span><br><span class="line">    <span class="keyword">int</span> po = ooffset;</span><br><span class="line">    <span class="comment">// 越界检查</span></span><br><span class="line">    <span class="keyword">if</span> ((ooffset &lt; <span class="number">0</span>) || (toffset &lt; <span class="number">0</span>)</span><br><span class="line">            || (toffset &gt; (<span class="keyword">long</span>)value.length - len)</span><br><span class="line">            || (ooffset &gt; (<span class="keyword">long</span>)other.value.length - len)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (len-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> c1 = ta[to++];</span><br><span class="line">        <span class="keyword">char</span> c2 = pa[po++];</span><br><span class="line">        <span class="keyword">if</span> (c1 == c2) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ignoreCase) &#123;</span><br><span class="line">            <span class="comment">//如果ignoreCase为true，则进行忽略大小写的比较</span></span><br><span class="line">            <span class="comment">// continue.</span></span><br><span class="line">            <span class="keyword">char</span> u1 = Character.toUpperCase(c1);</span><br><span class="line">            <span class="keyword">char</span> u2 = Character.toUpperCase(c2);</span><br><span class="line">            <span class="keyword">if</span> (u1 == u2) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 转化为大写，Georgian alphabet字母可能会比较错误，所以转化为小写再比较一次。</span></span><br><span class="line">            <span class="keyword">if</span> (Character.toLowerCase(u1) == Character.toLowerCase(u2)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="startsWith"><a href="#startsWith" class="headerlink" title="startsWith"></a>startsWith</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断字符串的toffset下标之后是不是prefix</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix, <span class="keyword">int</span> toffset)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ta[] = value;</span><br><span class="line">    <span class="keyword">int</span> to = toffset;</span><br><span class="line">    <span class="keyword">char</span> pa[] = prefix.value;</span><br><span class="line">    <span class="keyword">int</span> po = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> pc = prefix.value.length;</span><br><span class="line">    <span class="comment">// 越界检查</span></span><br><span class="line">    <span class="keyword">if</span> ((toffset &lt; <span class="number">0</span>) || (toffset &gt; value.length - pc)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断字符串的toffset与prefix是否相等，不相等则为false</span></span><br><span class="line">    <span class="keyword">while</span> (--pc &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ta[to++] != pa[po++]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断字符串的开头是否为prefix</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> startsWith(prefix, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断字符串的结尾是否为prefix</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">endsWith</span><span class="params">(String suffix)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//从字符串的最后suffix长度是否为suffix</span></span><br><span class="line">    <span class="keyword">return</span> startsWith(suffix, value.length - suffix.value.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode"></a>hashCode</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求hash值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> val[] = value;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">            <span class="comment">//31*h+字符的值</span></span><br><span class="line">            h = <span class="number">31</span> * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//作用，查找字符串中占2位的字符</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">indexOfSupplementary</span><span class="params">(<span class="keyword">int</span> ch, <span class="keyword">int</span> fromIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Character.isValidCodePoint(ch)) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] value = <span class="keyword">this</span>.value;</span><br><span class="line">        <span class="comment">//取出字符的高低2位</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span> hi = Character.highSurrogate(ch);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span> lo = Character.lowSurrogate(ch);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> max = value.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = fromIndex; i &lt; max; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value[i] == hi &amp;&amp; value[i + <span class="number">1</span>] == lo) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//作用：查找ch所在字符串的下标</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">int</span> ch, <span class="keyword">int</span> fromIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> max = value.length;</span><br><span class="line">    <span class="keyword">if</span> (fromIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        fromIndex = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fromIndex &gt;= max) &#123;</span><br><span class="line">        <span class="comment">//越界</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ch &lt; Character.MIN_SUPPLEMENTARY_CODE_POINT) &#123;</span><br><span class="line">        <span class="comment">//处理大多数情况（ch是BMP代码点或负值（无效代码点））</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] value = <span class="keyword">this</span>.value;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = fromIndex; i &lt; max; i++) &#123;</span><br><span class="line">            <span class="comment">//找到了目标字符，直接返回该下标</span></span><br><span class="line">            <span class="keyword">if</span> (value[i] == ch) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//处理2位的字符</span></span><br><span class="line">        <span class="keyword">return</span> indexOfSupplementary(ch, fromIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//作用：</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">char</span>[] source, <span class="keyword">int</span> sourceOffset, <span class="keyword">int</span> sourceCount, <span class="keyword">char</span>[] target, <span class="keyword">int</span> targetOffset, <span class="keyword">int</span> targetCount, <span class="keyword">int</span> fromIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//越界检查和处理</span></span><br><span class="line">    <span class="keyword">if</span> (fromIndex &gt;= sourceCount) &#123;</span><br><span class="line">        <span class="keyword">return</span> (targetCount == <span class="number">0</span> ? sourceCount : -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fromIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        fromIndex = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (targetCount == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> fromIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> first = target[targetOffset];</span><br><span class="line">    <span class="comment">//比对所能到达的最大下标</span></span><br><span class="line">    <span class="keyword">int</span> max = sourceOffset + (sourceCount - targetCount);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = sourceOffset + fromIndex; i &lt;= max; i++) &#123;</span><br><span class="line">        <span class="comment">//查找所要查找的第一个字符</span></span><br><span class="line">        <span class="keyword">if</span> (source[i] != first) &#123;</span><br><span class="line">            <span class="keyword">while</span> (++i &lt;= max &amp;&amp; source[i] != first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//比较之后的全部</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt;= max) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> end = j + targetCount - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = targetOffset + <span class="number">1</span>; j &lt; end &amp;&amp; source[j]</span><br><span class="line">                    == target[k]; j++, k++);</span><br><span class="line">            <span class="keyword">if</span> (j == end) &#123;</span><br><span class="line">                <span class="comment">//如果j==end，则说明全部相等，即找得到源字符数组中的目标数组的下标</span></span><br><span class="line">                <span class="keyword">return</span> i - sourceOffset;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找不到返回-1</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//其他方法则是调用以上方法</span></span><br></pre></td></tr></table></figure><h3 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="lastIndexOf"></a>lastIndexOf</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数：source 目标字符数组； sourceOffset 查找的开始下标； sourceCount 目标数组大小； target 查找的字符数组； targetOffset ；  targetCount  ； fromIndex 开始查找的下标</span></span><br><span class="line"><span class="comment">//作用：查找到字符数组在目标字符数组的最后位置</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(<span class="keyword">char</span>[] source, <span class="keyword">int</span> sourceOffset, <span class="keyword">int</span> sourceCount, <span class="keyword">char</span>[] target, <span class="keyword">int</span> targetOffset, <span class="keyword">int</span> targetCount, <span class="keyword">int</span> fromIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Check arguments; return immediately where possible. For</span></span><br><span class="line"><span class="comment">     * consistency, don't check for null str.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> rightIndex = sourceCount - targetCount;</span><br><span class="line">    <span class="keyword">if</span> (fromIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fromIndex &gt; rightIndex) &#123;</span><br><span class="line">        fromIndex = rightIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Empty string always matches. */</span></span><br><span class="line">    <span class="keyword">if</span> (targetCount == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> fromIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> strLastIndex = targetOffset + targetCount - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> strLastChar = target[strLastIndex];</span><br><span class="line">    <span class="keyword">int</span> min = sourceOffset + targetCount - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> i = min + fromIndex;</span><br><span class="line"></span><br><span class="line">startSearchForLastChar:</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= min &amp;&amp; source[i] != strLastChar) &#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; min) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> start = j - (targetCount - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> k = strLastIndex - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (j &gt; start) &#123;</span><br><span class="line">            <span class="keyword">if</span> (source[j--] != target[k--]) &#123;</span><br><span class="line">                i--;</span><br><span class="line">                <span class="keyword">continue</span> startSearchForLastChar;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> start - sourceOffset + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="substring"><a href="#substring" class="headerlink" title="substring"></a>substring</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//越界检查</span></span><br><span class="line">    <span class="keyword">if</span> (beginIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(beginIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> subLen = value.length - beginIndex;</span><br><span class="line">    <span class="keyword">if</span> (subLen &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(subLen);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果从0开始，则直接返回该字符串，否则，从beginIndex开始subLen个字符，创建一个新字符串</span></span><br><span class="line"><span class="keyword">return</span> (beginIndex == <span class="number">0</span>) ? <span class="keyword">this</span> : <span class="keyword">new</span> String(value, beginIndex, subLen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//越界检查</span></span><br><span class="line">    <span class="keyword">if</span> (beginIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(beginIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (endIndex &gt; value.length) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(endIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> subLen = endIndex - beginIndex;</span><br><span class="line"><span class="comment">//检查输入是否合理</span></span><br><span class="line">    <span class="keyword">if</span> (subLen &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(subLen);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果从0到length，则直接返回该字符串，否则，返回从beginIndex开始subLen个字符创建的一个新字符串</span></span><br><span class="line">    <span class="keyword">return</span> ((beginIndex == <span class="number">0</span>) &amp;&amp; (endIndex == value.length)) ? <span class="keyword">this</span></span><br><span class="line">            : <span class="keyword">new</span> String(value, beginIndex, subLen);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回类型为CharSequence的截取</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CharSequence <span class="title">subSequence</span><span class="params">(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.substring(beginIndex, endIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//作用：拼接字符串</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concat</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> otherLen = str.length();</span><br><span class="line">    <span class="comment">//如果拼接的字符串长度为0，则无需拼接</span></span><br><span class="line">    <span class="keyword">if</span> (otherLen == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = value.length;</span><br><span class="line">    <span class="comment">//把原字符串放到buf数组的开头，即0到len处</span></span><br><span class="line">    <span class="keyword">char</span> buf[] = Arrays.copyOf(value, len + otherLen);</span><br><span class="line">    <span class="comment">//把str即拼接的字符串，拼接到buf的len之后</span></span><br><span class="line">    str.getChars(buf, len);</span><br><span class="line">    <span class="comment">//返回拼接后的新字符串即 源字符串+拼接的字符串</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(buf, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//作用：使用newChar替换oldChar，返回替换后的新字符串</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replace</span><span class="params">(<span class="keyword">char</span> oldChar, <span class="keyword">char</span> newChar)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果替换的字符一样则无需替换</span></span><br><span class="line">    <span class="keyword">if</span> (oldChar != newChar) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = value.length;</span><br><span class="line">        <span class="keyword">int</span> i = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span>[] val = value;</span><br><span class="line">        <span class="comment">//找到第一个oldChar，找不到则直接返回原字符串</span></span><br><span class="line">        <span class="keyword">while</span> (++i &lt; len) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val[i] == oldChar) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到了oldChar则进入</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; len) &#123;</span><br><span class="line">            <span class="keyword">char</span> buf[] = <span class="keyword">new</span> <span class="keyword">char</span>[len];</span><br><span class="line">            <span class="comment">//把之前的oldChar放入buf</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                buf[j] = val[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//之后的如果有oldChar则替换成newChar</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">                <span class="keyword">char</span> c = val[i];</span><br><span class="line">                buf[i] = (c == oldChar) ? newChar : c;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//返回替换后的字符串</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> String(buf, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="contains"><a href="#contains" class="headerlink" title="contains"></a>contains</h3> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//坚持字符串是否含有目标CharSequence</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(CharSequence s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(s.toString()) &gt; -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="补充：StringJoiner"><a href="#补充：StringJoiner" class="headerlink" title="补充：StringJoiner"></a>补充：StringJoiner</h3><p>StringJoiner用于构造分隔的字符序列通过分隔符，并可选择以提供的前缀开头并以提供的后缀结束。</p><h4 id="变量-1"><a href="#变量-1" class="headerlink" title="变量"></a>变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String prefix; <span class="comment">//前缀</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String delimiter; <span class="comment">//分隔符</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String suffix;<span class="comment">//后缀</span></span><br><span class="line"><span class="keyword">private</span> StringBuilder value;<span class="comment">//StringBuilder存储值</span></span><br><span class="line"><span class="keyword">private</span> String emptyValue;</span><br></pre></td></tr></table></figure><h4 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传入分隔符的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringJoiner</span><span class="params">(CharSequence delimiter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(delimiter, <span class="string">""</span>, <span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//传入分隔符、前缀、后缀的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringJoiner</span><span class="params">(CharSequence delimiter,</span></span></span><br><span class="line"><span class="function"><span class="params">                    CharSequence prefix,</span></span></span><br><span class="line"><span class="function"><span class="params">                    CharSequence suffix)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(prefix, <span class="string">"The prefix must not be null"</span>);</span><br><span class="line">    Objects.requireNonNull(delimiter, <span class="string">"The delimiter must not be null"</span>);</span><br><span class="line">    Objects.requireNonNull(suffix, <span class="string">"The suffix must not be null"</span>);</span><br><span class="line">    <span class="keyword">this</span>.prefix = prefix.toString();</span><br><span class="line">    <span class="keyword">this</span>.delimiter = delimiter.toString();</span><br><span class="line">    <span class="keyword">this</span>.suffix = suffix.toString();</span><br><span class="line">    <span class="comment">//空值在这里置为前缀+后缀</span></span><br><span class="line">    <span class="keyword">this</span>.emptyValue = <span class="keyword">this</span>.prefix + <span class="keyword">this</span>.suffix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//值为空则返回前缀+后缀，在初始化时已经赋值给emptyValue</span></span><br><span class="line">        <span class="keyword">return</span> emptyValue;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//后缀为空则直接返回value</span></span><br><span class="line">        <span class="keyword">if</span> (suffix.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> value.toString();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> initialLength = value.length();</span><br><span class="line">            String result = value.append(suffix).toString();</span><br><span class="line">            <span class="comment">//更新其长度</span></span><br><span class="line">            value.setLength(initialLength);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="prepareBuilder"><a href="#prepareBuilder" class="headerlink" title="prepareBuilder"></a>prepareBuilder</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> StringBuilder <span class="title">prepareBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//不为空时添加一个分隔符</span></span><br><span class="line">        value.append(delimiter);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//为空时添加一个前缀符</span></span><br><span class="line">        value = <span class="keyword">new</span> StringBuilder().append(prefix);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="length-1"><a href="#length-1" class="headerlink" title="length"></a>length</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (value != <span class="keyword">null</span> ? value.length() + suffix.length() :</span><br><span class="line">            emptyValue.length());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="add"><a href="#add" class="headerlink" title="add"></a>add</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StringJoiner <span class="title">add</span><span class="params">(CharSequence newElement)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//prepareBuilder添加完分隔符或者前缀符之后，再添加newElement</span></span><br><span class="line">    prepareBuilder().append(newElement);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StringJoiner <span class="title">merge</span><span class="params">(StringJoiner other)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(other);</span><br><span class="line">    <span class="keyword">if</span> (other.value != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> length = other.value.length();</span><br><span class="line">        <span class="comment">//执行prepareBuilder</span></span><br><span class="line">        StringBuilder builder = prepareBuilder();</span><br><span class="line">        <span class="comment">//合并other，去掉其前缀</span></span><br><span class="line">        builder.append(other.value, other.prefix.length(), length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">join</span><span class="params">(CharSequence delimiter, CharSequence... elements)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(delimiter);</span><br><span class="line">    Objects.requireNonNull(elements);</span><br><span class="line">    <span class="comment">//创建一个StringJoiner，分隔符为delimiter</span></span><br><span class="line">    StringJoiner joiner = <span class="keyword">new</span> StringJoiner(delimiter);</span><br><span class="line">    <span class="comment">//把elements按delimiter分隔连接</span></span><br><span class="line">    <span class="keyword">for</span> (CharSequence cs: elements) &#123;</span><br><span class="line">        joiner.add(cs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> joiner.toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">join</span><span class="params">(CharSequence delimiter, Iterable&lt;? extends CharSequence&gt; elements)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(delimiter);</span><br><span class="line">    Objects.requireNonNull(elements);</span><br><span class="line">    StringJoiner joiner = <span class="keyword">new</span> StringJoiner(delimiter);</span><br><span class="line">    <span class="keyword">for</span> (CharSequence cs: elements) &#123;</span><br><span class="line">        joiner.add(cs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> joiner.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="trim"><a href="#trim" class="headerlink" title="trim"></a>trim</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">trim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = value.length;</span><br><span class="line">    <span class="keyword">int</span> st = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span>[] val = value;   </span><br><span class="line"><span class="comment">//从开头遍历空格</span></span><br><span class="line">    <span class="keyword">while</span> ((st &lt; len) &amp;&amp; (val[st] &lt;= <span class="string">' '</span>)) &#123;</span><br><span class="line">        st++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历结尾的空格</span></span><br><span class="line">    <span class="keyword">while</span> ((st &lt; len) &amp;&amp; (val[len - <span class="number">1</span>] &lt;= <span class="string">' '</span>)) &#123;</span><br><span class="line">        len--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果st不为0，len不等于value.length，则截取st到len的子字符串</span></span><br><span class="line">    <span class="keyword">return</span> ((st &gt; <span class="number">0</span>) || (len &lt; value.length)) ? substring(st, len) : <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="toString"><a href="#toString" class="headerlink" title="toString"></a>toString</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="toCharArray"><a href="#toCharArray" class="headerlink" title="toCharArray"></a>toCharArray</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">char</span>[] toCharArray() &#123;</span><br><span class="line">    <span class="comment">// 由于类初始化顺序问题，无法使用Arrays.copyOf</span></span><br><span class="line">    <span class="keyword">char</span> result[] = <span class="keyword">new</span> <span class="keyword">char</span>[value.length];</span><br><span class="line">    System.arraycopy(value, <span class="number">0</span>, result, <span class="number">0</span>, value.length);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf"></a>valueOf</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (obj == <span class="keyword">null</span>) ? <span class="string">"null"</span> : obj.toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//字符数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">char</span> data[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">char</span> data[], <span class="keyword">int</span> offset, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(data, offset, count);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//boolean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? <span class="string">"true"</span> : <span class="string">"false"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//字符</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> data[] = &#123;c&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(data, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//int</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Integer.toString(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考文章：<a href="https://blog.csdn.net/iblade/article/details/78111223" target="_blank" rel="noopener">https://blog.csdn.net/iblade/article/details/78111223</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;String源码学习&quot;&gt;&lt;a href=&quot;#String源码学习&quot; class=&quot;headerlink&quot; title=&quot;String源码学习&quot;&gt;&lt;/a&gt;String源码学习&lt;/h1&gt;&lt;h2 id=&quot;变量&quot;&gt;&lt;a href=&quot;#变量&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-栈的压入、弹出序列</title>
    <link href="http://yoursite.com/2019/08/05/%E5%89%91%E6%8C%87offer-%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/"/>
    <id>http://yoursite.com/2019/08/05/剑指offer-栈的压入、弹出序列/</id>
    <published>2019-08-05T13:23:52.905Z</published>
    <updated>2019-08-06T01:59:18.590Z</updated>
    
    <content type="html"><![CDATA[<p>﻿## 题目</p><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>第一步：pushA<strong>从头遍历</strong>，popA<strong>从尾开始</strong>；如果pushA[i]==popA[index]相等，则无需操作,index–;如果不相等，则pushA[i]放入栈中；<br>第二步：取出栈中的所有元素，判断是否与之前pushA与popA匹配后剩下的元素完全相同。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public boolean IsPopOrder(int[] pushA, int[] popA) &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        int index = popA.length-1;</span><br><span class="line">        for (int i = 0; i &lt; pushA.length; i++) &#123;</span><br><span class="line">            if (pushA[i] == popA[index]) &#123;</span><br><span class="line">                index --;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                stack.push(pushA[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while (index &gt;= 0) &#123;</span><br><span class="line">            if (stack.pop() != popA[index--])</span><br><span class="line">                return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p><img src="https://img-blog.csdnimg.cn/20190805212350685.png" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;﻿## 题目&lt;/p&gt;
&lt;p&gt;输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是
      
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-包含min函数的栈</title>
    <link href="http://yoursite.com/2019/08/05/%E5%89%91%E6%8C%87offer-%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/"/>
    <id>http://yoursite.com/2019/08/05/剑指offer-包含min函数的栈/</id>
    <published>2019-08-05T11:48:16.228Z</published>
    <updated>2019-08-06T01:58:55.766Z</updated>
    
    <content type="html"><![CDATA[<p>﻿## 题目</p><p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>第一步：使用一个min变量保存栈中的最小值<br>第二步：在每次对栈中进行增删时判断最小值是否改变，如果改变则维护min的值。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">    int min = Integer.MAX_VALUE;</span><br><span class="line">    public void push(int node) &#123;</span><br><span class="line">        if (node &lt; min) &#123;</span><br><span class="line">            min = node;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.add(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void pop() &#123;</span><br><span class="line">        Integer pop = stack.pop();</span><br><span class="line">        if (pop == min)&#123;</span><br><span class="line">            min = Integer.MAX_VALUE;</span><br><span class="line">            for (int val: stack) &#123;</span><br><span class="line">                if (val &lt; min)</span><br><span class="line">                    min = val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int top() &#123;</span><br><span class="line">        Integer remove = stack.remove(0);</span><br><span class="line">        if (remove == min)&#123;</span><br><span class="line">            min = Integer.MAX_VALUE;</span><br><span class="line">            for (int val: stack) &#123;</span><br><span class="line">                if (val &lt; min)</span><br><span class="line">                    min = val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return remove;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int min() &#123;</span><br><span class="line">        return min;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p><img src="https://img-blog.csdnimg.cn/2019080519481369.png" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;﻿## 题目&lt;/p&gt;
&lt;p&gt;定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。&lt;/p&gt;
&lt;h2 id=&quot;解题思路&quot;&gt;&lt;a href=&quot;#解题思路&quot; class=&quot;headerlink&quot; title=&quot;解题思路&quot;&gt;&lt;/a&gt;解
      
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-二叉树的镜像</title>
    <link href="http://yoursite.com/2019/08/04/%E5%89%91%E6%8C%87offer-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/"/>
    <id>http://yoursite.com/2019/08/04/剑指offer-二叉树的镜像/</id>
    <published>2019-08-04T14:48:27.548Z</published>
    <updated>2019-08-04T14:51:17.935Z</updated>
    
    <content type="html"><![CDATA[<p>﻿## 题目</p><p>操作给定的二叉树，将其变换为源二叉树的镜像。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p><strong>递归解法</strong><br>第一步：如果根节点为空，直接结束；<br>第二步：交换2个子结点的位置；<br>第三步：递归子结点。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void Mirror(TreeNode root) &#123;</span><br><span class="line">        if (root == null) return;</span><br><span class="line">        TreeNode temp = root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = temp;</span><br><span class="line">        Mirror(root.left);</span><br><span class="line">        Mirror(root.right);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p><img src="https://img-blog.csdnimg.cn/20190804224824721.png" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;﻿## 题目&lt;/p&gt;
&lt;p&gt;操作给定的二叉树，将其变换为源二叉树的镜像。&lt;/p&gt;
&lt;h2 id=&quot;解题思路&quot;&gt;&lt;a href=&quot;#解题思路&quot; class=&quot;headerlink&quot; title=&quot;解题思路&quot;&gt;&lt;/a&gt;解题思路&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;递归解法&lt;/stro
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="剑指offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-树的子结构</title>
    <link href="http://yoursite.com/2019/08/04/%E5%89%91%E6%8C%87offer-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2019/08/04/剑指offer-树的子结构/</id>
    <published>2019-08-04T07:32:38.876Z</published>
    <updated>2019-08-04T14:50:47.185Z</updated>
    
    <content type="html"><![CDATA[<p>﻿## 题目</p><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>以下是使用的递归思路：<br>第一步：如果root2为空，则说明root2是root1的子结构。<strong>（这需要一个辅助条件，就是这题目上要求，root2为空即返回false需要排除掉）</strong> 如果root1为空，则说明不是root1的子结构。<br>第二步：如果root1和root2不相同，则返回root1的子节点和root2的比较。<br>第三步：如果root1和root2相同，则比较他们的子节点是否相同，如果相同返回true，如果不相同，则返回root1的子节点和root2的比较。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//树的子结构</span><br><span class="line">    public boolean HasSubtree(TreeNode root1, TreeNode root2) &#123;</span><br><span class="line">        if (root2 == null) return false;</span><br><span class="line">        return helper(root1, root2);</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean helper(TreeNode root1, TreeNode root2) &#123;</span><br><span class="line">        if (root2 == null) return true;</span><br><span class="line">        if (root1 == null) return false;</span><br><span class="line">        if (root1.val == root2.val) &#123;</span><br><span class="line">            if(helper(root1.left, root2.left)</span><br><span class="line">                    &amp;&amp; helper(root1.right, root2.right))&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return helper(root1.left, root2) || helper(root1.right, root2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p><img src="https://img-blog.csdnimg.cn/20190804152313615.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDQ4NTc0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;﻿## 题目&lt;/p&gt;
&lt;p&gt;输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）&lt;/p&gt;
&lt;h2 id=&quot;解题思路&quot;&gt;&lt;a href=&quot;#解题思路&quot; class=&quot;headerlink&quot; title=&quot;解题思路&quot;&gt;&lt;/a&gt;解题思路&lt;/h
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="剑指offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-合并两个排序的链表</title>
    <link href="http://yoursite.com/2019/08/04/%E5%89%91%E6%8C%87offer-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2019/08/04/剑指offer-合并两个排序的链表/</id>
    <published>2019-08-04T06:03:09.886Z</published>
    <updated>2019-08-04T14:50:04.189Z</updated>
    
    <content type="html"><![CDATA[<p>﻿## 题目</p><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>第一步：定义一条新的空链表<br>第二步：比较两条链表的表头，把小的接在新链表后面，直到某一条链表为空<br>第三步：把不为空的另一条链表接在新链表后面即可。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public ListNode Merge(ListNode list1,ListNode list2) &#123;</span><br><span class="line">        ListNode res = new ListNode(0);</span><br><span class="line">        ListNode p = res;</span><br><span class="line">        while (list1 != null &amp;&amp; list2 != null) &#123;</span><br><span class="line">            if (list1.val &lt;= list2.val) &#123;</span><br><span class="line">                p.next = list1;</span><br><span class="line">                list1 = list1.next;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                p.next = list2;</span><br><span class="line">                list2 = list2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        if (list1 == null) &#123;</span><br><span class="line">            p.next = list2;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            p.next = list1;</span><br><span class="line">        &#125;</span><br><span class="line">        return res.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p><img src="https://img-blog.csdnimg.cn/20190804140258846.png" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;﻿## 题目&lt;/p&gt;
&lt;p&gt;输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。&lt;/p&gt;
&lt;h2 id=&quot;解题思路&quot;&gt;&lt;a href=&quot;#解题思路&quot; class=&quot;headerlink&quot; title=&quot;解题思路&quot;&gt;&lt;/a&gt;解题思路&lt;/
      
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="剑指offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>Solr学习笔记</title>
    <link href="http://yoursite.com/2019/07/26/Solr%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/07/26/Solr学习笔记/</id>
    <published>2019-07-26T06:57:19.111Z</published>
    <updated>2019-08-06T02:00:11.222Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Solr学习笔记"><a href="#Solr学习笔记" class="headerlink" title="Solr学习笔记"></a>Solr学习笔记</h1><h2 id="Solr安装部署在centos7"><a href="#Solr安装部署在centos7" class="headerlink" title="Solr安装部署在centos7"></a>Solr安装部署在centos7</h2><p>第一步：安装tomcat</p><p><img src="C:\Users\xin\AppData\Roaming\Typora\typora-user-images\1564124267335.png" alt="1564124267335"></p><p>第二步：直接上代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#solr版本为8.1.1  </span><br><span class="line">#创建一个solr文件夹来保存相关文件 路径为/usr/local/services</span><br><span class="line">mkdir solr</span><br><span class="line">#复制tomcat到该文件夹中</span><br><span class="line">cp apache-tomcat-9.0.21 solr -r</span><br><span class="line"></span><br><span class="line">#复制solr中的webapp文件夹到tomcat中webapps的solr8中</span><br><span class="line">cp server/solr-webapp/webapp/ /usr/local/services/solr/apache-tomcat-9.0.21/webapps/solr8 -r</span><br><span class="line"></span><br><span class="line">#复制solr-8.1.1/server/lib下的所有jar包到tomcat下的solr</span><br><span class="line">cp * /usr/local/services/solr/apache-tomcat-9.0.21/webapps/solr8/WEB-INF/lib</span><br><span class="line"></span><br><span class="line">#复制server/lib/ext的所有jar包</span><br><span class="line">cp * /usr/local/services/solr/apache-tomcat-9.0.21/webapps/solr8/WEB-INF/lib</span><br><span class="line"></span><br><span class="line">#拷贝log4j2配置文件：将solr-8.1.1/server/resource目录中的log4j配置文件拷入web工程目录WEB-INF/classes（自行创建目录）</span><br><span class="line">cp -r log4j2* /usr/local/services/solr/apache-tomcat-9.0.21/webapps/solr8/WEB-INF/classes</span><br><span class="line"></span><br><span class="line">#创建solrhome目录，把solr-8.1.1/server下的solr复制到solr中</span><br><span class="line">#并命名为solr8home</span><br><span class="line">cp solr /usr/local/services/solr/solr8home -r</span><br><span class="line"></span><br><span class="line">#修改solr8/WEB_INF/lib下的web.xml</span><br><span class="line">vim web.xml</span><br><span class="line">#注释掉下面的代码</span><br><span class="line">&lt;!--</span><br><span class="line">  &lt;security-constraint&gt;</span><br><span class="line">    &lt;web-resource-collection&gt;</span><br><span class="line">      &lt;web-resource-name&gt;Disable TRACE&lt;/web-resource-name&gt;</span><br><span class="line">      &lt;url-pattern&gt;/&lt;/url-pattern&gt;</span><br><span class="line">      &lt;http-method&gt;TRACE&lt;/http-method&gt;</span><br><span class="line">    &lt;/web-resource-collection&gt;</span><br><span class="line">    &lt;auth-constraint/&gt;</span><br><span class="line">  &lt;/security-constraint&gt;</span><br><span class="line">  &lt;security-constraint&gt;</span><br><span class="line">    &lt;web-resource-collection&gt;</span><br><span class="line">      &lt;web-resource-name&gt;Enable everything but TRACE&lt;/web-resource-name&gt;</span><br><span class="line">      &lt;url-pattern&gt;/&lt;/url-pattern&gt;</span><br><span class="line">      &lt;http-method-omission&gt;TRACE&lt;/http-method-omission&gt;</span><br><span class="line">    &lt;/web-resource-collection&gt;</span><br><span class="line">  &lt;/security-constraint&gt;</span><br><span class="line">--&gt;</span><br><span class="line">#添加以下代码,env-entry-value的值即solrhome目录</span><br><span class="line">  &lt;env-entry&gt;</span><br><span class="line">    &lt;env-entry-name&gt;solr/home&lt;/env-entry-name&gt;</span><br><span class="line">    &lt;env-entry-value&gt;/usr/local/services/solr/solr8home&lt;/env-entry-value&gt;</span><br><span class="line">    &lt;env-entry-type&gt;java.lang.String&lt;/env-entry-type&gt;</span><br><span class="line">  &lt;/env-entry&gt;</span><br><span class="line"></span><br><span class="line">#启动tomcat</span><br><span class="line">./startup.sh</span><br></pre></td></tr></table></figure><p>第三步：测试连接</p><p><img src="C:\Users\xin\AppData\Roaming\Typora\typora-user-images\1564127500323.png" alt="1564127500323"></p><p>参考自 <a href="https://blog.csdn.net/qq_27570205/article/details/93062856" target="_blank" rel="noopener">https://blog.csdn.net/qq_27570205/article/details/93062856</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Solr学习笔记&quot;&gt;&lt;a href=&quot;#Solr学习笔记&quot; class=&quot;headerlink&quot; title=&quot;Solr学习笔记&quot;&gt;&lt;/a&gt;Solr学习笔记&lt;/h1&gt;&lt;h2 id=&quot;Solr安装部署在centos7&quot;&gt;&lt;a href=&quot;#Solr安装部署在cent
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>leetcode334. 递增的三元子序列</title>
    <link href="http://yoursite.com/2019/07/14/leetcode334.%20%E9%80%92%E5%A2%9E%E7%9A%84%E4%B8%89%E5%85%83%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>http://yoursite.com/2019/07/14/leetcode334. 递增的三元子序列/</id>
    <published>2019-07-14T02:51:20.421Z</published>
    <updated>2019-07-14T02:51:17.764Z</updated>
    
    <content type="html"><![CDATA[<p>﻿## 题目</p><blockquote><p>给定一个未排序的数组，判断这个数组中是否存在长度为 3 的递增子序列。</p><p>数学表达式如下:</p><p>如果存在这样的 i, j, k,  且满足 0 ≤ i &lt; j &lt; k ≤ n-1， 使得 arr[i] &lt; arr[j] &lt; arr[k]<br>，返回 true ; 否则返回 false 。 说明: 要求算法的时间复杂度为 O(n)，空间复杂度为 O(1) 。</p><p>示例 1:</p><p>输入: [1,2,3,4,5] 输出: true 示例 2:</p><p>输入: [5,4,3,2,1] 输出: false</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/increasing-triplet-subsequence" target="_blank" rel="noopener">https://leetcode-cn.com/problems/increasing-triplet-subsequence</a></p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>第一步：转化题目，求长度为3的递增子序列，等同于维护3个下标，如题目所述。<br>第二步：使用2个变量保存最小的2个数值，即min1为数组当前的最小值，min2为第二小的值。<br>第三步：如果出现小于min1的值，更新min1；如果出现小于min2的值，更新min2。（本人所写代码中使用了小于等于，是因为要排除等于的情况）<br>第四步：如果找到大于min2的数，则说明存在长度为3的递增子序列</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean increasingTriplet(int[] nums) &#123;</span><br><span class="line">        if (nums.length &lt; 3) return false;</span><br><span class="line">        int min1 = nums[0];</span><br><span class="line">        int min2 = Integer.MAX_VALUE;</span><br><span class="line">        for (int i = 1; i &lt; nums.length; i++) &#123;</span><br><span class="line">            if (nums[i] &lt;= min1) &#123;</span><br><span class="line">                min1 = nums[i];</span><br><span class="line">            &#125; else if (nums[i] &lt;= min2) &#123;</span><br><span class="line">                min2 = nums[i];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p><img src="https://img-blog.csdnimg.cn/20190713221603642.png" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;﻿## 题目&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个未排序的数组，判断这个数组中是否存在长度为 3 的递增子序列。&lt;/p&gt;
&lt;p&gt;数学表达式如下:&lt;/p&gt;
&lt;p&gt;如果存在这样的 i, j, k,  且满足 0 ≤ i &amp;lt; j &amp;lt; k ≤ n-1， 使得
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode318. 最大单词长度乘积</title>
    <link href="http://yoursite.com/2019/07/14/leetcode337.%20%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%20III/"/>
    <id>http://yoursite.com/2019/07/14/leetcode337. 打家劫舍 III/</id>
    <published>2019-07-14T02:42:58.913Z</published>
    <updated>2019-07-14T02:51:32.950Z</updated>
    
    <content type="html"><![CDATA[<p>﻿## 题目</p><blockquote><p>在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。<br>除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。<br>如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。 计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。<br><strong>示例 1:</strong></p><p>输入: [3,2,3,null,3,null,1]<br><img src="https://img-blog.csdnimg.cn/20190714103836323.png" alt="在这里插入图片描述"></p><p>输出: 7<br>解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.<br><strong>示例 2:</strong></p><p>输入: [3,4,5,1,3,null,1]<br><img src="https://img-blog.csdnimg.cn/20190714103843845.png" alt="在这里插入图片描述"><br>输出: 9<br>解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9.</p><p>来源：力扣（LeetCode） 链接：<a href="https://leetcode-cn.com/problems/house-robber-iii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/house-robber-iii</a></p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>第一步：父节点如果被偷，则2个子结点必不可能被偷；父节点不被偷，则2个子结点有被偷的情况，即偷左右，偷左不偷右，偷右不偷左，左右都不偷4种。<br>第二步：深度搜索，返回一个数组res，res[0]表示当前节点被偷，res[1]表示当前节点不被偷；<br>第三步：返回max(res[0],res[1])</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int rob(TreeNode root) &#123;</span><br><span class="line">        int[] res = dfs(root);</span><br><span class="line">        return Math.max(res[0], res[1]);</span><br><span class="line">    &#125;</span><br><span class="line">    public int[] dfs(TreeNode root) &#123;</span><br><span class="line">        int[] res = new int[2];</span><br><span class="line">        if (root == null) return res;</span><br><span class="line">        int[] left = dfs(root.left);</span><br><span class="line">        int[] right = dfs(root.right);</span><br><span class="line">        res[0] = root.val + left[1] + right[1];</span><br><span class="line">        res[1] = Math.max(right[0], right[1]) +Math.max(left[0],left[1]);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p><img src="https://img-blog.csdnimg.cn/20190714104243432.png" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;﻿## 题目&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。&lt;br&gt;除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Java线程学习</title>
    <link href="http://yoursite.com/2019/07/13/Java%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2019/07/13/Java线程学习/</id>
    <published>2019-07-13T08:18:32.793Z</published>
    <updated>2019-07-13T12:56:37.396Z</updated>
    
    <content type="html"><![CDATA[<p>﻿# Java线程学习</p><h2 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h2><ul><li>进程是资源分配的最小单位，线程是CPU调度的最小单位。</li><li>进程可以看作是独立的应用，线程不可以。</li><li>进程有独立的地址空间，互相不影响，线程只是进程的不同执行路径。</li><li>线程没有独立的地址空间，多进程程序比多线程程序健壮</li><li>进程的切换开销比线程大</li></ul><h2 id="Java进程和线程的关系"><a href="#Java进程和线程的关系" class="headerlink" title="Java进程和线程的关系"></a>Java进程和线程的关系</h2><p>每运行一个程序就会产生一个进程，进程至少包含一个线程。</p><p>每个进程对应一个JVM实例，多个线程共享JVM里的堆。</p><p>Java采用单线程编程模型，程序会自动创建主线程。</p><p>主线程可以创建子线程，原则上要后于子线程完成执行。</p><h2 id="Thread中的start和run方法的区别"><a href="#Thread中的start和run方法的区别" class="headerlink" title="Thread中的start和run方法的区别"></a>Thread中的start和run方法的区别</h2><p>调用start()方法会<strong>创建</strong>一个新的子线程并启动。</p><p>run()方法只是Thread的一个普通方法的调用。</p><h2 id="Thread和Runnable的区别"><a href="#Thread和Runnable的区别" class="headerlink" title="Thread和Runnable的区别"></a>Thread和Runnable的区别</h2><p>Thread是类，Runnable是接口。</p><p>Thread是实现了Runnable接口的类，使得run支持多线程。</p><p>因类的单一继承原则，推荐多使用Runnable接口。</p><h2 id="如何实现处理线程的返回值"><a href="#如何实现处理线程的返回值" class="headerlink" title="如何实现处理线程的返回值"></a>如何实现处理线程的返回值</h2><p>主线程等待法</p><p>使用Thread中的join阻塞当前线程以等待子线程处理完毕</p><p>通过Callable接口实现：通过Future或者线程池获取。</p><h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><ol><li>新建（New）：创建后尚未启动的线程状态</li><li>运行（Runnable）：包含运行中Running和就绪状态Ready</li><li>无限期等待（Waiting）：不会被分配CPU执行时间，需要显式被唤醒</li><li>限期等待（Timed Waiting）：在一定时间后悔由系统自动唤醒</li><li>阻塞（Blocked）：等待获取排它锁</li><li>结束（Terminated）：已终止线程的状态，线程已经结束执行</li></ol><h2 id="sleep和wait的区别"><a href="#sleep和wait的区别" class="headerlink" title="sleep和wait的区别"></a>sleep和wait的区别</h2><p><strong>基本差别</strong></p><ul><li>sleep是Thread类的方法，wait是Object类中定义的方法</li><li>sleep()方法可以在任何地方使用</li><li>wait()方法只能在synchronized方法或synchronized块中使用</li></ul><p><strong>最主要的本质区别</strong></p><ul><li>Thread.sleep只会让出CPU，不会导致锁行为的改变</li><li>Object.wait不仅会让出CPU，还会释放已经占有的同步资源锁</li></ul><h2 id="notify和notifyAll的区别"><a href="#notify和notifyAll的区别" class="headerlink" title="notify和notifyAll的区别"></a>notify和notifyAll的区别</h2><h3 id="锁池"><a href="#锁池" class="headerlink" title="锁池"></a>锁池</h3><p>​    假设线程A已经拥有了某个对象的（不是类）锁而其他线程B、C想调用这个对象的某个synchronized方法（或块），由于B、C线程在进入对象的synchronized方法（或块）之前必须先获得该对象锁的拥有权，而恰巧该对象的锁目前正被线程A所占用，此时B、C线程就会被阻塞，进入一个地方等待锁的释放，这个地方就是该对象的<strong>锁池</strong>。</p><p>锁池就是线程竞争锁时所被放入的地方。</p><h3 id="等待池"><a href="#等待池" class="headerlink" title="等待池"></a>等待池</h3><p>​    假设线程A调用了某个对象的wait()方法，线程A就会释放该对象的锁，同时线程A就会进入到了该对象的<strong>等待池</strong>中，进入到等待池中的线程，不会去竞争该对象的锁。</p><ul><li>notifyAll会让所有处于等待池的线程全部进入锁池去竞争获取锁的机会</li><li>notify只会随机选取一个处于等待池中的线程进入锁池去竞争获取锁的机会</li></ul><h2 id="yieId"><a href="#yieId" class="headerlink" title="yieId"></a>yieId</h2><p>当调用Thread.yieId()方法时，会给线程调度器一个当前线程愿意让出CPU的暗示，但是线程调度器可能会忽略这个暗示。调用该方法不影响锁的行为。</p><h2 id="如何中断线程"><a href="#如何中断线程" class="headerlink" title="如何中断线程"></a>如何中断线程</h2><p><strong>已经被抛弃的方法</strong></p><ul><li>通过stop()方法停止线程</li><li>通过调用suspend和resume方法</li></ul><p><strong>目前使用的方法</strong></p><ul><li>调用interrupt()，通知线程应该中断了<ol><li>如果线程处于被阻塞状态，那么线程将立即退出被阻塞状态，并抛出一个InterruptedException异常</li><li>如果线程处于正常活动状态，那么会将该线程的中断标志设置为true。被设置中断标志的线程将继续政策执行，不受影响。</li></ol></li><li>需要被调度的线程配合中断<ol><li>在正常运行任何时，经常检查本线程的中断标志位，如果被设置了中断标志就自行停止线程</li><li>如果线程处于正常活动状态，那么就会将该线程的中断标准位设置为true。被设置中断标志的线程将继续政策执行，不受影响</li></ol></li></ul><h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><h2 id="线程安全问题的主要诱因"><a href="#线程安全问题的主要诱因" class="headerlink" title="线程安全问题的主要诱因"></a>线程安全问题的主要诱因</h2><ul><li>存在共享数据（也成临界资源）</li><li>存在多条线程共同操作这些共享数据</li></ul><p>解决问题的根本方法：</p><p>​    同一时刻有且只有一个线程在操作共享数据，其他线程必须等到该线程处理完数据后再对共享数据进行操作</p><h2 id="互斥锁的特性"><a href="#互斥锁的特性" class="headerlink" title="互斥锁的特性"></a>互斥锁的特性</h2><p>互斥性：即在同一时间只允许一个线程持有某个对象锁，通过这种特性来实现多线程的协调机制，这样在就实现了<strong>同一时间只有一个线程对需要同步的代码块（复合操作）进行访问</strong>。互斥性也称为操作的<strong>原子性</strong>。</p><p>可见性：必须确保在锁被释放之前，对共享变量所做的修改，对于随后获得该锁的另一个线程是可见的（即<strong>在获得锁时所获得的共享变量值是最新的</strong>），否则，另一个线程可能是在本地缓冲的某个副本继续进行操作，从而引起不一致。</p><h2 id="对象锁和类锁的总结"><a href="#对象锁和类锁的总结" class="headerlink" title="对象锁和类锁的总结"></a>对象锁和类锁的总结</h2><ol><li>有线程访问对象的同步代码块时，另外的线程可以访问该对象的非同步代码块；</li><li>若锁住的是同一个对象，一个线程在访问对象的<strong>同步代码块</strong>时，另一个访问对象的<strong>同步代码块</strong>的线程会被阻塞；</li><li>若锁住的是同一个对象，一个线程在访问对象的<strong>同步方法</strong>时，另一个访问对象的<strong>同步方法</strong>的线程会被阻塞；</li><li>若锁住的是同一个对象，一个线程在访问对象的<strong>同步代码块</strong>时，另一个访问对象的<strong>同步方法</strong>的线程会被阻塞，反之亦然；</li><li>同一个类的不同对象的对象锁互不干扰；</li><li>类锁由于也是一种特殊的对象锁，因此与1、2、3、4一致，而由于一个类只有一把对象锁，所以同一个类的不同对象，使用类锁将会是同步的。</li><li>类锁和对象锁互不干扰。</li></ol><h2 id="重入"><a href="#重入" class="headerlink" title="重入"></a>重入</h2><p>当某个线程请求一个由其他线程持有的锁时，发出请求的线程就会阻塞，但当一个线程再次请求自己持有对象锁的临界资源时，这种情况属于重入。由于对象锁是可重入的，因此如果某个线程试图获得一个已经由它自己持有的锁，那么这个请求就会成功。</p><h1 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h1><p><strong>实现原理</strong></p><p>同步方法是在flags标志中加入 ACC_SYNCHRONIZED</p><p>同步代码块是使用monitor （管程）实现</p><h2 id="Mark-Word（对象头）"><a href="#Mark-Word（对象头）" class="headerlink" title="Mark Word（对象头）"></a>Mark Word（对象头）</h2><p><img src="https://img-blog.csdnimg.cn/20190713205144719.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDQ4NTc0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><ul><li>许多情况下，共享数据的锁定状态持续时间较短，切换线程不值得</li><li>通过让线程执行忙循环等待锁的释放，不让出CPU</li><li>缺点：若锁被其他线程长时间占用，会带来许多性能上的开销</li></ul><h2 id="自适应自旋锁"><a href="#自适应自旋锁" class="headerlink" title="自适应自旋锁"></a>自适应自旋锁</h2><ul><li>自旋的次数不再固定</li><li>由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定</li></ul><h2 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h2><p>JIT编译时，对运行上下文进行扫描，去除不可能存在竞争的锁</p><h2 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h2><p>通过扩大加锁的范围，避免反复加锁和解锁</p><h2 id="synchronized的四种状态"><a href="#synchronized的四种状态" class="headerlink" title="synchronized的四种状态"></a>synchronized的四种状态</h2><p>无锁、偏向锁、轻量级锁、重量级锁</p><p>锁膨胀方向：无锁 → 偏向锁 → 轻量级锁 → 重量级锁</p><h3 id="无锁：没有加锁"><a href="#无锁：没有加锁" class="headerlink" title="无锁：没有加锁"></a>无锁：没有加锁</h3><h3 id="偏向锁：减少同一线程获取锁的代价"><a href="#偏向锁：减少同一线程获取锁的代价" class="headerlink" title="偏向锁：减少同一线程获取锁的代价"></a>偏向锁：减少同一线程获取锁的代价</h3><p>大多数情况下，锁不存在多线程竞争，总是由同一线程多次获得</p><p>核心思想：</p><p>如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark Word的结构也变成为偏向锁结构，当该线程再次请求锁时，无需再做任何同步操作，即获取锁的过程只需要坚持Mark Word的锁标记位为偏向锁以及当前线程Id等于Mark Word的ThreadID即可，这样就省去了大量有关锁申请的操作。</p><p>不适合于锁竞争毕竟激烈的多线程场合</p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>轻量级锁是由偏向锁升级来的，偏向锁运行在一个线程进入同步块的情况下，当第二个线程加入竞争时，偏向锁就会升级为轻量级锁。</p><p>适应的场景：线程交替执行同步块</p><p>若存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀为重量级锁</p><h3 id="锁的内存语义"><a href="#锁的内存语义" class="headerlink" title="锁的内存语义"></a>锁的内存语义</h3><p>当线程释放锁时，Java内存模型会<strong>把该线程对应的本地内存中的共享变量刷新到主内存中</strong>；</p><p>而当线程获得锁时，Java内存模型会把该线程对应的本地内存置为无效，从而使得被监视器保护的临界区代码必须<strong>从主内存中读取共享变量</strong>。</p><h3 id="偏向锁、轻量级锁、重量级锁的汇总"><a href="#偏向锁、轻量级锁、重量级锁的汇总" class="headerlink" title="偏向锁、轻量级锁、重量级锁的汇总"></a>偏向锁、轻量级锁、重量级锁的汇总</h3><p><img src="https://img-blog.csdnimg.cn/2019071320520517.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDQ4NTc0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="synchronized和ReentrantLock的区别"><a href="#synchronized和ReentrantLock的区别" class="headerlink" title="synchronized和ReentrantLock的区别"></a>synchronized和ReentrantLock的区别</h2><h3 id="ReentrantLock（再入锁）"><a href="#ReentrantLock（再入锁）" class="headerlink" title="ReentrantLock（再入锁）"></a>ReentrantLock（再入锁）</h3><ul><li>位于java.util.concurrent.locks包</li><li>和CountDownLatch、FutureTask、Semaphore一样基于AQS实现</li><li>能够实现比synchronized更细粒度的控制</li><li>调用lock()之后，必须调用unlock()释放锁</li><li>性能未必比synchronized高，并且也是可重入的</li></ul><h3 id="ReentrantLock公平性的设置"><a href="#ReentrantLock公平性的设置" class="headerlink" title="ReentrantLock公平性的设置"></a>ReentrantLock公平性的设置</h3><ul><li>ReentrantLock fairLock = new ReentrantLock(true);</li><li>参数为true时，倾向于将锁赋予等待时间最久的线程</li><li>公平锁：获取锁的顺序按先后调用lock方法的顺序（慎用）</li><li>非公平锁：抢占的顺序不一定，看运气</li><li>synchronized是非公平锁</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>synchronized是关键字，ReentrantLock是类</p><p>ReentrantLock可以对获取锁的等待时间进行设置，避免死锁</p><p>ReentrantLock可以获取各种锁的信息</p><p>ReentrantLock可以灵活地实现多路通知</p><p>机制：synchronized操作Mark Word，lock调用Unsafe类的park()方法</p><h2 id="Java内存模型JMM"><a href="#Java内存模型JMM" class="headerlink" title="Java内存模型JMM"></a>Java内存模型JMM</h2><p>Java内存模型（即Java Memory Model，简称JMM）本身是一种抽象的概念，并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实力字段，静态字段和构成数组对象的元素）的访问方式。<br><img src="https://img-blog.csdnimg.cn/20190713205217373.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDQ4NTc0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>线程间的通信都是通过主内存来完成，线程并不能直接修改主内存的数据，必须把数据取到工作内存当中进行操作，之后再写回主内存。</p><h2 id="JMM如何解决可见性问题"><a href="#JMM如何解决可见性问题" class="headerlink" title="JMM如何解决可见性问题"></a>JMM如何解决可见性问题</h2><h3 id="指令重排序需要满足的条件"><a href="#指令重排序需要满足的条件" class="headerlink" title="指令重排序需要满足的条件"></a>指令重排序需要满足的条件</h3><ul><li>在单线程环境下不能改变程序运行的结果</li><li>存在数据依赖关系的不允许重拍下</li></ul><p>无法通过happens-before原则推导出来的，才能进行指令的重排序</p><p>A操作的结果需要对B操作可见，则A与B存在happens-before关系</p><h3 id="happens-before的八大原则"><a href="#happens-before的八大原则" class="headerlink" title="happens-before的八大原则"></a>happens-before的八大原则</h3><ol><li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作；</li><li>锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作；</li><li>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；</li><li>传递规则：如果A操作先行发生于操作B，而B操作又先行发生于C操作，则A操作先行发生于C操作；</li><li>线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作；</li><li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；</li><li>线程终结规则：线程的所有操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlieve()的返回值手动检测到线程已经终止执行；</li><li>对象终结规则：一个对象的初始化完成先行发生于它的finalize()方法的开始；</li></ol><h2 id="volatile-：JVM提供的轻量级同步机制"><a href="#volatile-：JVM提供的轻量级同步机制" class="headerlink" title="volatile ：JVM提供的轻量级同步机制"></a>volatile ：JVM提供的轻量级同步机制</h2><ul><li>保证被volatile修饰的共享变量对所有线程总是可见的</li><li>禁止指令重排序优化</li></ul><h3 id="volatile变量为何立即可见？"><a href="#volatile变量为何立即可见？" class="headerlink" title="volatile变量为何立即可见？"></a>volatile变量为何立即可见？</h3><p>当写一个volatile变量时，JMM会把该线程对应的工作内存中的共享变量值刷新到主内存中；</p><p>当读取一个volatile变量时，JMM会把该线程对应的工作内存置为无效，迫使其从主内存中获取共享变量的最新值。</p><h3 id="volatile如何禁止重拍优化"><a href="#volatile如何禁止重拍优化" class="headerlink" title="volatile如何禁止重拍优化"></a>volatile如何禁止重拍优化</h3><p>内存屏障（memory barrier）</p><p>1.保证特点操作的执行顺序</p><p>2.保证某些变量的内存可见性</p><p>通过插入内存屏障指令禁止在内存屏障前后的指令执行重排序优化</p><p>强制刷出各种CPU的缓存数据，因此任何CPU上的线程都能读取到这些数据的最新版本。</p><h2 id="volatile和synchronized的区别"><a href="#volatile和synchronized的区别" class="headerlink" title="volatile和synchronized的区别"></a>volatile和synchronized的区别</h2><ol><li>vilatile本质是高手JVM当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取；synchronized则是锁定该变量，只有当前线程可以访问该变量，其他线程被阻塞住直到该线程完成变量操作位置</li><li>volatile仅能使用在变量级别；synchronized则可以使用在变量、方法和类级别</li><li>volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量修改的可见性和原子性</li><li>volatile不会造成线程的阻塞，synchronized可能会造成线程的阻塞</li><li>volatile标记的变量不会被编译器优化，synchronized标记的变量可以被编译器优化</li></ol><h2 id="CAS（compare-And-Swap）"><a href="#CAS（compare-And-Swap）" class="headerlink" title="CAS（compare And Swap）"></a>CAS（compare And Swap）</h2><p>一种高效实现线程安全性的方法</p><ul><li>支持原子更新操作，适用于计数器，序列发生器等场景</li><li>属于乐观锁机制，号称lock-free</li><li>CAS操作失败时，由开发者决定是继续尝试，还是执行别的操作</li></ul><h3 id="CAS多数情况下对开发者来说是透明的"><a href="#CAS多数情况下对开发者来说是透明的" class="headerlink" title="CAS多数情况下对开发者来说是透明的"></a>CAS多数情况下对开发者来说是透明的</h3><ul><li>J.U.C（java.util.concurrent）的atomic包提供了常用的原子性数据类型以及引用、数组等相关原子类型和更新操作工具，是很多线程安全程序的首选</li><li>Unsafe类虽然提供CAS服务，但因能够操作任意内存地址读写而有隐患</li><li>Java9以后，可以使用Variable Handle API来替代Unsafe</li></ul><h1 id="Java线程池"><a href="#Java线程池" class="headerlink" title="Java线程池"></a>Java线程池</h1><h2 id="Fork-Join框架"><a href="#Fork-Join框架" class="headerlink" title="Fork/Join框架"></a>Fork/Join框架</h2><p>把大任务分割成若干个小任务并行执行，最终汇总每个小任务结果后得到大任务的结果的框架</p><p><img src="https://img-blog.csdnimg.cn/2019071320524613.png" alt="在这里插入图片描述"></p><h2 id="为什么要使用线程池"><a href="#为什么要使用线程池" class="headerlink" title="为什么要使用线程池"></a>为什么要使用线程池</h2><p>降低资源消耗</p><p>提高线程的可管理性</p><h2 id="线程池的继承关系"><a href="#线程池的继承关系" class="headerlink" title="线程池的继承关系"></a>线程池的继承关系</h2><p><img src="https://img-blog.csdnimg.cn/20190713205256514.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDQ4NTc0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="ThreadPoolExecutor的构造函数"><a href="#ThreadPoolExecutor的构造函数" class="headerlink" title="ThreadPoolExecutor的构造函数"></a>ThreadPoolExecutor的构造函数</h2><p>corePoolSize：核心线程数量</p><p>maximumPoolSize：线程不够用时能够创建的最大线程数</p><p>workQueue：任务等待队列</p><p>keepAliveTime：抢占的顺序不一定，随机</p><p>threadFactory：创建新线程，Executors.defaultThreadFactory</p><p>handler：线程池的饱和策略</p><ul><li>AbortPilicy:直接抛出异常，这是默认策略</li><li>CallerRunsPolicy:用调用者所在的线程来执行任务</li><li>DiscardOlestPolicy:丢弃队列中靠最前的任务，并执行当前任务</li><li>DiscardPolicy:直接丢弃任务</li><li>实现RejectedExecutionHandler接口的自定义handler</li></ul><h2 id="新任务提交execute执行后的判断"><a href="#新任务提交execute执行后的判断" class="headerlink" title="新任务提交execute执行后的判断"></a>新任务提交execute执行后的判断</h2><ul><li>如果运行的线程少于corePoolSize，则创建新线程来处理任务，即使线程池中的其他线程是空闲的</li><li>如果线程池中的线程数量大于等于corePoolSize且小于maximumPoolSize，则只有当workQueue满时，才创建新的线程去处理任务；</li><li>如果设置的corePoolSize和maximumPoolSize相同，则创建的线程池的大小是固定的，这时如果有新任务提交，若workQueue未满，则将请求放入workQueue中， 等待有空闲的线程去从workQueue中取任务并处理</li><li>如果运行的线程数量大于等于maximumPoolSize，这时如果workQueue已经慢了，则通过handler所指定的策略来处理任务</li></ul><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><img src="https://img-blog.csdnimg.cn/20190713205344322.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDQ4NTc0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="线程池的状态"><a href="#线程池的状态" class="headerlink" title="线程池的状态"></a>线程池的状态</h2><ul><li>Running（运行）：能接受新提交的任务，并且也能处理阻塞队列中的任务</li><li>Shutdown（关闭）：不再接受新提交的任务，但可以处理存量任务</li><li>Stop（停止）：不再接受新提交的任务，也不处理存量任务</li><li>Tidying（整理）：所有的任务都已经终止</li><li>Terminated（终止）：terminated()方法执行完进入该状态</li></ul><p><img src="https://img-blog.csdnimg.cn/20190713205357817.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDQ4NTc0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="线程池的大小如何选定"><a href="#线程池的大小如何选定" class="headerlink" title="线程池的大小如何选定"></a>线程池的大小如何选定</h2><p>CPU密集型：线程数=按照核数或者核数+1设定</p><p>I/O密集型：线程数=CPU核数*（1+平均等待时间/平均工作时间）</p><h2 id="利用Executors创建不同的线程池满足不同场景的需求"><a href="#利用Executors创建不同的线程池满足不同场景的需求" class="headerlink" title="利用Executors创建不同的线程池满足不同场景的需求"></a>利用Executors创建不同的线程池满足不同场景的需求</h2><ol><li>newFixedThreadPool(int nThreads)指定工作线程数量的线程池</li><li>newCachedThreadPool()处理大量短时间工作任务的线程池<ol><li>试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程</li><li>如果线程闲置的时间超过阈值，则会被终止并移除缓存</li><li>系统长时间闲置的时候，不会消耗什么资源</li></ol></li><li>newSingleThreadExecutor()创建唯一的工作者线程来执行任务，如果线程异常结束，会有另一个线程取代它</li><li><p>newSingleThreadScheduledExecutor或new ScheduledThreadPool(int corePoolSize)定时或者周期性的工作调度，两者的区别在于单一工作线程还是多个线程<br>池满足不同场景的需求</p></li><li><p>newFixedThreadPool(int nThreads)指定工作线程数量的线程池</p></li><li>newCachedThreadPool()处理大量短时间工作任务的线程池<ol><li>试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程</li><li>如果线程闲置的时间超过阈值，则会被终止并移除缓存</li><li>系统长时间闲置的时候，不会消耗什么资源</li></ol></li><li>newSingleThreadExecutor()创建唯一的工作者线程来执行任务，如果线程异常结束，会有另一个线程取代它</li><li>newSingleThreadScheduledExecutor或new ScheduledThreadPool(int corePoolSize)定时或者周期性的工作调度，两者的区别在于单一工作线程还是多个线程</li><li>newWorkStealingPool()内部会构建ForkJoinPool，利用Working-stealing算法，并行的处理任务，不保证处理顺序<br><strong>ps：学习视频来自慕课网剑指Java面试-Offer直通车</strong>  </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;﻿# Java线程学习&lt;/p&gt;
&lt;h2 id=&quot;进程和线程的区别&quot;&gt;&lt;a href=&quot;#进程和线程的区别&quot; class=&quot;headerlink&quot; title=&quot;进程和线程的区别&quot;&gt;&lt;/a&gt;进程和线程的区别&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;进程是资源分配的最小单位，线程是CPU调度
      
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode328. 奇偶链表</title>
    <link href="http://yoursite.com/2019/07/11/leetcode328.%20%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2019/07/11/leetcode328. 奇偶链表/</id>
    <published>2019-07-11T07:56:30.846Z</published>
    <updated>2019-07-11T11:41:23.185Z</updated>
    
    <content type="html"><![CDATA[<p>﻿## 题目</p><blockquote><p>给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。</p><p>请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。</p><p><strong>示例 1:</strong></p><p><strong>输入:</strong> 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br><strong>输出:</strong> 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL<br><strong>示例 2:</strong></p><p><strong>输入:</strong> 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL<br><strong>输出:</strong> 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL<br><strong>说明:</strong></p><p>应当保持奇数节点和偶数节点的相对顺序。 链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/odd-even-linked-list" target="_blank" rel="noopener">https://leetcode-cn.com/problems/odd-even-linked-list</a></p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这题没啥好说的，直接给2个结点，奇数下标结点odd，偶数下标结点even，奇数下标的接奇数结点后边，偶数下标接偶数结点后边，最后2条链连接即可。<br>注意：处理一下最后的结点的问题，因为连接后的结点之后还是在原链表上，所以要把<strong>最后结点的next置为null</strong>；我使用的方法要注意区分链表长度是奇数个还是偶数个的情况。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode oddEvenList(ListNode head) &#123;</span><br><span class="line">        ListNode odd = new ListNode(0);</span><br><span class="line">        ListNode even = new ListNode(0);</span><br><span class="line">        ListNode p = odd, q = even;</span><br><span class="line">        while (head != null &amp;&amp; head.next != null) &#123;</span><br><span class="line">            p.next = head;</span><br><span class="line">            q.next = head.next;</span><br><span class="line">            p = p.next;</span><br><span class="line">            q = q.next;</span><br><span class="line">            head = head.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        q.next = null;</span><br><span class="line">        if (head != null) &#123;</span><br><span class="line">            p.next = head;</span><br><span class="line">            p.next.next = even.next;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            p.next = even.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return odd.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p><img src="https://img-blog.csdnimg.cn/20190711155626733.png" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;﻿## 题目&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。&lt;/p&gt;
&lt;p&gt;请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode324. 摆动排序 II</title>
    <link href="http://yoursite.com/2019/07/10/leetcode324.%20%E6%91%86%E5%8A%A8%E6%8E%92%E5%BA%8F%20II/"/>
    <id>http://yoursite.com/2019/07/10/leetcode324. 摆动排序 II/</id>
    <published>2019-07-10T03:41:04.546Z</published>
    <updated>2019-07-10T03:42:08.790Z</updated>
    
    <content type="html"><![CDATA[<p>﻿## 题目</p><blockquote><p>给定一个无序的数组 nums，将它重新排列成 nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]… 的顺序。</p><p><strong>示例 1:</strong></p><p><strong>输入:</strong> nums = [1, 5, 1, 1, 6, 4]<br><strong>输出:</strong> 一个可能的答案是 [1, 4, 1, 5, 1, 6]<br><strong>示例 2:</strong></p><p><strong>输入:</strong> nums = [1, 3, 2, 2, 3, 1]<br><strong>输出:</strong> 一个可能的答案是 [2, 3, 1, 3, 1, 2]</p><p>来源：力扣（LeetCode） 链接：<a href="https://leetcode-cn.com/problems/wiggle-sort-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/wiggle-sort-ii</a></p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>第一步：把数组复制到tmp并排序,这样小的和大的就分开来，小的在nums[0,index-1],大的是nums[index,length]<br>第二步：把小的最大的放在第i位，大的最大放在i+1位，因为题目一定有解，所以这样就可以避免冲突，即相等的情况。<br>第三步：处理数组长度为奇数的情况，即最后一位在这种情况要赋予tmp[0]。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void wiggleSort(int[] nums) &#123;</span><br><span class="line">        int[] tmp = Arrays.copyOf(nums, nums.length);</span><br><span class="line">        Arrays.sort(tmp);</span><br><span class="line">        int index = (nums.length+1)/2;</span><br><span class="line">        for (int i = 0, j = nums.length; i &lt; nums.length - 1; i=i+2) &#123;</span><br><span class="line">            nums[i] = tmp[--index];</span><br><span class="line">            nums[i+1] = tmp[--j];</span><br><span class="line">        &#125;</span><br><span class="line">        nums[nums.length - 1] = nums.length % 2 == 0 ? nums[nums.length - 1] : tmp[0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p><img src="https://img-blog.csdnimg.cn/20190710114047759.png" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;﻿## 题目&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个无序的数组 nums，将它重新排列成 nums[0] &amp;lt; nums[1] &amp;gt; nums[2] &amp;lt; nums[3]… 的顺序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode319. 灯泡开关</title>
    <link href="http://yoursite.com/2019/07/10/leetcode319.%20%E7%81%AF%E6%B3%A1%E5%BC%80%E5%85%B3/"/>
    <id>http://yoursite.com/2019/07/10/leetcode319. 灯泡开关/</id>
    <published>2019-07-10T02:38:13.914Z</published>
    <updated>2019-07-10T03:41:50.855Z</updated>
    
    <content type="html"><![CDATA[<p>﻿## 题目</p><blockquote><p>初始时有 n 个灯泡关闭。 第 1 轮，你打开所有的灯泡。 第 2 轮，每两个灯泡你关闭一次。 第 3<br>轮，每三个灯泡切换一次开关（如果关闭则开启，如果开启则关闭）。第 i 轮，每 i 个灯泡切换一次开关。 对于第 n<br>轮，你只切换最后一个灯泡的开关。 找出 n 轮后有多少个亮着的灯泡。</p><p><strong>示例:</strong></p><p><strong>输入:</strong> 3<br><strong>输出:</strong> 1<br><strong>解释:</strong>  初始时, 灯泡状态 [关闭, 关闭, 关闭]. 第一轮后, 灯泡状态 [开启, 开启, 开启]. 第二轮后, 灯泡状态 [开启, 关闭, 开启]. 第三轮后, 灯泡状态 [开启, 关闭, 关闭]. </p><p>你应该返回 1，因为只有一个灯泡还亮着。</p><p>来源：力扣（LeetCode） 链接：<a href="https://leetcode-cn.com/problems/bulb-switcher" target="_blank" rel="noopener">https://leetcode-cn.com/problems/bulb-switcher</a></p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>起始思路：<br>从后往前逆推，因为第i+1轮并不能影响到前面第i轮得到的结果，所以f(i+1) = (i+1) + f(i)，把单独的第i+1次拿出来处理，一直递归直到i为0。<br>之后的思路：<br>因为如果第i轮能影响到第k个灯泡的结果，则说明该轮是k的因数，由因为必存在另一个因数j，使得i*j==k，所以，要使得灯泡开，只有存在i==j这一种情况，所以问题就变得异常简单了。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public int bulbSwitch(int n) &#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            int tmp = i*i;</span><br><span class="line">            if (tmp &gt; n) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p><img src="https://img-blog.csdnimg.cn/20190710103804655.png" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;﻿## 题目&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;初始时有 n 个灯泡关闭。 第 1 轮，你打开所有的灯泡。 第 2 轮，每两个灯泡你关闭一次。 第 3&lt;br&gt;轮，每三个灯泡切换一次开关（如果关闭则开启，如果开启则关闭）。第 i 轮，每 i 个灯泡切换一次开关。 对于第
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
</feed>
