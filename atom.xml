<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>白哥的博客</title>
  
  <subtitle>白哥的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-05-07T03:20:56.515Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>白哥</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode106. 从中序与后序遍历序列构造二叉树</title>
    <link href="http://yoursite.com/2019/05/07/leetcode106.%20%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2019/05/07/leetcode106. 从中序与后序遍历序列构造二叉树/</id>
    <published>2019-05-07T03:20:40.826Z</published>
    <updated>2019-05-07T03:20:56.515Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>根据一棵树的中序遍历与后序遍历构造二叉树。</p><p><strong>注意:</strong> 你可以假设树中没有重复的元素。</p><p>例如，给出</p><p>中序遍历 inorder = [9,3,15,20,7] 后序遍历 postorder = [9,15,7,20,3] 返回如下的二叉树：<br><img src="https://img-blog.csdnimg.cn/20190507110245228.png" alt="在这里插入图片描述"></p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>跟使用前序遍历和中序遍历建树一样的思路，就是后序遍历的最后结点为根结点root而已。<br>这题我学习了leetcode上的一个小技巧，在遍历中序遍历的时候从尾遍历，提交结果就快了近10倍，可能是用例问题 <strong>？</strong></p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode buildTree(int[] inorder, int[] postorder) &#123;</span><br><span class="line">        int len = inorder.length;</span><br><span class="line">        if(len == 0) return null;</span><br><span class="line">        return helper(inorder,0,len, postorder,0,len);</span><br><span class="line">    &#125;</span><br><span class="line">    public TreeNode helper(int[] inorder, int inStart, int inEnd, int[] postorder, int postStart, int postEnd) &#123;</span><br><span class="line">        if(postEnd == 0) return null;</span><br><span class="line">        TreeNode root = null;</span><br><span class="line">        int rootVal = postorder[postEnd-1];</span><br><span class="line">        for(int i = inEnd-1; i &gt;= inStart; i --)&#123;</span><br><span class="line">            if(inorder[i] == rootVal)&#123;</span><br><span class="line">                root = new TreeNode(rootVal);</span><br><span class="line">                root.left = helper(inorder, inStart, i, postorder, postStart, postStart+i-inStart);</span><br><span class="line">                root.right = helper(inorder, i+1, inEnd, postorder, postStart+i-inStart, postEnd-1);</span><br><span class="line">                return root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 3 ms, 在Construct Binary Tree from Inorder and Postorder Traversal的Java提交中击败了97.97% 的用户<br>内存消耗 : 35.3 MB, 在Construct Binary Tree from Inorder and Postorder Traversal的Java提交中击败了99.05% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;根据一棵树的中序遍历与后序遍历构造二叉树。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt; 你可以假设树中
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode105. 从前序与中序遍历序列构造二叉树</title>
    <link href="http://yoursite.com/2019/05/07/leetcode105.%20%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2019/05/07/leetcode105. 从前序与中序遍历序列构造二叉树/</id>
    <published>2019-05-07T03:15:07.863Z</published>
    <updated>2019-05-07T03:15:31.091Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>根据一棵树的前序遍历与中序遍历构造二叉树。</p><p><strong>注意:</strong> 你可以假设树中没有重复的元素。</p><p>例如，给出</p><p>前序遍历 preorder = [3,9,20,15,7] 中序遍历 inorder = [9,3,15,20,7]<br>返回如下的二叉树：<br><img src="https://img-blog.csdnimg.cn/2019050710210233.png" alt="在这里插入图片描述"></p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>根据前序遍历和中序遍历的性质，<strong>前序遍历的第一个元素即根</strong>，中序遍历中根的<strong>左边的它的左子树的中序遍历，右边为右子树的中序遍历</strong>，前序遍历中根的后边是它的<strong>左子树+右子树的前序遍历</strong>。<br>所以这就可以使用递归来解决。<br>⒈把前序遍历preorder[preStart, preEnd]第一个元素preorder[preStart]作为根root；<br>⒉在中序遍历inorder[inStart, inEnd]中找到根的下标i；<br>⒊root.left的前序遍历即为preorder[preStart+1, preStart+1+i-inStart),中序遍历为inorder[inStart, i)；<br>（preStart+1即去掉根元素，+i-inStart是由中序遍历计算出左子树的长度。）<br>⒋root.right也同理，注意下标越界的处理即可ac。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode buildTree(int[] preorder, int[] inorder) &#123;</span><br><span class="line">        return helper(preorder, 0, preorder.length, inorder, 0, inorder.length);</span><br><span class="line">    &#125;</span><br><span class="line">    public TreeNode helper(int[] preprder, int preStart, int preEnd, int[] inorder, int inStart, int inEnd)&#123;</span><br><span class="line">        if(preStart &gt;= preprder.length)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        int rootVal = preprder[preStart];</span><br><span class="line">        TreeNode root = null;</span><br><span class="line">        for(int i = inStart; i &lt; inEnd; i ++) &#123;</span><br><span class="line">            if(inorder[i] == rootVal) &#123;</span><br><span class="line">                root = new TreeNode(rootVal);</span><br><span class="line">                root.left = helper(preprder, preStart+1, i+preStart+1-inStart, inorder, inStart, i);</span><br><span class="line">                root.right = helper(preprder, i+preStart+1-inStart, preEnd, inorder, i+1, inEnd);</span><br><span class="line">                return root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 33 ms, 在Construct Binary Tree from Preorder and Inorder Traversal的Java提交中击败了42.18% 的用户<br>内存消耗 : 38.7 MB, 在Construct Binary Tree from Preorder and Inorder Traversal的Java提交中击败了56.29% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;根据一棵树的前序遍历与中序遍历构造二叉树。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt; 你可以假设树中
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode96. 不同的二叉搜索树</title>
    <link href="http://yoursite.com/2019/05/06/leetcode96-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>http://yoursite.com/2019/05/06/leetcode96-不同的二叉搜索树/</id>
    <published>2019-05-06T08:12:28.000Z</published>
    <updated>2019-05-06T08:12:53.475Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？</p><p><strong>示例:</strong></p><p><strong>输入:</strong> 3<br><strong>输出:</strong> 5<br><strong>解释:</strong> 给定 n = 3, 一共有 5 种不同结构的二叉搜索树: <img src="https://img-blog.csdnimg.cn/20190505203055142.png" alt="在这里插入图片描述"></p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>因为1-n中不包含<strong>重复</strong>的结点，所以n个结点所能组成的二叉搜索树的固定个数的，例如（1,2）（2,3）所能组成的二叉搜索树都是2棵。所以这道题就可以直接用动态规划来进行求解了。<br>选定一个结点j，一棵n个结点的二叉搜索树就有<strong>j从0到n,  res += numTrees(j) * numTrees(n-j-1)</strong> 棵子树。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public int numTrees(int n) &#123;</span><br><span class="line">        int[] res = new int[n+1];</span><br><span class="line">        res[0] = 1; res[1] = 1;</span><br><span class="line">        for(int i = 2; i &lt;= n; i ++)&#123;</span><br><span class="line">            for(int j = 0; j &lt; i; j ++)&#123;</span><br><span class="line">                res[i] += res[j] * res[i-j-1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res[n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 1 ms, 在Unique Binary Search Trees的Java提交中击败了20.73% 的用户<br>内存消耗 : 33.2 MB, 在Unique Binary Search Trees的Java提交中击败了9.48% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/st
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode95. 不同的二叉搜索树 II</title>
    <link href="http://yoursite.com/2019/05/05/leetcode95-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-II/"/>
    <id>http://yoursite.com/2019/05/05/leetcode95-不同的二叉搜索树-II/</id>
    <published>2019-05-05T09:45:23.000Z</published>
    <updated>2019-05-05T09:45:50.613Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个整数 n，生成所有由 1 … n 为节点所组成的二叉搜索树。</p><p><strong>示例:</strong></p><p><strong>输入:</strong> 3<br> <strong>输出:</strong> [   [1,null,3,2],   [3,2,null,1],   [3,1,null,null,2],<br>[2,1,3],   [1,null,2,null,3] ]<br><strong>解释:</strong> 以上的输出对应以下 5 种不同结构的二叉搜索树：<br><img src="https://img-blog.csdnimg.cn/20190505172755456.png" alt="在这里插入图片描述"></p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>使用分治+递归的方法建树，<strong>[1,n]中取k(1&lt;=k&lt;=n)为根节点，则他的左子树必定为[1,k-1]，右子树为[k+1,n]</strong>，所以递归调用建树的方法，最后把他所有的左右子树整合在一起。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;TreeNode&gt; generateTrees(int n) &#123;</span><br><span class="line">        if(n == 0) return new ArrayList&lt;&gt;();</span><br><span class="line">        return generateTreeHelper(1,n);</span><br><span class="line">    &#125;</span><br><span class="line">    public List&lt;TreeNode&gt; generateTreeHelper(int i, int j)&#123;</span><br><span class="line">        List&lt;TreeNode&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">        //i&gt;j返回一个空的子树</span><br><span class="line">        if(i &gt; j) &#123;</span><br><span class="line">            res.add(null);</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        //i==j返回一个结点的子树</span><br><span class="line">        if(i == j)&#123;</span><br><span class="line">            res.add(new TreeNode(i));</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        //分治+递归建树</span><br><span class="line">        for(int k = i; k &lt;= j; k++)&#123;</span><br><span class="line">            List&lt;TreeNode&gt; left = generateTreeHelper(i,k-1);</span><br><span class="line">            List&lt;TreeNode&gt; right = generateTreeHelper(k+1,j);</span><br><span class="line">            for(TreeNode tmpR: right)&#123;</span><br><span class="line">                for(TreeNode tmpL: left)&#123;</span><br><span class="line">                    TreeNode tn = new TreeNode(k);</span><br><span class="line">                    tn.left = tmpL;</span><br><span class="line">                    tn.right = tmpR;</span><br><span class="line">                    res.add(tn);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 5 ms, 在Unique Binary Search Trees II的Java提交中击败了66.57% 的用户<br>内存消耗 : 38.8 MB, 在Unique Binary Search Trees II的Java提交中击败了68.05% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个整数 n，生成所有由 1 … n 为节点所组成的二叉搜索树。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/st
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode93. 复原IP地址</title>
    <link href="http://yoursite.com/2019/05/05/leetcode93-%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80/"/>
    <id>http://yoursite.com/2019/05/05/leetcode93-复原IP地址/</id>
    <published>2019-05-05T09:35:00.000Z</published>
    <updated>2019-05-05T09:45:10.830Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。</p><p><strong>示例:</strong></p><p><strong>输入:</strong> “25525511135”<br><strong>输出:</strong> [“255.255.11.135”, “255.255.111.35”]</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>记录每次放入的ip节，对字符串其进行回溯，即每次放入前1-3个数字，一直深度即可。<br>需要注意的是：<br>1.如果第1个数字是0的话可以直接剪枝（必须，不然会解答错误，因为ip节可能出现00这种情况）。<br>2.如果s的长度大于还未放入的ip节数*3可以剪枝。<br>3.放入4个之后即count==0，如果s不为空，则不用继续深度搜索。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//93. 复原IP地址</span><br><span class="line">    public List&lt;String&gt; restoreIpAddresses(String s) &#123;</span><br><span class="line">        ArrayList&lt;String&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">        dfs(res, 4, s, new StringBuilder(16));</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public void dfs(List&lt;String&gt; list, int count, String s, StringBuilder ip)&#123;</span><br><span class="line">//        大于最大的长度</span><br><span class="line">        if(s.length() &gt; 3 * count) return;</span><br><span class="line">        //ip中已经放入4个时</span><br><span class="line">        if(count == 0)&#123;</span><br><span class="line">            if(s.isEmpty()) &#123;</span><br><span class="line">                //去掉最后多的“”&quot;.&quot;</span><br><span class="line">                list.add(ip.substring(0,ip.length()-1));</span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 1; i &lt;= 3 &amp;&amp; i &lt;= s.length(); i ++)&#123;</span><br><span class="line">            String tmp  = s.substring(0,i);</span><br><span class="line">            if(Integer.parseInt(tmp) &lt;= 255)&#123;</span><br><span class="line">                int len = ip.length();</span><br><span class="line">                ip.append(tmp);</span><br><span class="line">                ip.append(&quot;.&quot;);</span><br><span class="line">                dfs(list, count-1, s.substring(i), ip);</span><br><span class="line">                ip.delete(len, ip.length());</span><br><span class="line">                if(tmp.equals(&quot;0&quot;))&#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 5 ms, 在Restore IP Addresses的Java提交中击败了73.10% 的用户<br>内存消耗 : 35.2 MB, 在Restore IP Addresses的Java提交中击败了77.65% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/st
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title> leetcode反转链表2</title>
    <link href="http://yoursite.com/2019/05/05/leetcode%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A82/"/>
    <id>http://yoursite.com/2019/05/05/leetcode反转链表2/</id>
    <published>2019-05-05T09:34:54.000Z</published>
    <updated>2019-05-05T09:44:58.776Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。</p><p><strong>说明:</strong> 1 ≤ m ≤ n ≤ 链表长度。</p><p><strong>示例:</strong></p><p><strong>输入:</strong> 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4<br><strong>输出:</strong> 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>把前面的结点直接接到新链表后面，最后一个结点为<strong>index</strong>，需要反转的结点依次<strong>插入到index后面</strong>，即 <strong>p.next = index.next;           index.next = p;</strong>最后把剩下的结点放到第一个插入index后面的结点即可。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public ListNode reverseBetween(ListNode head, int m, int n) &#123;</span><br><span class="line">        ListNode resList = new ListNode(0);</span><br><span class="line">        ListNode p = head;</span><br><span class="line">        ListNode index = resList;</span><br><span class="line">        //不用反转的结点</span><br><span class="line">        for(int i = 1; i &lt; m; i ++) &#123;</span><br><span class="line">            index.next = p;</span><br><span class="line">            p = p.next;</span><br><span class="line">            index = index.next;</span><br><span class="line">        &#125;</span><br><span class="line">        //需要反转的第一个结点</span><br><span class="line">        ListNode next = index.next;</span><br><span class="line">        next = p;</span><br><span class="line">        p = p.next;</span><br><span class="line">        index.next = next;</span><br><span class="line">        if(p == null) return resList.next;</span><br><span class="line">        ListNode q = p.next;</span><br><span class="line">        //其他结点放在第一个结点之后</span><br><span class="line">        for(int i = m; i &lt; n; i ++) &#123;</span><br><span class="line">            p.next = index.next;</span><br><span class="line">            index.next = p;</span><br><span class="line">            p = q;</span><br><span class="line">            if(q != null) q = q.next;</span><br><span class="line">        &#125;</span><br><span class="line">        //把剩下的结点接上去</span><br><span class="line">        next.next = p;</span><br><span class="line">        return resList.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 1 ms, 在Reverse Linked List II的Java提交中击败了94.17% 的用户<br>内存消耗 : 33.8 MB, 在Reverse Linked List II的Java提交中击败了92.92% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt; 
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode90. 子集 II</title>
    <link href="http://yoursite.com/2019/05/04/leetcode90-%E5%AD%90%E9%9B%86-II/"/>
    <id>http://yoursite.com/2019/05/04/leetcode90-子集-II/</id>
    <published>2019-05-04T13:33:52.000Z</published>
    <updated>2019-05-04T13:34:04.024Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</p><p><strong>说明：</strong> 解集不能包含重复的子集。</p><p><strong>示例:</strong></p><p><strong>输入:</strong> [1,2,2]<br><strong>输出:</strong><br>[<br>  [2],<br>  [1],<br>  [1,2,2],<br>  [2,2],<br>  [1,2],<br>  []<br>]</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>先排列数组，再遍历数组，每遍历到一个元素，就把链表的元素取出来复制，都加上这个元素再放回结果链表，重复的不放入结果链表即可。可以直接用链表的contains方法，也可以使用下标记录。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><pre><code>class Solution {    public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) {        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;();        Arrays.sort(nums);        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();        res.add(list);        int l, r, len = 0;        for(int i = 0; i &lt; nums.length; i ++) {            r = res.size();            //减去上一次新增的链表数量，即上一次增加的链表才需要取出来            if(i != 0 &amp;&amp; nums[i] == nums[i-1]) l = r-len;            //不是重复的则res的所有都需要拿出来            else l = 0;            //新增的链表数量            len = r - l;            for(int j = l; j &lt; r; j ++) {                list = new ArrayList&lt;&gt;(res.get(j));                list.add(nums[i]);                res.add(list);            }        }        return res;        }}</code></pre><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 3 ms, 在Subsets II的Java提交中击败了94.02% 的用户<br>内存消耗 : 38 MB, 在Subsets II的Java提交中击败了60.93% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt; 解
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>
leetcode82. 删除排序链表中的重复元素 II</title>
    <link href="http://yoursite.com/2019/04/30/leetcode82-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0-II/"/>
    <id>http://yoursite.com/2019/04/30/leetcode82-删除排序链表中的重复元素-II/</id>
    <published>2019-04-30T13:05:22.000Z</published>
    <updated>2019-04-30T13:05:49.598Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。</p><p><strong>示例 1:</strong></p><p><strong>输入:</strong> 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5<br><strong>输出:</strong> 1-&gt;2-&gt;5<br><strong>示例 2:</strong></p><p><strong>输入:</strong> 1-&gt;1-&gt;1-&gt;2-&gt;3<br><strong>输出:</strong> 2-&gt;3</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>使用双指针，判断结点是否重复，不重复则加入链表，重复则跳过即可。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode deleteDuplicates(ListNode head) &#123;</span><br><span class="line">        if(head == null) return null;</span><br><span class="line">if(head.next == null) return head;</span><br><span class="line">ListNode root = new ListNode(0);</span><br><span class="line">ListNode index = root;//合适的结点放入的位置</span><br><span class="line">ListNode p = head;</span><br><span class="line">ListNode q = head.next;</span><br><span class="line">while(q != null) &#123;</span><br><span class="line">while(q!=null &amp;&amp; p.val == q.val) &#123;</span><br><span class="line">q = q.next;</span><br><span class="line">&#125; </span><br><span class="line">            if(q == null)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">if(p.next == q) &#123;</span><br><span class="line">index.next = p;</span><br><span class="line">index = index.next;</span><br><span class="line">&#125;</span><br><span class="line">if(q.next == null) &#123;</span><br><span class="line">index.next = q;</span><br><span class="line">index = index.next;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">p = q;</span><br><span class="line">q = q.next;</span><br><span class="line">&#125;</span><br><span class="line">index.next = null;//去掉尾巴</span><br><span class="line">return root.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 2 ms, 在Remove Duplicates from Sorted List II的Java提交中击败了80.87% 的用户<br>内存消耗 : 36 MB, 在Remove Duplicates from Sorted List II的Java提交中击败了73.50% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。&lt;/p&gt;
&lt;p&gt;&lt;stron
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode81. 搜索旋转排序数组 II</title>
    <link href="http://yoursite.com/2019/04/29/leetcode81-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84-II/"/>
    <id>http://yoursite.com/2019/04/29/leetcode81-搜索旋转排序数组-II/</id>
    <published>2019-04-29T03:46:44.000Z</published>
    <updated>2019-04-29T03:46:51.400Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。</p><p>编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。</p><p><strong>示例 1:</strong></p><p><strong>输入:</strong> nums = [2,5,6,0,0,1,2], target = 0<br><strong>输出:</strong> true<br><strong>示例 2:</strong></p><p><strong>输入:</strong> nums = [2,5,6,0,0,1,2], target = 3<br><strong>输出:</strong> false</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>使用二分查找，先判断nums[mid]在旋转点的左侧或者右侧，即 <strong>nums[mid] &lt;= nums[high]</strong> 则在右侧；<strong>nums[mid] &gt;= nums[low]</strong> 则在左侧。<br>在右侧时，如果 <strong>target &gt; nums[mid] &amp;&amp; target &lt;= nums[high]</strong> target只可能在区间[mid+1, high]中；否则，target只能在区间[low,mid-1]中。<br>左侧也同理，如果 <strong>target &lt; nums[mid] &amp;&amp; target &gt;= nums[low]</strong> target只可能在区间[low, mid-1]中；否则只能在[mid+1, high]中。<br>最后的一点就是在判断nums[mid]在旋转点哪一侧时，如果有重复的数字，会导致判断错误，例如<strong>nums={1,1,3,1}，target = 3；</strong>  无法判断nums[mid]在哪一侧。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean search(int[] nums, int target) &#123;</span><br><span class="line">        if(nums == null || nums.length &lt; 1) return false;</span><br><span class="line">int low = 0, high = nums.length-1;</span><br><span class="line">while(low &lt;= high) &#123;</span><br><span class="line">//去掉重复的点，不然在下面的判断mid在旋转点左右侧会有影响 如&#123;1,1,3,1&#125;则无法判断mid的位置</span><br><span class="line">while(low+1 &lt;= high &amp;&amp; nums[low+1] == nums[low]) low++;</span><br><span class="line">while(high-1 &gt;= low &amp;&amp; nums[high-1] == nums[high]) high--;</span><br><span class="line">int mid = (low + high) &gt;&gt; 1;</span><br><span class="line">if(target == nums[mid])&#123;</span><br><span class="line">return true;</span><br><span class="line">&#125; else if(nums[mid] &lt;= nums[high]) &#123;</span><br><span class="line">//mid在旋转点右边</span><br><span class="line">if(target &gt; nums[mid] &amp;&amp; target &lt;= nums[high]) &#123;</span><br><span class="line">low = mid + 1;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">high = mid - 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125; else if(nums[mid] &gt;= nums[low]) &#123;</span><br><span class="line">//mid在旋转点左边</span><br><span class="line">if(target &lt; nums[mid] &amp;&amp; target &gt;= nums[low]) &#123;</span><br><span class="line">high = mid - 1;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">low = mid + 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 2 ms, 在Search in Rotated Sorted Array II的Java提交中击败了91.00% 的用户<br>内存消耗 : 37.4 MB, 在Search in Rotated Sorted Array II的Java提交中击败了52.09% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;假设按照升序排序的数组在预先未知的某个点上进行了旋转。&lt;/p&gt;
&lt;p&gt;( 例如，数组 [0,0,1,2,2,5,6
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode80. 删除排序数组中的重复项 II</title>
    <link href="http://yoursite.com/2019/04/29/leetcode80-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9-II/"/>
    <id>http://yoursite.com/2019/04/29/leetcode80-删除排序数组中的重复项-II/</id>
    <published>2019-04-29T03:46:08.000Z</published>
    <updated>2019-04-29T03:46:26.871Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p><p><strong>示例 1:</strong></p><p>给定 nums = [1,1,1,2,2,3],</p><p>函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。</p><p>你不需要考虑数组中超出新长度后面的元素。<br><strong>示例 2:</strong></p><p>给定 nums = [0,0,1,1,1,1,2,3,3],</p><p>函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。</p><p>你不需要考虑数组中超出新长度后面的元素。<br><strong>说明:</strong></p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><p>// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝 int len = removeDuplicates(nums);</p><p>// 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。 for (int<br>i = 0; i &lt; len; i++) {<br>    print(nums[i]); }</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>定义一个变量cnt计算当前数字的个数，用一个指针表示符合的元素的位置（最后返回的长度），另一个指针则遍历数组。<br>如果<strong>nums[i-1] == nums[i] &amp;&amp; cnt==2</strong>则直接说明这个元素已经放入2个了，直接继续；<br>如果<strong>nums[i-1] == nums[i] &amp;&amp; cnt == 1</strong>则把元素放到nums[index]，cnt+1；<br>其他的直接放到nums[index]并把cnt置1。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int removeDuplicates(int[] nums) &#123;</span><br><span class="line">        if(nums.length == 0) return 0;</span><br><span class="line">if(nums.length == 1) return 1;</span><br><span class="line">        int index = 1, cnt = 1;</span><br><span class="line">        for(int i = 1; i &lt; nums.length; i ++) &#123;</span><br><span class="line">        if(nums[i-1] == nums[i] &amp;&amp; cnt == 2) &#123;</span><br><span class="line">                ;</span><br><span class="line">        &#125; else if(nums[i-1] == nums[i] &amp;&amp; cnt == 1) &#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        nums[index++] = nums[i];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        cnt = 1;</span><br><span class="line">        nums[index++] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 2 ms, 在Remove Duplicates from Sorted Array II的Java提交中击败了98.91% 的用户<br>内存消耗 : 37.9 MB, 在Remove Duplicates from Sorted Array II的Java提交中击败了90.08% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。&lt;/p&gt;
&lt;p
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode79. 单词搜索</title>
    <link href="http://yoursite.com/2019/04/29/leetcode79-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/"/>
    <id>http://yoursite.com/2019/04/29/leetcode79-单词搜索/</id>
    <published>2019-04-29T03:45:59.000Z</published>
    <updated>2019-04-29T03:46:17.102Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个二维网格和一个单词，找出该单词是否存在于网格中。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。<br><strong>示例:</strong> board = [   [‘A’,’B’,’C’,’E’],   [‘S’,’F’,’C’,’S’],   [‘A’,’D’,’E’,’E’] ] 给定 word = “ABCCED”, 返回 true. 给定 word = “SEE”, 返回<br>true. 给定 word = “ABCB”, 返回 false.</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>使用深度搜索，遍历数组，如果是word的第一个字符，则进行深度查找，每次都判断上下左右是否符合下一个字符，注意好<strong>下标越界问题</strong>和<strong>判断这个位置是否走过</strong>就好了。不走重复位置的话，我是把board[i][j] 设为0。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean exist(char[][] board, String word) &#123;</span><br><span class="line">        for(int i = 0; i &lt; board.length; i ++) &#123;</span><br><span class="line">        for(int j = 0; j &lt; board[0].length; j++) &#123;</span><br><span class="line">        if(board[i][j] != word.charAt(0)) continue;</span><br><span class="line">        if(dfs(board, word, i, j, 0)) &#123;</span><br><span class="line">        return true;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">public boolean dfs(char[][] board,  String word, int i, int j, int index) &#123;</span><br><span class="line">if(word.length() == index) &#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">if(i &gt;= board.length || i &lt; 0 || j &lt; 0 || j &gt;= board[0].length || board[i][j] == &apos;0&apos;) &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">if(board[i][j] == word.charAt(index)) &#123;</span><br><span class="line">char tmp = board[i][j];</span><br><span class="line">board[i][j] = &apos;0&apos;;</span><br><span class="line">if(dfs(board, word, i+1, j, index+1) </span><br><span class="line">|| dfs(board, word, i-1, j, index+1)</span><br><span class="line">|| dfs(board, word, i, j+1, index+1)</span><br><span class="line">|| dfs(board, word, i, j-1, index+1)) &#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">board[i][j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 12 ms, 在Word Search的Java提交中击败了75.59% 的用户<br>内存消耗 : 43.6 MB, 在Word Search的Java提交中击败了83.83% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个二维网格和一个单词，找出该单词是否存在于网格中。&lt;/p&gt;
&lt;p&gt;单词必须按照字母顺序，通过相邻的单元格内的
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode77. 组合</title>
    <link href="http://yoursite.com/2019/04/29/leetcode77-%E7%BB%84%E5%90%88/"/>
    <id>http://yoursite.com/2019/04/29/leetcode77-组合/</id>
    <published>2019-04-29T01:51:36.000Z</published>
    <updated>2019-04-29T01:51:53.567Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。</p><p><strong>示例:</strong></p><p><strong>输入:</strong> n = 4, k = 2<br><strong>输出:</strong> [   [2,4],   [3,4],   [2,3],   [1,2],   [1,3],   [1,4], ]</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>类似之前做过的全排列，思路是一样的，只是不需要从头遍历，直接往下走，深度遍历即可。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123;</span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">dfs(res, new ArrayList&lt;Integer&gt;(), n, 1, k);</span><br><span class="line">return res;</span><br><span class="line">    &#125;</span><br><span class="line">public void dfs(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; list, int n, int index, int k) &#123;</span><br><span class="line">if(list.size() == k) &#123;</span><br><span class="line">res.add(new ArrayList&lt;&gt;(list));</span><br><span class="line">return ;</span><br><span class="line">&#125;</span><br><span class="line">for(int i = index; i &lt;= n - (k-list.size()) + 1; i ++) &#123;</span><br><span class="line">list.add(i);</span><br><span class="line">dfs(res, list, n, i+1, k);</span><br><span class="line">list.remove(list.size()-1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 6 ms, 在Combinations的Java提交中击败了85.95% 的用户<br>内存消耗 : 49.8 MB, 在Combinations的Java提交中击败了56.03% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode74. 搜索二维矩阵</title>
    <link href="http://yoursite.com/2019/04/29/leetcode74-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/"/>
    <id>http://yoursite.com/2019/04/29/leetcode74-搜索二维矩阵/</id>
    <published>2019-04-29T01:51:25.000Z</published>
    <updated>2019-04-29T01:51:44.912Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：</p><p>每行中的整数从左到右按升序排列。 每行的第一个整数大于前一行的最后一个整数。<br><strong>示例 1:</strong><br><strong>输入:</strong> matrix = [   [1,   3,  5,  7],   [10, 11, 16, 20],   [23, 30, 34, 50] ] target = 3<br><strong>输出:</strong> true<br><strong>示例 2:</strong></p><p><strong>输入:</strong> matrix = [   [1,   3,  5,  7],   [10, 11, 16, 20],   [23, 30, 34, 50] ] target = 13<br><strong>输出:</strong> false</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>题目跟之前做的剑指offer1一样，从最左的一列开始查找，使用二分查找，<strong>注意这里可以一直把行给缩短</strong>，在二分查找的时候，如果matrix[mid][j]&gt;target，则mid行及以下的都可以不用再找了。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean searchMatrix(int[][] matrix, int target) &#123;</span><br><span class="line">        if(matrix.length &lt;= 0) return false;</span><br><span class="line">        int lo = 0, hi = matrix.length-1;</span><br><span class="line">for(int j = 0; j &lt; matrix[0].length; j ++) &#123;</span><br><span class="line">//lo不能缩</span><br><span class="line">lo = 0;</span><br><span class="line">while(lo &lt;= hi) &#123;</span><br><span class="line">int mid = (lo + hi) &gt;&gt; 1;</span><br><span class="line">if(matrix[mid][j] == target) &#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">else if(matrix[mid][j] &gt; target) &#123;</span><br><span class="line">//hi以上行的都可以直接不用找了</span><br><span class="line">hi = mid-1;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">lo = mid + 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 1 ms, 在Search a 2D Matrix的Java提交中击败了99.56% 的用户<br>内存消耗 : 40.6 MB, 在Search a 2D Matrix的Java提交中击败了70.78% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：&lt;/p&gt;
&lt;p&gt;每行中的整数
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title> leetcode71.简化路径</title>
    <link href="http://yoursite.com/2019/04/29/leetcode71-%E7%AE%80%E5%8C%96%E8%B7%AF%E5%BE%84/"/>
    <id>http://yoursite.com/2019/04/29/leetcode71-简化路径/</id>
    <published>2019-04-29T01:50:21.000Z</published>
    <updated>2019-04-29T01:51:13.161Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>以 Unix 风格给出一个文件的绝对路径，你需要简化它。或者换句话说，将其转换为规范路径。 在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..）表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。更多信息请参阅：<a href="https://blog.csdn.net/u011327334/article/details/50355600" target="_blank" rel="noopener">Linux / Unix中的绝对路径 vs 相对路径</a><br>请注意，返回的规范路径必须始终以斜杠 / 开头，并且两个目录名之间必须只有一个斜杠 /。最后一个目录名（如果存在）不能以 / 结尾。此外，规范路径必须是表示绝对路径的最短字符串。<br><strong>示例 1：</strong><br><strong>输入：</strong>“/home/“<br><strong>输出：</strong>“/home”<br><strong>解释：</strong> 注意，最后一个目录名后面没有斜杠。</p><p><strong>示例 2：</strong><br><strong>输入：</strong>“/../“<br><strong>输出：</strong>“/“<br><strong>解释：</strong> 从根目录向上一级是不可行的，因为根是你可以到达的最高级。</p><p><strong>示例 3：</strong><br><strong>输入：</strong>“/home//foo/“<br><strong>输出：</strong>“/home/foo”<br><strong>解释：</strong> 在规范路径中，多个连续斜杠需要用一个斜杠替换。</p><p><strong>示例 4：</strong><br><strong>输入：</strong>“/a/./b/../../c/“<br><strong>输出：</strong>“/c”</p><p><strong>示例 5：</strong><br><strong>输入：</strong>“/a/../../b/../c//.//“<br><strong>输出：</strong>“/c”</p><p><strong>示例 6：</strong><br><strong>输入：</strong>“/a//b////c/d//././/..”<br><strong>输出：</strong>“/a/b/c”</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>使用双下标，判断/与/之间的字符串，如果是<strong>一点</strong>则直接跳过，如果是 <strong>两点</strong> 则判断栈是否为空，如果不为空则pop栈顶元素，其他元素则push到栈中，最后把栈的元素转化为题目所求即可。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String simplifyPath(String path) &#123;</span><br><span class="line">        if(path.isEmpty() || path.length() == 1) return &quot;/&quot;;</span><br><span class="line">        Stack&lt;String&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        StringBuilder res = new StringBuilder();</span><br><span class="line">        int pre = 0, next = 1;</span><br><span class="line">        while(next &lt; path.length()) &#123;</span><br><span class="line">        while(next &lt; path.length() &amp;&amp; path.charAt(next) != &apos;/&apos;) &#123;</span><br><span class="line">        next++;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果/与/之间不为空</span><br><span class="line">        if(next - 1 != pre) &#123;</span><br><span class="line">        String tmp = path.substring(pre+1, next);</span><br><span class="line">        if(tmp.equals(&quot;..&quot;)) &#123;</span><br><span class="line">        if(!stack.isEmpty()) stack.pop();</span><br><span class="line">        &#125; else if(tmp.equals(&quot;.&quot;)) &#123;</span><br><span class="line">        ;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">        stack.push(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = next++;</span><br><span class="line">        &#125;</span><br><span class="line">        while(!stack.isEmpty()) &#123;</span><br><span class="line">        res.insert(0, &quot;/&quot; + stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        return res.length() == 0 ? &quot;/&quot; : res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 9 ms, 在Simplify Path的Java提交中击败了97.92% 的用户<br>内存消耗 : 35.2 MB, 在Simplify Path的Java提交中击败了100.00% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;以 Unix 风格给出一个文件的绝对路径，你需要简化它。或者换句话说，将其转换为规范路径。 在 Unix 风格的文
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode64. 最小路径和</title>
    <link href="http://yoursite.com/2019/04/29/leetcode64-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
    <id>http://yoursite.com/2019/04/29/leetcode64-最小路径和/</id>
    <published>2019-04-29T01:49:37.000Z</published>
    <updated>2019-04-29T01:50:50.969Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。<br><strong>说明：</strong> 每次只能向下或者向右移动一步。<br><strong>示例:<br>输入:</strong><br>[<br>  [1,3,1],<br>  [1,5,1],<br>  [4,2,1]<br>]<br><strong>输出:</strong> 7<br><strong>解释:</strong> 因为路径 1→3→1→1→1 的总和最小。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>使用动态规划，除了最后一列和最后一行，其他格子只能往下和往右走，所以很容易得出dp(i,j) = grid(i,j)+min(dp(i+1, j), dp(i, j+1))，这题是动态规划中的简单题目。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int minPathSum(int[][] grid) &#123;</span><br><span class="line">        int n = grid.length, m = grid[0].length;</span><br><span class="line">if(n == 0 || m == 0) return 0;</span><br><span class="line">        int[][] dp = new int[n][m];</span><br><span class="line">        dp[n-1][m-1] = grid[n-1][m-1];//终点</span><br><span class="line">        //最后一行只能往右走</span><br><span class="line">        for(int j = m-2; j &gt;= 0; j--) dp[n-1][j] = grid[n-1][j] + dp[n-1][j+1];</span><br><span class="line">        //最后一列只能往下走</span><br><span class="line">        for(int i = n-2; i &gt;= 0; i--) dp[i][m-1] = grid[i][m-1] + dp[i+1][m-1];</span><br><span class="line">        for(int i = n-2; i &gt;= 0; i--) &#123;</span><br><span class="line">        for(int j = m-2; j &gt;= 0; j --) &#123;</span><br><span class="line">        dp[i][j] = grid[i][j] + Math.min(dp[i+1][j], dp[i][j+1]);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[0][0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 3 ms, 在Minimum Path Sum的Java提交中击败了98.59% 的用户<br>内存消耗 : 36.1 MB, 在Minimum Path Sum的Java提交中击败了99.82% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。&lt;br&gt;&lt;strong&gt;说明：&lt;/s
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode62. 不同路径</title>
    <link href="http://yoursite.com/2019/04/27/leetcode62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/"/>
    <id>http://yoursite.com/2019/04/27/leetcode62-不同路径/</id>
    <published>2019-04-27T09:52:35.000Z</published>
    <updated>2019-04-27T09:52:52.248Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>问总共有多少条不同的路径？</p><p><img src="https://img-blog.csdnimg.cn/20190427174432112.png" alt="在这里插入图片描述"></p><p>例如，上图是一个7 x 3 的网格。有多少可能的路径？</p><p><strong>说明：</strong> m 和 n 的值均不超过 100。</p><p><strong>示例 1:</strong></p><p><strong>输入:</strong> m = 3, n = 2<br><strong>输出:</strong> 3<br><strong>解释:</strong> 从左上角开始，总共有 3 条路径可以到达右下角。</p><ol><li>向右 -&gt; 向右 -&gt; 向下</li><li>向右 -&gt; 向下 -&gt; 向右</li><li>向下 -&gt; 向右 -&gt; 向右 </li></ol><p><strong>示例 2:</strong></p><p><strong>输入:</strong> m = 7, n = 3<br><strong>输出:</strong> 28</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>利用动态规划，在最后一行和最后一列的时候，只有唯一的一条路可以走，便是一直往右和往下走；<br>每次只能向下和向右走，所以有dp(i,j) = dp(i+1,j) + dp(i, j+1);<br>但是由于<strong>最后一行和最后一列每次只能向一个方向走</strong>，所以把二维数组转化为一维数组，有dp(i) = dp(i) + dp(i+1);</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><pre><code>class Solution {    public int uniquePaths(int m, int n) {        if(m &lt;= 0 || n &lt;= 0) return 0;        int[] dp = new int[m];        for(int i = m-1; i &gt;= 0; i --) dp[i] = 1;//最后一行        for(int i = n-2; i &gt;= 0; i--) {            for(int j = m-2; j &gt;= 0; j--) {                dp[j] = dp[j]+dp[j+1];            }        }        return dp[0];    }}</code></pre><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 1 ms, 在Unique Paths的Java提交中击败了86.27% 的用户<br>内存消耗 : 32.5 MB, 在Unique Paths的Java提交中击败了40.83% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。&lt;/p&gt;
&lt;p&gt;机器人每次
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode63. 不同路径 II</title>
    <link href="http://yoursite.com/2019/04/27/leetcode63-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84-II/"/>
    <id>http://yoursite.com/2019/04/27/leetcode63-不同路径-II/</id>
    <published>2019-04-27T09:52:09.000Z</published>
    <updated>2019-04-27T09:52:41.328Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><p><img src="https://img-blog.csdnimg.cn/20190427174458878.png" alt="在这里插入图片描述"></p><p>网格中的障碍物和空位置分别用 1 和 0 来表示。</p><p><strong>说明：</strong> m 和 n 的值均不超过 100。</p><p><strong>示例 1: 输入:</strong> [   [0,0,0],   [0,1,0],   [0,0,0] ]<br><strong>输出:</strong> 2<br><strong>解释:</strong> 3x3 网格的正中间有一个障碍物。 从左上角到右下角一共有 2 条不同的路径：</p><ol><li>向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</li><li>向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</li></ol></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>使用动态规划，解题思路跟不同路径1一模一样，如果当前位置是障碍物的话，则这条路是不通的，也就是到达终点的路径数为0。在初始化最后一列和最后一行时也要判断一下。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123;</span><br><span class="line">        int n = obstacleGrid.length, m = obstacleGrid[0].length;</span><br><span class="line">int[][] dp = new int[n+1][m+1];</span><br><span class="line">for(int i = m-1; i &gt;= 0; i --) &#123;</span><br><span class="line">if(obstacleGrid[n-1][i] == 1) break;</span><br><span class="line">dp[n-1][i] = 1;</span><br><span class="line">&#125;</span><br><span class="line">for(int i = n-1; i &gt;= 0; i --) &#123;</span><br><span class="line">if(obstacleGrid[i][m-1] == 1) break;</span><br><span class="line">dp[i][m-1] = 1;</span><br><span class="line">&#125;</span><br><span class="line">for(int i = n-2; i &gt;= 0; i --) &#123;</span><br><span class="line">for(int j = m-2; j &gt;= 0; j --) &#123;</span><br><span class="line">if(obstacleGrid[i][j] == 1) &#123;</span><br><span class="line">dp[i][j] = 0;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">dp[i][j] = dp[i+1][j] + dp[i][j+1];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return dp[0][0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 1 ms, 在Unique Paths II的Java提交中击败了97.67% 的用户<br>内存消耗 : 35 MB, 在Unique Paths II的Java提交中击败了52.23% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。&lt;/p&gt;
&lt;p&gt;机器人每次
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode61. 旋转链表</title>
    <link href="http://yoursite.com/2019/04/27/leetcode61-%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2019/04/27/leetcode61-旋转链表/</id>
    <published>2019-04-27T09:51:49.000Z</published>
    <updated>2019-04-27T09:52:18.346Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。<br><strong>示例 1:</strong><br><strong>输入:</strong> 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2<br><strong>输出:</strong> 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL<br><strong>解释:</strong> 向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL 向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL<br><strong>示例 2:</strong></p><p><strong>输入:</strong> 0-&gt;1-&gt;2-&gt;NULL, k = 4<br><strong>输出:</strong> 2-&gt;0-&gt;1-&gt;NULL<br><strong>解释:</strong> 向右旋转 1 步: 2-&gt;0-&gt;1-&gt;NULL 向右旋转 2 步: 1-&gt;2-&gt;0-&gt;NULL 向右旋转 3 步: 0-&gt;1-&gt;2-&gt;NULL 向右旋转 4 步: 2-&gt;0-&gt;1-&gt;NULL</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>在k&lt;链表长度len的前提下，使用2个指针p、q，<strong>q指向链表的最后一个结点，p指向q第前k个结点</strong>，然后q.next -&gt;head,p的前一个结点指向null，即可旋转完成。<br>k大于链表长度的话，则直接求k%len即可。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode rotateRight(ListNode head, int k) &#123;</span><br><span class="line">        if(k == 0) return head;</span><br><span class="line">        if(head == null || head.next == null) return head;</span><br><span class="line">ListNode p = head, q = head, ppre = head;</span><br><span class="line">for(int i = 2; i &lt;= k; i ++) &#123;</span><br><span class="line">q= q.next;</span><br><span class="line">//说明k大于或等于链表的长度</span><br><span class="line">if(q.next==null) &#123;</span><br><span class="line">return rotateRight(head, k%i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//q走到最后一个节点</span><br><span class="line">while(q.next != null) &#123;</span><br><span class="line">if(p != head) </span><br><span class="line">ppre = ppre.next;</span><br><span class="line">p = p.next;</span><br><span class="line">q = q.next;</span><br><span class="line">&#125;</span><br><span class="line">//旋转链表</span><br><span class="line">q.next = head;</span><br><span class="line">ppre.next = null;</span><br><span class="line">return p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 2 ms, 在Rotate List的Java提交中击败了98.90% 的用户<br>内存消耗 : 36.1 MB, 在Rotate List的Java提交中击败了82.48% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。&lt;br&gt;&lt;strong&gt;示例 1:
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode59. 螺旋矩阵 II</title>
    <link href="http://yoursite.com/2019/04/27/leetcode59-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5-II/"/>
    <id>http://yoursite.com/2019/04/27/leetcode59-螺旋矩阵-II/</id>
    <published>2019-04-27T09:51:39.000Z</published>
    <updated>2019-04-27T09:51:55.924Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个正整数 n，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。<br><strong>示例:<br>输入:</strong> 3<br><strong>输出:</strong> [<br>[ 1, 2, 3 ],<br>[ 8, 9, 4 ],<br>[ 7, 6, 5 ] ]</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>从矩形的外部一直往内部螺旋的加入数字就好了，类似于之前的螺旋矩阵1的解法，但是这次是正方形，所以这题的下标更好理解。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[][] generateMatrix(int n) &#123;</span><br><span class="line">        int[][] res = new int[n][n];</span><br><span class="line">        //代表数组长度res.length-1;</span><br><span class="line">        n--;</span><br><span class="line">        int num = 1;</span><br><span class="line">        for(int i = 0; i &lt;= n/2; i ++) &#123;</span><br><span class="line">        //剩下最后一个的情况</span><br><span class="line">        if(n == 2*i) &#123;</span><br><span class="line">        res[i][i] = num;</span><br><span class="line">        break;</span><br><span class="line">        &#125;;</span><br><span class="line">        num = addRow(res, i, i, n-i, num);</span><br><span class="line">        num = addCol(res, n-i, i, n-i, num);</span><br><span class="line">        num = addRow(res, n-i, n-i, i, num);</span><br><span class="line">        num = addCol(res, i, n-i,i, num);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">//返回值保存num的值</span><br><span class="line">public int addRow(int[][] res,int row, int colStart, int colEnd, int num) &#123;</span><br><span class="line">if(colStart == colEnd) &#123;</span><br><span class="line">res[row][colStart] = num++;</span><br><span class="line">return num;</span><br><span class="line">&#125;</span><br><span class="line">for(int i = colStart;i &lt; colEnd; i ++) res[row][i] = num++;</span><br><span class="line">for(int i = colStart;i &gt; colEnd; i --) res[row][i] = num++;</span><br><span class="line">return num;</span><br><span class="line">&#125;</span><br><span class="line">public int addCol(int[][] res,int col, int rowStart, int rowEnd, int num) &#123;</span><br><span class="line">if(rowStart == rowEnd) &#123;</span><br><span class="line">res[col][rowEnd] = num++;</span><br><span class="line">return num;</span><br><span class="line">&#125;</span><br><span class="line">for(int i = rowStart;i &lt; rowEnd; i ++) res[i][col] = num++;</span><br><span class="line">for(int i = rowStart;i &gt; rowEnd; i --) res[i][col] = num++;</span><br><span class="line">return num;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 0 ms, 在Spiral Matrix II的Java提交中击败了100.00% 的用户<br>内存消耗 : 33.7 MB, 在Spiral Matrix II的Java提交中击败了84.01% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个正整数 n，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。&lt;br&gt;&lt;str
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode54. 螺旋矩阵</title>
    <link href="http://yoursite.com/2019/04/26/leetcode54-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/"/>
    <id>http://yoursite.com/2019/04/26/leetcode54-螺旋矩阵/</id>
    <published>2019-04-26T08:55:16.000Z</published>
    <updated>2019-04-26T08:55:32.992Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。<br><strong>示例 1:<br>输入:</strong><br>[<br> [ 1, 2, 3 ],<br> [ 4, 5, 6 ],<br> [ 7, 8, 9 ]<br>]<br><strong>输出:</strong> [1,2,3,6,9,8,7,4,5]<br><strong>示例 2:<br>输入:</strong><br>[<br>  [1, 2, 3, 4],<br>  [5, 6, 7, 8],<br>  [9,10,11,12]<br>]<br><strong>输出:</strong> [1,2,3,4,8,12,11,10,9,5,6,7]</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>先把上面一整行加入链表，然后判断是否有竖的列，如若有，则加入；如果最后一列不是当前列，再加入最后一列；再加入左边的一列，加入步骤可以理解为如图的加入顺序，剩下的是对于坐标的理解和处理了。<br><img src="https://img-blog.csdnimg.cn/20190426150525729.png" alt="在这里插入图片描述"></p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123;</span><br><span class="line">if(matrix == null || matrix.length == 0) return new ArrayList&lt;&gt;();</span><br><span class="line">List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">int rlen = matrix.length-1, clen = matrix[0].length-1;</span><br><span class="line">for(int i = 0; i &lt; (rlen+2)/2 &amp;&amp; i&lt;(clen+2)/2; i++) &#123;</span><br><span class="line">addRow(res, matrix, i, i, clen-i);</span><br><span class="line">if(i+1 &lt;= rlen-i-1)</span><br><span class="line">addCol(res, matrix, clen-i,i+1, rlen-i-1);</span><br><span class="line">if(rlen-i &gt; i)</span><br><span class="line">addRow(res, matrix, rlen-i, clen-i, i);</span><br><span class="line">if(i+1 &lt;= rlen-i-1 &amp;&amp; i &lt; clen-i)</span><br><span class="line">addCol(res, matrix, i, rlen-i-1, i+1);</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">    &#125;</span><br><span class="line">public void addRow(List&lt;Integer&gt; list, int[][] matrix,int row, int colStart, int colEnd) &#123;</span><br><span class="line">//根据行下标，开始下标结束下标加入行</span><br><span class="line">if(colStart == colEnd) &#123;</span><br><span class="line">list.add(matrix[row][colStart]);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">//如果colStart&lt;colEnd则从前往后加入</span><br><span class="line">for(int j = colStart; j &lt;= colEnd; j ++) &#123;</span><br><span class="line">list.add(matrix[row][j]);</span><br><span class="line">&#125;</span><br><span class="line">//如果colStart》colEnd则从后往前加入</span><br><span class="line">for(int j = colStart; j &gt;= colEnd; j --) &#123;</span><br><span class="line">list.add(matrix[row][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public void addCol(List&lt;Integer&gt; list, int[][] matrix,int col, int rowStart, int rowEnd) &#123;</span><br><span class="line">if(rowStart == rowEnd) &#123;</span><br><span class="line">list.add(matrix[rowStart][col]);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">for(int i = rowStart; i &lt;= rowEnd; i ++) &#123;</span><br><span class="line">list.add(matrix[i][col]);</span><br><span class="line">&#125;</span><br><span class="line">for(int i = rowStart; i &gt;= rowEnd; i --) &#123;</span><br><span class="line">list.add(matrix[i][col]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 1 ms, 在Spiral Matrix的Java提交中击败了96.80% 的用户<br>内存消耗 : 32.1 MB, 在Spiral Matrix的Java提交中击败了100.00% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。&lt;br&gt;&lt;strong&gt;示例 1:&lt;
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
</feed>
