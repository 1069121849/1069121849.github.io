<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>白哥的博客</title>
  
  <subtitle>白哥的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-27T09:52:52.248Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>白哥</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode62. 不同路径</title>
    <link href="http://yoursite.com/2019/04/27/leetcode62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/"/>
    <id>http://yoursite.com/2019/04/27/leetcode62-不同路径/</id>
    <published>2019-04-27T09:52:35.000Z</published>
    <updated>2019-04-27T09:52:52.248Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>问总共有多少条不同的路径？</p><p><img src="https://img-blog.csdnimg.cn/20190427174432112.png" alt="在这里插入图片描述"></p><p>例如，上图是一个7 x 3 的网格。有多少可能的路径？</p><p><strong>说明：</strong> m 和 n 的值均不超过 100。</p><p><strong>示例 1:</strong></p><p><strong>输入:</strong> m = 3, n = 2<br><strong>输出:</strong> 3<br><strong>解释:</strong> 从左上角开始，总共有 3 条路径可以到达右下角。</p><ol><li>向右 -&gt; 向右 -&gt; 向下</li><li>向右 -&gt; 向下 -&gt; 向右</li><li>向下 -&gt; 向右 -&gt; 向右 </li></ol><p><strong>示例 2:</strong></p><p><strong>输入:</strong> m = 7, n = 3<br><strong>输出:</strong> 28</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>利用动态规划，在最后一行和最后一列的时候，只有唯一的一条路可以走，便是一直往右和往下走；<br>每次只能向下和向右走，所以有dp(i,j) = dp(i+1,j) + dp(i, j+1);<br>但是由于<strong>最后一行和最后一列每次只能向一个方向走</strong>，所以把二维数组转化为一维数组，有dp(i) = dp(i) + dp(i+1);</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><pre><code>class Solution {    public int uniquePaths(int m, int n) {        if(m &lt;= 0 || n &lt;= 0) return 0;        int[] dp = new int[m];        for(int i = m-1; i &gt;= 0; i --) dp[i] = 1;//最后一行        for(int i = n-2; i &gt;= 0; i--) {            for(int j = m-2; j &gt;= 0; j--) {                dp[j] = dp[j]+dp[j+1];            }        }        return dp[0];    }}</code></pre><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 1 ms, 在Unique Paths的Java提交中击败了86.27% 的用户<br>内存消耗 : 32.5 MB, 在Unique Paths的Java提交中击败了40.83% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。&lt;/p&gt;
&lt;p&gt;机器人每次
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode63. 不同路径 II</title>
    <link href="http://yoursite.com/2019/04/27/leetcode63-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84-II/"/>
    <id>http://yoursite.com/2019/04/27/leetcode63-不同路径-II/</id>
    <published>2019-04-27T09:52:09.000Z</published>
    <updated>2019-04-27T09:52:41.328Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><p><img src="https://img-blog.csdnimg.cn/20190427174458878.png" alt="在这里插入图片描述"></p><p>网格中的障碍物和空位置分别用 1 和 0 来表示。</p><p><strong>说明：</strong> m 和 n 的值均不超过 100。</p><p><strong>示例 1: 输入:</strong> [   [0,0,0],   [0,1,0],   [0,0,0] ]<br><strong>输出:</strong> 2<br><strong>解释:</strong> 3x3 网格的正中间有一个障碍物。 从左上角到右下角一共有 2 条不同的路径：</p><ol><li>向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</li><li>向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</li></ol></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>使用动态规划，解题思路跟不同路径1一模一样，如果当前位置是障碍物的话，则这条路是不通的，也就是到达终点的路径数为0。在初始化最后一列和最后一行时也要判断一下。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123;</span><br><span class="line">        int n = obstacleGrid.length, m = obstacleGrid[0].length;</span><br><span class="line">int[][] dp = new int[n+1][m+1];</span><br><span class="line">for(int i = m-1; i &gt;= 0; i --) &#123;</span><br><span class="line">if(obstacleGrid[n-1][i] == 1) break;</span><br><span class="line">dp[n-1][i] = 1;</span><br><span class="line">&#125;</span><br><span class="line">for(int i = n-1; i &gt;= 0; i --) &#123;</span><br><span class="line">if(obstacleGrid[i][m-1] == 1) break;</span><br><span class="line">dp[i][m-1] = 1;</span><br><span class="line">&#125;</span><br><span class="line">for(int i = n-2; i &gt;= 0; i --) &#123;</span><br><span class="line">for(int j = m-2; j &gt;= 0; j --) &#123;</span><br><span class="line">if(obstacleGrid[i][j] == 1) &#123;</span><br><span class="line">dp[i][j] = 0;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">dp[i][j] = dp[i+1][j] + dp[i][j+1];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return dp[0][0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 1 ms, 在Unique Paths II的Java提交中击败了97.67% 的用户<br>内存消耗 : 35 MB, 在Unique Paths II的Java提交中击败了52.23% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。&lt;/p&gt;
&lt;p&gt;机器人每次
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode61. 旋转链表</title>
    <link href="http://yoursite.com/2019/04/27/leetcode61-%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2019/04/27/leetcode61-旋转链表/</id>
    <published>2019-04-27T09:51:49.000Z</published>
    <updated>2019-04-27T09:52:18.346Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。<br><strong>示例 1:</strong><br><strong>输入:</strong> 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2<br><strong>输出:</strong> 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL<br><strong>解释:</strong> 向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL 向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL<br><strong>示例 2:</strong></p><p><strong>输入:</strong> 0-&gt;1-&gt;2-&gt;NULL, k = 4<br><strong>输出:</strong> 2-&gt;0-&gt;1-&gt;NULL<br><strong>解释:</strong> 向右旋转 1 步: 2-&gt;0-&gt;1-&gt;NULL 向右旋转 2 步: 1-&gt;2-&gt;0-&gt;NULL 向右旋转 3 步: 0-&gt;1-&gt;2-&gt;NULL 向右旋转 4 步: 2-&gt;0-&gt;1-&gt;NULL</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>在k&lt;链表长度len的前提下，使用2个指针p、q，<strong>q指向链表的最后一个结点，p指向q第前k个结点</strong>，然后q.next -&gt;head,p的前一个结点指向null，即可旋转完成。<br>k大于链表长度的话，则直接求k%len即可。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode rotateRight(ListNode head, int k) &#123;</span><br><span class="line">        if(k == 0) return head;</span><br><span class="line">        if(head == null || head.next == null) return head;</span><br><span class="line">ListNode p = head, q = head, ppre = head;</span><br><span class="line">for(int i = 2; i &lt;= k; i ++) &#123;</span><br><span class="line">q= q.next;</span><br><span class="line">//说明k大于或等于链表的长度</span><br><span class="line">if(q.next==null) &#123;</span><br><span class="line">return rotateRight(head, k%i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//q走到最后一个节点</span><br><span class="line">while(q.next != null) &#123;</span><br><span class="line">if(p != head) </span><br><span class="line">ppre = ppre.next;</span><br><span class="line">p = p.next;</span><br><span class="line">q = q.next;</span><br><span class="line">&#125;</span><br><span class="line">//旋转链表</span><br><span class="line">q.next = head;</span><br><span class="line">ppre.next = null;</span><br><span class="line">return p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 2 ms, 在Rotate List的Java提交中击败了98.90% 的用户<br>内存消耗 : 36.1 MB, 在Rotate List的Java提交中击败了82.48% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。&lt;br&gt;&lt;strong&gt;示例 1:
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode59. 螺旋矩阵 II</title>
    <link href="http://yoursite.com/2019/04/27/leetcode59-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5-II/"/>
    <id>http://yoursite.com/2019/04/27/leetcode59-螺旋矩阵-II/</id>
    <published>2019-04-27T09:51:39.000Z</published>
    <updated>2019-04-27T09:51:55.924Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个正整数 n，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。<br><strong>示例:<br>输入:</strong> 3<br><strong>输出:</strong> [<br>[ 1, 2, 3 ],<br>[ 8, 9, 4 ],<br>[ 7, 6, 5 ] ]</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>从矩形的外部一直往内部螺旋的加入数字就好了，类似于之前的螺旋矩阵1的解法，但是这次是正方形，所以这题的下标更好理解。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[][] generateMatrix(int n) &#123;</span><br><span class="line">        int[][] res = new int[n][n];</span><br><span class="line">        //代表数组长度res.length-1;</span><br><span class="line">        n--;</span><br><span class="line">        int num = 1;</span><br><span class="line">        for(int i = 0; i &lt;= n/2; i ++) &#123;</span><br><span class="line">        //剩下最后一个的情况</span><br><span class="line">        if(n == 2*i) &#123;</span><br><span class="line">        res[i][i] = num;</span><br><span class="line">        break;</span><br><span class="line">        &#125;;</span><br><span class="line">        num = addRow(res, i, i, n-i, num);</span><br><span class="line">        num = addCol(res, n-i, i, n-i, num);</span><br><span class="line">        num = addRow(res, n-i, n-i, i, num);</span><br><span class="line">        num = addCol(res, i, n-i,i, num);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">//返回值保存num的值</span><br><span class="line">public int addRow(int[][] res,int row, int colStart, int colEnd, int num) &#123;</span><br><span class="line">if(colStart == colEnd) &#123;</span><br><span class="line">res[row][colStart] = num++;</span><br><span class="line">return num;</span><br><span class="line">&#125;</span><br><span class="line">for(int i = colStart;i &lt; colEnd; i ++) res[row][i] = num++;</span><br><span class="line">for(int i = colStart;i &gt; colEnd; i --) res[row][i] = num++;</span><br><span class="line">return num;</span><br><span class="line">&#125;</span><br><span class="line">public int addCol(int[][] res,int col, int rowStart, int rowEnd, int num) &#123;</span><br><span class="line">if(rowStart == rowEnd) &#123;</span><br><span class="line">res[col][rowEnd] = num++;</span><br><span class="line">return num;</span><br><span class="line">&#125;</span><br><span class="line">for(int i = rowStart;i &lt; rowEnd; i ++) res[i][col] = num++;</span><br><span class="line">for(int i = rowStart;i &gt; rowEnd; i --) res[i][col] = num++;</span><br><span class="line">return num;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 0 ms, 在Spiral Matrix II的Java提交中击败了100.00% 的用户<br>内存消耗 : 33.7 MB, 在Spiral Matrix II的Java提交中击败了84.01% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个正整数 n，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。&lt;br&gt;&lt;str
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode54. 螺旋矩阵</title>
    <link href="http://yoursite.com/2019/04/26/leetcode54-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/"/>
    <id>http://yoursite.com/2019/04/26/leetcode54-螺旋矩阵/</id>
    <published>2019-04-26T08:55:16.000Z</published>
    <updated>2019-04-26T08:55:32.992Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。<br><strong>示例 1:<br>输入:</strong><br>[<br> [ 1, 2, 3 ],<br> [ 4, 5, 6 ],<br> [ 7, 8, 9 ]<br>]<br><strong>输出:</strong> [1,2,3,6,9,8,7,4,5]<br><strong>示例 2:<br>输入:</strong><br>[<br>  [1, 2, 3, 4],<br>  [5, 6, 7, 8],<br>  [9,10,11,12]<br>]<br><strong>输出:</strong> [1,2,3,4,8,12,11,10,9,5,6,7]</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>先把上面一整行加入链表，然后判断是否有竖的列，如若有，则加入；如果最后一列不是当前列，再加入最后一列；再加入左边的一列，加入步骤可以理解为如图的加入顺序，剩下的是对于坐标的理解和处理了。<br><img src="https://img-blog.csdnimg.cn/20190426150525729.png" alt="在这里插入图片描述"></p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123;</span><br><span class="line">if(matrix == null || matrix.length == 0) return new ArrayList&lt;&gt;();</span><br><span class="line">List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">int rlen = matrix.length-1, clen = matrix[0].length-1;</span><br><span class="line">for(int i = 0; i &lt; (rlen+2)/2 &amp;&amp; i&lt;(clen+2)/2; i++) &#123;</span><br><span class="line">addRow(res, matrix, i, i, clen-i);</span><br><span class="line">if(i+1 &lt;= rlen-i-1)</span><br><span class="line">addCol(res, matrix, clen-i,i+1, rlen-i-1);</span><br><span class="line">if(rlen-i &gt; i)</span><br><span class="line">addRow(res, matrix, rlen-i, clen-i, i);</span><br><span class="line">if(i+1 &lt;= rlen-i-1 &amp;&amp; i &lt; clen-i)</span><br><span class="line">addCol(res, matrix, i, rlen-i-1, i+1);</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">    &#125;</span><br><span class="line">public void addRow(List&lt;Integer&gt; list, int[][] matrix,int row, int colStart, int colEnd) &#123;</span><br><span class="line">//根据行下标，开始下标结束下标加入行</span><br><span class="line">if(colStart == colEnd) &#123;</span><br><span class="line">list.add(matrix[row][colStart]);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">//如果colStart&lt;colEnd则从前往后加入</span><br><span class="line">for(int j = colStart; j &lt;= colEnd; j ++) &#123;</span><br><span class="line">list.add(matrix[row][j]);</span><br><span class="line">&#125;</span><br><span class="line">//如果colStart》colEnd则从后往前加入</span><br><span class="line">for(int j = colStart; j &gt;= colEnd; j --) &#123;</span><br><span class="line">list.add(matrix[row][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public void addCol(List&lt;Integer&gt; list, int[][] matrix,int col, int rowStart, int rowEnd) &#123;</span><br><span class="line">if(rowStart == rowEnd) &#123;</span><br><span class="line">list.add(matrix[rowStart][col]);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">for(int i = rowStart; i &lt;= rowEnd; i ++) &#123;</span><br><span class="line">list.add(matrix[i][col]);</span><br><span class="line">&#125;</span><br><span class="line">for(int i = rowStart; i &gt;= rowEnd; i --) &#123;</span><br><span class="line">list.add(matrix[i][col]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 1 ms, 在Spiral Matrix的Java提交中击败了96.80% 的用户<br>内存消耗 : 32.1 MB, 在Spiral Matrix的Java提交中击败了100.00% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。&lt;br&gt;&lt;strong&gt;示例 1:&lt;
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode55. 跳跃游戏</title>
    <link href="http://yoursite.com/2019/04/26/leetcode55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/"/>
    <id>http://yoursite.com/2019/04/26/leetcode55-跳跃游戏/</id>
    <published>2019-04-26T08:55:04.000Z</published>
    <updated>2019-04-26T08:55:21.871Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个非负整数数组，你最初位于数组的第一个位置。<br>数组中的每个元素代表你在该位置可以跳跃的最大长度。<br>判断你是否能够到达最后一个位置。<br><strong>示例 1:<br>输入:</strong> [2,3,1,1,4]<br><strong>输出:</strong> true<br><strong>解释:</strong> 从位置 0 到 1 跳 1 步, 然后跳 3 步到达最后一个位置。<br><strong>示例 2:</strong><br><strong>输入:</strong> [3,2,1,0,4]<br><strong>输出:</strong> false<br><strong>解释:</strong> 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>从数组后面遍历，如果nums[i]&gt;=len-i的话，则说明这一块可以达到终点，继续查找下一个能达到nums[len]的位置，如果最后len==0则说明起点能达到终点。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public boolean canJump(int[] nums) &#123;</span><br><span class="line">int len = nums.length-1;</span><br><span class="line">if(len &lt; 1) return true;</span><br><span class="line">        for(int i = len-1; i &gt;= 0; i --) &#123;</span><br><span class="line">        if(nums[i] &gt;= len - i) </span><br><span class="line">        len = i;</span><br><span class="line">        if(len == 0) return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 2 ms, 在Jump Game的Java提交中击败了99.14% 的用户<br>内存消耗 : 36.4 MB, 在Jump Game的Java提交中击败了99.59% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个非负整数数组，你最初位于数组的第一个位置。&lt;br&gt;数组中的每个元素代表你在该位置可以跳跃的最大长度。&lt;br&gt;判断你是否能够到达最后一
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode50. Pow(x, n)</title>
    <link href="http://yoursite.com/2019/04/25/leetcode50-Pow-x-n/"/>
    <id>http://yoursite.com/2019/04/25/leetcode50-Pow-x-n/</id>
    <published>2019-04-25T15:35:25.000Z</published>
    <updated>2019-04-25T15:35:43.781Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>实现 pow(x, n) ，即计算 x 的 n 次幂函数。</p><p><strong>示例 1:</strong></p><p><strong>输入:</strong> 2.00000, 10 <strong>输出:</strong> 1024.00000<br><strong>示例 2:</strong></p><p><strong>输入:</strong> 2.10000, 3 <strong>输出:</strong> 9.26100<br> <strong>示例 3:</strong></p><p><strong>输入:</strong> 2.00000, -2 <strong>输出:</strong> 0.25000<br><strong>解释:</strong> 2-2 = 1/22 = 1/4 = 0.25<br> <strong>说明:</strong></p><p>-100.0 &lt; x &lt; 100.0 n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>当n&gt;1的时候，如果n是偶数，x的n次方 == x²的n/2次方；n是奇数，则有 x的n次方 == x²的n/2次方*x；当n &lt; 0时，则可以转化为1/x的-n次方来处理。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public double myPow(double x, int n) &#123;</span><br><span class="line">        if(x == 1) return 1;</span><br><span class="line">        if(x == 0) return 0;</span><br><span class="line">if(n == 0) return 1;</span><br><span class="line">if(n == 1) return x;</span><br><span class="line">if(n &gt; 0) &#123;</span><br><span class="line">if(n%2 == 0)</span><br><span class="line">return myPow(x*x, n/2);</span><br><span class="line">return myPow(x*x, n/2)*x;</span><br><span class="line">&#125;</span><br><span class="line">        if(n == Integer.MIN_VALUE)</span><br><span class="line">return Math.abs(myPow(1/x, Integer.MAX_VALUE));</span><br><span class="line">return myPow(1/x, -n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 2 ms, 在Pow(x, n)的Java提交中击败了99.79% 的用户<br>内存消耗 : 32.7 MB, 在Pow(x, n)的Java提交中击败了92.74% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;实现 pow(x, n) ，即计算 x 的 n 次幂函数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/stron
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer 8.跳台阶</title>
    <link href="http://yoursite.com/2019/04/25/%E5%89%91%E6%8C%87offer-8-%E8%B7%B3%E5%8F%B0%E9%98%B6/"/>
    <id>http://yoursite.com/2019/04/25/剑指offer-8-跳台阶/</id>
    <published>2019-04-25T15:35:00.000Z</published>
    <updated>2019-04-25T15:35:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>不管多少台阶都可以分解成为2个子问题的和，即target-1和target-2的和；<br>使用递归、动态等方法都可以解答。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int JumpFloor(int target) &#123;</span><br><span class="line">        if(target == 1) return 1;</span><br><span class="line">if(target == 2) return 2;</span><br><span class="line">//直接使用递归；</span><br><span class="line">//return JumpFloor(target-1) + JumpFloor(target-2);</span><br><span class="line">//动态规划</span><br><span class="line">int[] dp = new int[target+1];</span><br><span class="line">        dp[1] = 1; dp[2] = 2;</span><br><span class="line">for(int i = 3; i &lt; dp.length; i ++) &#123;</span><br><span class="line">dp[i] = dp[i-1] + dp[i-2];</span><br><span class="line">&#125;</span><br><span class="line">return dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。&lt;/p&gt;
&lt;h2 id
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer6.旋转数组的最小数字</title>
    <link href="http://yoursite.com/2019/04/25/%E5%89%91%E6%8C%87offer6-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/"/>
    <id>http://yoursite.com/2019/04/25/剑指offer6-旋转数组的最小数字/</id>
    <published>2019-04-25T15:34:40.000Z</published>
    <updated>2019-04-25T15:35:10.807Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>最简单是思路是直接遍历，不做解释。<br>我的思路是使用二分查找，找到最小的元素。<br>若low指针向右移到最大的即不再移动，high指针一直往左移动直到最小的元素。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int minNumberInRotateArray(int [] array) &#123;</span><br><span class="line">        if(array == null || array.length &lt; 1) return 0;</span><br><span class="line">    int low = 0, high = array.length-1;</span><br><span class="line">    while(low != high-1) &#123;</span><br><span class="line">    int mid = (low + high) &gt;&gt; 1;</span><br><span class="line">    if(array[mid] &lt;= array[high]) &#123;</span><br><span class="line">    high = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(array[mid] &gt;= array[low]) &#123;</span><br><span class="line">    low = mid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    return array[high];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode49. 字母异位词分组</title>
    <link href="http://yoursite.com/2019/04/25/leetcode49-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/"/>
    <id>http://yoursite.com/2019/04/25/leetcode49-字母异位词分组/</id>
    <published>2019-04-25T08:15:14.000Z</published>
    <updated>2019-04-25T08:15:35.500Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</p><p><strong>示例:</strong></p><p><strong>输入:</strong> [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”],<br><strong>输出:</strong> [[“ate”,”eat”,”tea”],   [“nat”,”tan”],   [“bat”] ]<br><strong>说明：</strong><br>所有输入均为小写字母。 不考虑答案输出的顺序。</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>学了一下别人使用26个素数对应26个字母，用素数的乘积来表示单词具有一样的字母，然后使用一个map保存对应字母所在res中的list的下标，每个单词都查找map中有没有，有的话则取出res中的list然后添加，没有则创建一个list然后用map记录下标，再放进res。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">        //26个素数对应26个字母</span><br><span class="line">int[] primeNumber = &#123;2,3,5,7,11,13,17,19,23,29,</span><br><span class="line">31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101&#125;;</span><br><span class="line">//保存字母所在res中的下标</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">        int index = 0;//list计数器</span><br><span class="line">        for(int i = 0; i &lt; strs.length; i++) &#123;</span><br><span class="line">        int ch = 1;</span><br><span class="line">        for(int j = 0; j &lt; strs[i].length(); j++) </span><br><span class="line">        //获取该单词所有字母对应素数的乘积</span><br><span class="line">        ch *= primeNumber[strs[i].charAt(j)-&apos;a&apos;];</span><br><span class="line">        if(map.containsKey(ch)) </span><br><span class="line">        //如果已经存在字母异位词，则加入其中</span><br><span class="line">        res.get(map.get(ch)).add(strs[i]);</span><br><span class="line">        else &#123;</span><br><span class="line">        //没有则创建一个list加入其中并在map记录下其下标</span><br><span class="line">        map.put(ch, index++);</span><br><span class="line">        List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        list.add(strs[i]);</span><br><span class="line">        res.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 22 ms, 在Group Anagrams的Java提交中击败了85.81% 的用户<br>内存消耗 : 52.1 MB, 在Group Anagrams的Java提交中击败了73.13% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。&lt;/p&gt;
&lt;p&gt;&lt;stron
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode47. 全排列 II</title>
    <link href="http://yoursite.com/2019/04/25/leetcode47-%E5%85%A8%E6%8E%92%E5%88%97-II/"/>
    <id>http://yoursite.com/2019/04/25/leetcode47-全排列-II/</id>
    <published>2019-04-25T08:14:27.000Z</published>
    <updated>2019-04-25T08:14:56.721Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个可包含重复数字的序列，返回所有不重复的全排列。</p><p><strong>示例:</strong></p><p><strong>输入:</strong> [1,1,2]<br><strong>输出:</strong> [   [1,1,2],   [1,2,1],   [2,1,1] ]</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p><strong>定义变量：</strong> 结果链表res；临时链表list（用来存储全排列）；布尔数组states。<br>首先<strong>排序nums数组</strong>，然后使用一个states布尔数组记录nums数组的元素是否已经加入list，由于先前已经对nums数组排序，所以如果nums[i] == nums[i-]那么nums[i-1]没被加入list，则nums[i]也不可以加入list，因为在排列中可以看出重复的数字只有一个，而且由最前面的那么决定是否加入list。<br>使用回溯算法进行解答。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123;</span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">Arrays.sort(nums);</span><br><span class="line">boolean[] states = new boolean[nums.length];</span><br><span class="line">helper(res, list, nums, states);</span><br><span class="line">return res;</span><br><span class="line">    &#125;</span><br><span class="line">public void helper(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; list, int[] nums, boolean[] states) &#123;</span><br><span class="line">if(list.size() == nums.length) &#123;</span><br><span class="line">res.add(new ArrayList&lt;&gt;(list));</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">for(int i = 0;i&lt;nums.length; i ++) &#123;</span><br><span class="line">//已经加入list， 重复而且前一个重复的没有放进list</span><br><span class="line">if(states[i] || (i &gt; 0 &amp;&amp; nums[i] == nums[i-1] &amp;&amp; !states[i-1])) continue;</span><br><span class="line">states[i] = true;</span><br><span class="line">list.add(nums[i]);</span><br><span class="line">helper(res, list, nums, states);</span><br><span class="line">list.remove(list.size()-1);</span><br><span class="line">states[i] = false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 5 ms, 在Permutations II的Java提交中击败了90.61% 的用户<br>内存消耗 : 42.6 MB, 在Permutations II的Java提交中击败了77.99% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个可包含重复数字的序列，返回所有不重复的全排列。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode48. 旋转图像</title>
    <link href="http://yoursite.com/2019/04/25/leetcode48-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/"/>
    <id>http://yoursite.com/2019/04/25/leetcode48-旋转图像/</id>
    <published>2019-04-25T08:14:04.000Z</published>
    <updated>2019-04-25T08:14:41.292Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个 n × n 的二维矩阵表示一个图像。</p><p>将图像顺时针旋转 90 度。</p><p><strong>说明：</strong><br>你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。</p><p><strong>示例 1:</strong></p><p>给定 matrix =<br>[[1,2,3],<br>[4,5,6],<br>[7,8,9] ],</p><p>原地旋转输入矩阵，使其变为:<br>[[7,4,1],<br>[8,5,2],<br>[9,6,3] ]<br><strong>示例 2:</strong></p><p>给定 matrix = [<br>[ 5, 1, 9,11],<br> [ 2, 4, 8,10],<br>[13, 3, 6, 7],<br>[15,14,12,16] ], </p><p>原地旋转输入矩阵，使其变为: [<br> [15,13, 2, 5],<br> [14, 3, 4, 1],<br> [12, 6, 8, 9],<br>[16, 7,10,11] ]</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>很直观的一道题目，我的解法是从外向内，然后一直转换。<br>把matrix[i][j]放到matrix[j][len-i]中，旋转一周，然后一直向内执行即可。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">   public void rotate(int[][] matrix) &#123;</span><br><span class="line">        int len = matrix.length-1;</span><br><span class="line">        for(int i = 0; i &lt;= len/2; i ++) &#123;</span><br><span class="line">        for(int j = i; j &lt; len-i; j ++) &#123;</span><br><span class="line">        int cnt = 0;</span><br><span class="line">        int i1 = j, j1 = len-i;</span><br><span class="line">        int temp1 = matrix[i][j];</span><br><span class="line">        do &#123;</span><br><span class="line">        int temp2 = matrix[i1][j1];//保存替换掉的值</span><br><span class="line">            matrix[i1][j1] = temp1;</span><br><span class="line">            int t = i1;</span><br><span class="line">            i1 = j1;//更新下一个替换的下标</span><br><span class="line">            j1 = len-t;</span><br><span class="line">            temp1 = temp2;//替换掉的值 是 下一个替换上去的值</span><br><span class="line">        &#125;while(cnt++ &lt; 3) ;//旋转一周，替换4次。</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 1 ms, 在Rotate Image的Java提交中击败了90.11% 的用户<br>内存消耗 : 35.7 MB, 在Rotate Image的Java提交中击败了68.85% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个 n × n 的二维矩阵表示一个图像。&lt;/p&gt;
&lt;p&gt;将图像顺时针旋转 90 度。&lt;/p&gt;
&lt;p&gt;&lt;str
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer1-5</title>
    <link href="http://yoursite.com/2019/04/23/%E5%89%91%E6%8C%87offer1-5/"/>
    <id>http://yoursite.com/2019/04/23/剑指offer1-5/</id>
    <published>2019-04-23T13:41:44.000Z</published>
    <updated>2019-04-23T13:42:13.189Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 剑指offer1.二维数组中的查找</span><br><span class="line"></span><br><span class="line">    public boolean Find(int target, int [][] array) &#123;</span><br><span class="line">        int lo = 0, hi = array.length-1;</span><br><span class="line">        for(int j = 0; j &lt; array[0].length; j ++) &#123;</span><br><span class="line">        lo = 0;</span><br><span class="line">        while(lo &lt;= hi) &#123;</span><br><span class="line">        int mid = (lo + hi) &gt;&gt; 1;</span><br><span class="line">        if(array[mid][j] == target) &#123;</span><br><span class="line">        return true;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(array[mid][j] &gt; target) &#123;</span><br><span class="line">        hi = mid-1;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">        lo = mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//剑指offer2.替换空格</span><br><span class="line">public String replaceSpace(StringBuffer str) &#123;</span><br><span class="line">    return str.toString().replaceAll(&quot; &quot;, &quot;%20&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">//剑指offer3.从尾到头打印链表</span><br><span class="line">public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">        while(listNode != null) &#123;</span><br><span class="line">        res.add(0, listNode.val);</span><br><span class="line">        listNode = listNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//剑指offer4.重建二叉树</span><br><span class="line">public TreeNode reConstructBinaryTree(int [] pre,int [] in) &#123;</span><br><span class="line">if(pre.length == 0 || in.length == 0) return null;</span><br><span class="line">TreeNode root = reConstructBinaryTree(pre, 0, pre.length, in, 0, in.length);</span><br><span class="line">return root;</span><br><span class="line">    &#125;</span><br><span class="line">public TreeNode reConstructBinaryTree(int [] pre,int startPre, int endPre,</span><br><span class="line">int [] in, int startIn, int endIn) &#123;</span><br><span class="line">if(startPre &gt;= endPre || startIn &gt;= endIn) </span><br><span class="line">return null;</span><br><span class="line">TreeNode root = new TreeNode(pre[startPre]);</span><br><span class="line">for(int i = startIn; i &lt; endIn; i ++) &#123;</span><br><span class="line">if(in[i] == pre[startPre]) &#123;</span><br><span class="line">root.left = reConstructBinaryTree(pre, startPre+1, startPre+i-startIn+1, in, startIn, i);</span><br><span class="line">root.right = reConstructBinaryTree(pre, startPre+i-startIn+1, endPre, in, i+1, endIn);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return root;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">//剑指offer5.用两个栈实现队列</span><br><span class="line">Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;();</span><br><span class="line">    public void push(int node) &#123;</span><br><span class="line">        while(!stack1.isEmpty()) &#123;</span><br><span class="line">        stack2.push(stack1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        stack2.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int pop() &#123;</span><br><span class="line">    while(!stack2.isEmpty()) &#123;</span><br><span class="line">    stack1.push(stack2.pop());</span><br><span class="line">    &#125;</span><br><span class="line">    return stack1.pop();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode46. 全排列</title>
    <link href="http://yoursite.com/2019/04/23/leetcode46-%E5%85%A8%E6%8E%92%E5%88%97/"/>
    <id>http://yoursite.com/2019/04/23/leetcode46-全排列/</id>
    <published>2019-04-23T07:05:01.000Z</published>
    <updated>2019-04-23T07:05:23.614Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个没有重复数字的序列，返回其所有可能的全排列。</p><p><strong>示例:</strong></p><p><strong>输入:</strong> [1,2,3]<br> <strong>输出:</strong> [   [1,2,3],   [1,3,2],   [2,1,3],   [2,3,1],   [3,1,2],   [3,2,1] ]</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>使用回溯算法进行深度遍历；向list添加<strong>任意</strong>nums[i]，如果nums[i]已经存在，则不放入，直到list的长度等于nums的长度，则res加入list。.</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        backstack(res, nums, list, 0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">public void backstack(List&lt;List&lt;Integer&gt;&gt; res, int[]nums, List&lt;Integer&gt; list, int len) &#123;</span><br><span class="line">if(len == nums.length) &#123;</span><br><span class="line">res.add(new ArrayList&lt;&gt;(list));</span><br><span class="line">return ;</span><br><span class="line">&#125;</span><br><span class="line">for(int i = 0; i &lt; nums.length; i ++) &#123;</span><br><span class="line">if(!list.contains(nums[i])) &#123;</span><br><span class="line">list.add(nums[i]);</span><br><span class="line">backstack(res, nums, list, len +1);</span><br><span class="line">list.remove(list.size()-1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 5 ms, 在Permutations的Java提交中击败了68.78% 的用户<br>内存消耗 : 38 MB, 在Permutations的Java提交中击败了81.41% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个没有重复数字的序列，返回其所有可能的全排列。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode43. 字符串相乘</title>
    <link href="http://yoursite.com/2019/04/23/leetcode43-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/"/>
    <id>http://yoursite.com/2019/04/23/leetcode43-字符串相乘/</id>
    <published>2019-04-23T07:04:24.000Z</published>
    <updated>2019-04-23T07:05:10.631Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。</p><p>示例 1:</p><p>输入: num1 = “2”, num2 = “3” 输出: “6” 示例 2:</p><p>输入: num1 = “123”, num2 = “456” 输出: “56088” 说明：</p><p>num1 和 num2 的长度小于110。 num1 和 num2 只包含数字 0-9。 num1 和 num2 均不以零开头，除非是数字<br>0 本身。 不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>把每个位数相乘的结果储存在一个数组里面，然后遍历这个数组，注意进位的处理就可以了，跟自己笔算乘法运算一样。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String multiply(String num1, String num2) &#123;</span><br><span class="line">        if(num1.equals(&quot;0&quot;) || num2.equals(&quot;0&quot;)) return &quot;0&quot;;</span><br><span class="line">//根据题目定的数组长度</span><br><span class="line">        int[] res = new int[220];</span><br><span class="line">        int index = num1.length() + num2.length()-2;</span><br><span class="line">        for(int i = num1.length()-1; i &gt;= 0; i --) &#123;</span><br><span class="line">        for(int j = num2.length()-1; j &gt;= 0; j --) &#123;</span><br><span class="line">        int mult = (num1.charAt(i)-&apos;0&apos;) * (num2.charAt(j)-&apos;0&apos;);</span><br><span class="line">        //计算2个数的相应位数</span><br><span class="line">        int t = index-i-j;</span><br><span class="line">        //存入结果，进位先不处理</span><br><span class="line">        res[t] += mult;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder str = new StringBuilder(110);</span><br><span class="line">        int resIndex;</span><br><span class="line">        //多余0去掉</span><br><span class="line">        for(resIndex = index+1; resIndex &gt;= 0 ; resIndex--) </span><br><span class="line">        if(res[resIndex] != 0) break;</span><br><span class="line">        int carry = 0;</span><br><span class="line">        for(int i = 0; i &lt;= resIndex; i ++) &#123;</span><br><span class="line">        res[i] += carry;</span><br><span class="line">        carry = 0;</span><br><span class="line">        if(res[i] &gt;= 10) &#123;</span><br><span class="line">        carry = res[i]/10;</span><br><span class="line">        res[i] %= 10;</span><br><span class="line">        &#125;</span><br><span class="line">        str.append(res[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        if(carry != 0) str.append(carry);</span><br><span class="line">        //最后结果翻转字符串即可</span><br><span class="line">        return str.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 11 ms, 在Multiply Strings的Java提交中击败了91.17% 的用户<br>内存消耗 : 38.1 MB, 在Multiply Strings的Java提交中击败了77.83% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode40. 组合总和 II</title>
    <link href="http://yoursite.com/2019/04/22/leetcode40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-II/"/>
    <id>http://yoursite.com/2019/04/22/leetcode40-组合总和-II/</id>
    <published>2019-04-22T14:44:26.000Z</published>
    <updated>2019-04-22T14:44:48.490Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p><p>candidates 中的每个数字在每个组合中只能使用一次。</p><p>说明：</p><p>所有数字（包括目标数）都是正整数。 解集不能包含重复的组合。  示例 1:</p><p>输入: candidates = [10,1,2,7,6,1,5], target = 8, 所求解集为: [   [1, 7],<br>[1, 2, 5],   [2, 6],   [1, 1, 6] ] 示例 2:</p><p>输入: candidates = [2,5,2,1,2], target = 5, 所求解集为: [   [1,2,2],   [5] ]</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>因为做了上一道题，这道题其实只是上一道题目的去重而已。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123;</span><br><span class="line">if(target &lt; 0) return null;</span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">Arrays.sort(candidates);</span><br><span class="line">dfs(res, candidates, new ArrayList&lt;Integer&gt;(), target, 0);</span><br><span class="line">return res;</span><br><span class="line">    &#125;</span><br><span class="line">public void dfs(List&lt;List&lt;Integer&gt;&gt; res, int[] candidates, List&lt;Integer&gt; tmp, int target, int index) &#123;</span><br><span class="line">if(target == 0) &#123;</span><br><span class="line">res.add(tmp);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">        if(target &lt; candidates[0]) return ;</span><br><span class="line">for(int i = index; i &lt; candidates.length &amp;&amp; candidates[i] &lt;= target; i++) &#123;</span><br><span class="line">//去重</span><br><span class="line">if (i &gt; index &amp;&amp; candidates[i] == candidates[i - 1]) continue;</span><br><span class="line">List&lt;Integer&gt; list = new ArrayList&lt;&gt;(tmp);</span><br><span class="line">list.add(candidates[i]);</span><br><span class="line">dfs(res, candidates, list, target-candidates[i], i+1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 6 ms, 在Combination Sum II的Java提交中击败了98.24% 的用户<br>内存消耗 : 38.9 MB, 在Combination Sum II的Java提交中击败了80.83% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode39.总数之和</title>
    <link href="http://yoursite.com/2019/04/22/leetcode39-%E6%80%BB%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://yoursite.com/2019/04/22/leetcode39-总数之和/</id>
    <published>2019-04-22T14:43:41.000Z</published>
    <updated>2019-04-22T14:44:37.243Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target<br>的组合。<br>candidates 中的数字可以无限制重复被选取。<br>说明：<br>所有数字（包括 target）都是正整数。 解集不能包含重复的组合。<br> <strong>示例 1:</strong><br><strong>输入:</strong> candidates = [2,3,6,7], target = 7,<br>所求解集为: [   [7],   [2,2,3] ]<br><strong>示例 2:</strong><br><strong>输入:</strong> candidates = [2,3,5], target = 8,<br>所求解集为: [   [2,2,2,2],   [2,3,3], [3,5] ]</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>深度搜索每一种可能，递归查找(target -candidates[i])是否有解。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123;</span><br><span class="line">if(target &lt; 0) return null;</span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">Arrays.sort(candidates);</span><br><span class="line">dfs(res, candidates, new ArrayList&lt;Integer&gt;(), target, 0);</span><br><span class="line">return res;</span><br><span class="line">    &#125;</span><br><span class="line">public void dfs(List&lt;List&lt;Integer&gt;&gt; res, int[] candidates, List&lt;Integer&gt; tmp, int target, int index) &#123;</span><br><span class="line">//如果target==0则找到</span><br><span class="line">if(target == 0) &#123;</span><br><span class="line">res.add(tmp);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">//已经排序，所以如果target不为0且小于candidates[0]则return</span><br><span class="line">        if(target &lt; candidates[0]) return ;</span><br><span class="line">for(int i = 0; i &lt; candidates.length &amp;&amp; candidates[i] &lt;= target; i++) &#123;</span><br><span class="line">    //如果candidates[0] &gt; target则不用深度了</span><br><span class="line">    //index记录当前节点，之前的节点的结果已经被遍历了。</span><br><span class="line">if(i &lt; index) continue;</span><br><span class="line">List&lt;Integer&gt; list = new ArrayList&lt;&gt;(tmp);</span><br><span class="line">list.add(candidates[i]);</span><br><span class="line">dfs(res, candidates, list, target-candidates[i], i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 6 ms, 在Combination Sum的Java提交中击败了98.24% 的用户<br>内存消耗 : 36.3 MB, 在Combination Sum的Java提交中击败了98.81% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode36. 有效的数独</title>
    <link href="http://yoursite.com/2019/04/21/leetcode36-%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC/"/>
    <id>http://yoursite.com/2019/04/21/leetcode36-有效的数独/</id>
    <published>2019-04-21T08:37:26.000Z</published>
    <updated>2019-04-21T08:37:55.042Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。</p><p>数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。<br><img src="https://img-blog.csdnimg.cn/2019042116333010.png" alt="在这里插入图片描述"></p><p>上图是一个部分填充的有效的数独。</p><p>数独部分空格内已填入了数字，空白格用 ‘.’ 表示。</p><p><strong>示例 1:</strong></p><p><strong>输入:</strong> [   [“5”,”3”,”.”,”.”,”7”,”.”,”.”,”.”,”.”],<br>[“6”,”.”,”.”,”1”,”9”,”5”,”.”,”.”,”.”],<br>[“.”,”9”,”8”,”.”,”.”,”.”,”.”,”6”,”.”],<br>[“8”,”.”,”.”,”.”,”6”,”.”,”.”,”.”,”3”],<br>[“4”,”.”,”.”,”8”,”.”,”3”,”.”,”.”,”1”],<br>[“7”,”.”,”.”,”.”,”2”,”.”,”.”,”.”,”6”],<br>[“.”,”6”,”.”,”.”,”.”,”.”,”2”,”8”,”.”],<br>[“.”,”.”,”.”,”4”,”1”,”9”,”.”,”.”,”5”],<br>[“.”,”.”,”.”,”.”,”8”,”.”,”.”,”7”,”9”] ]<br><strong>输出:</strong> true<br><strong>示例 2:</strong></p><p><strong>输入:</strong> [   [“8”,”3”,”.”,”.”,”7”,”.”,”.”,”.”,”.”],<br>[“6”,”.”,”.”,”1”,”9”,”5”,”.”,”.”,”.”],<br>[“.”,”9”,”8”,”.”,”.”,”.”,”.”,”6”,”.”],<br>[“8”,”.”,”.”,”.”,”6”,”.”,”.”,”.”,”3”],<br>[“4”,”.”,”.”,”8”,”.”,”3”,”.”,”.”,”1”],<br>[“7”,”.”,”.”,”.”,”2”,”.”,”.”,”.”,”6”],<br>[“.”,”6”,”.”,”.”,”.”,”.”,”2”,”8”,”.”],<br>[“.”,”.”,”.”,”4”,”1”,”9”,”.”,”.”,”5”],<br>[“.”,”.”,”.”,”.”,”8”,”.”,”.”,”7”,”9”] ]<br><strong>输出:</strong> false<br> <strong>解释:</strong> 除了第一行的第一个数字从 5<br>改为 8 以外，空格内其他数字均与 示例1 相同。<br>     但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。<br>     <strong>说明:</strong></p><p>一个有效的数独（部分已被填充）不一定是可解的。 只需要根据以上规则，验证已经填入的数字是否有效即可。 给定数独序列只包含数字 1-9 和字符 ‘.’ 。 给定数独永远是 9x9 形式的。</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>直接遍历整个数独，把所有的条件都实现即可。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isValidSudoku(char[][] board) &#123;</span><br><span class="line">for(int i = 0; i&lt; 9; i ++) </span><br><span class="line">        for(int j = 0; j &lt; 9; j ++) &#123;</span><br><span class="line">        if(board[i][j] == &apos;.&apos;) continue;</span><br><span class="line">        //遍历同一列的元素是否重复</span><br><span class="line">        for(int k = j+1; k &lt; 9; k ++) </span><br><span class="line">        if(board[i][j] == board[i][k]) return false;</span><br><span class="line">        //遍历同一行的元素是否重复</span><br><span class="line">        for(int k = i+1; k &lt; 9; k ++) </span><br><span class="line">        if(board[i][j] == board[k][j]) return false;</span><br><span class="line">        //遍历同个3*3格子里是否有重复</span><br><span class="line">        for(int k1 = i/3*3; k1 &lt; i/3*3+3; k1 ++) </span><br><span class="line">        for(int k2 = j/3*3; k2 &lt; j/3*3+3; k2++) &#123;</span><br><span class="line">        if(i == k1 &amp;&amp; j == k2) continue;</span><br><span class="line">        if(board[i][j] == board[k1][k2]) return false;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 5 ms, 在Valid Sudoku的Java提交中击败了98.72% 的用户<br>内存消耗 : 38.5 MB, 在Valid Sudoku的Java提交中击败了98.13% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。&lt;/p&gt;
&lt;p&gt;数字 1-9
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode34. 在排序数组中查找元素的第一个和最后一个位置</title>
    <link href="http://yoursite.com/2019/04/21/leetcode34-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2019/04/21/leetcode34-在排序数组中查找元素的第一个和最后一个位置/</id>
    <published>2019-04-21T08:37:14.000Z</published>
    <updated>2019-04-21T08:37:38.377Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p><p>你的算法时间复杂度必须是 O(log n) 级别。</p><p>如果数组中不存在目标值，返回 [-1, -1]。</p><p><strong>示例 1:</strong></p><p><strong>输入:</strong> nums = [5,7,7,8,8,10], target = 8<br><strong>输出:</strong> [3,4]<br><strong>示例 2:</strong></p><p><strong>输入:</strong> nums = [5,7,7,8,8,10], target = 6<br><strong>输出</strong>: [-1,-1]</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>使用二分查找找出最左最右2个元素的位置即可。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] searchRange(int[] nums, int target) &#123;</span><br><span class="line">        int[] res = &#123;-1,-1&#125;;</span><br><span class="line">        if(nums == null) return res;</span><br><span class="line">        int low = 0, high = nums.length-1;</span><br><span class="line">        while(low &lt;= high) &#123;</span><br><span class="line">        int mid = (low+high) &gt;&gt; 1;</span><br><span class="line">        if(nums[mid] == target &amp;&amp; (mid-1 &lt; 0 || nums[mid-1] &lt; target)) &#123;</span><br><span class="line">        res[0] = mid;</span><br><span class="line">        break;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(nums[mid] &gt;= target) </span><br><span class="line">        high = mid-1;</span><br><span class="line">        else </span><br><span class="line">        low = mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        //左边的元素如果没找到，就直接return</span><br><span class="line">        if(res[0] &lt; 0) return res;</span><br><span class="line">        low = 0; high = nums.length-1;</span><br><span class="line">        while(low &lt;= high) &#123;</span><br><span class="line">        int mid = (low+high) &gt;&gt; 1;</span><br><span class="line">        if(nums[mid] == target &amp;&amp; (mid+1 &gt;= nums.length || nums[mid+1] &gt; target)) &#123;</span><br><span class="line">        res[1] = mid;</span><br><span class="line">        break;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(nums[mid] &gt; target) </span><br><span class="line">        high = mid-1;</span><br><span class="line">        else </span><br><span class="line">        low = mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 1 ms, 在Find First and Last Position of Element in Sorted Array的Java提交中击败了99.50% 的用户<br>内存消耗 : 43.3 MB, 在Find First and Last Position of Element in Sorted Array的Java提交中击败了45.89% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode31. 下一个排列</title>
    <link href="http://yoursite.com/2019/04/21/leetcode31-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/"/>
    <id>http://yoursite.com/2019/04/21/leetcode31-下一个排列/</id>
    <published>2019-04-21T06:16:11.000Z</published>
    <updated>2019-04-21T06:16:30.558Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p><p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p><p>必须原地修改，只允许使用额外常数空间。</p><p>以下是一些例子，输入位于左侧列，其相应输出位于右侧列。 1,2,3 → 1,3,2 3,2,1 → 1,2,3 1,1,5 → 1,5,1</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>直接从数组的结尾遍历，如果nums[i] &lt; nums[i+1]则说明有下一个排序数组; 如若没有找到，则说明这是倒序排列，则直接反转数组。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public void nextPermutation(int[] nums) &#123;</span><br><span class="line">        if(nums.length == 1) return;</span><br><span class="line">if(nums.length == 2) &#123;swap(nums, 0, 1); return;&#125;</span><br><span class="line">int len = nums.length;</span><br><span class="line">int index = len-2;</span><br><span class="line">        for(; index &gt;= 0; index --) &#123;</span><br><span class="line">        if(nums[index] &lt; nums[index+1])</span><br><span class="line">        break;</span><br><span class="line">        &#125;</span><br><span class="line">        if(index &lt; 0) &#123;</span><br><span class="line">        reserve(nums, 0, len-1);</span><br><span class="line">        return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = len-1; i &gt; index; i --) &#123;</span><br><span class="line">        if(nums[i] &gt; nums[index]) &#123;</span><br><span class="line">        swap(nums, i, index);</span><br><span class="line">        reserve(nums, index+1, len-1);</span><br><span class="line">                return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void swap(int[] nums, int n, int m) &#123;</span><br><span class="line">int tmp = nums[n];</span><br><span class="line">nums[n] = nums[m];</span><br><span class="line">nums[m] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">    public void reserve(int[] nums, int n, int m) &#123;</span><br><span class="line">while(n &lt; m) swap(nums,n++,m--);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 2 ms, 在Next Permutation的Java提交中击败了99.35% 的用户<br>内存消耗 : 38.2 MB, 在Next Permutation的Java提交中击败了80.97% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。&lt;/p&gt;
&lt;p&gt;如果不存在下一
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
</feed>
