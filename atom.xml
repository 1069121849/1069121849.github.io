<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>白哥的博客</title>
  
  <subtitle>白哥的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-05-29T07:12:28.280Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>白哥</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JVM学习笔记</title>
    <link href="http://yoursite.com/2019/05/29/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/05/29/JVM学习笔记/</id>
    <published>2019-05-29T07:07:54.126Z</published>
    <updated>2019-05-29T07:12:28.280Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM学习"><a href="#JVM学习" class="headerlink" title="JVM学习"></a>JVM学习</h2><h3 id="JVM如何加载-class文件"><a href="#JVM如何加载-class文件" class="headerlink" title="JVM如何加载.class文件"></a>JVM如何加载.class文件</h3><p><strong>JVM虚拟机</strong></p><p><img src="https://img-blog.csdnimg.cn/20190529150652107.png" alt="在这里插入图片描述"><br>Class Loader：以及特定格式，加载class文件到内存</p><p>Execution Engine：对命令进行解析</p><p>Native Interface：融合不同开发语言的原生库为java所用</p><p>Runtime Data Area：JVM内存空间结构模型</p><h3 id="类从编译到执行的过程"><a href="#类从编译到执行的过程" class="headerlink" title="类从编译到执行的过程"></a>类从编译到执行的过程</h3><p>编译器将java源文件编译成class字节码文件</p><p>ClassLoader将字节码转换为JVM中的Class对象</p><p>JVM利用Class对象实例化为实例对象</p><h3 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h3><p>ClassLoader在Java中有着非常重要的作用，它主要工作在Class装载的加载阶段，其主要作用是从系统外部获取Class二进制数据流。它是Java的核心组件，所有的Class都是由ClassLoader进行加载的，ClassLoader负责通过将Class文件里的二进制数据流装载进系统，然后交给Java虚拟机进行链接、初始化等操作。</p><h3 id="ClassLoader的种类"><a href="#ClassLoader的种类" class="headerlink" title="ClassLoader的种类"></a>ClassLoader的种类</h3><ul><li><p>[ ] BootStrapClassLoader：C++编写，加载核心库java.*</p></li><li><p>[ ] ExtClassLoader：Java编写，加载扩展库javax.*</p></li><li><p>[ ] AppClassLoader：Java编写，加载程序所在目录</p></li><li><p>[ ] 自定义ClassLoader：Java编写，定制化加载</p></li></ul><h3 id="类的加载方式"><a href="#类的加载方式" class="headerlink" title="类的加载方式"></a>类的加载方式</h3><p>隐式加载：new</p><p>显式加载：loadClass，forName等</p><h3 id="类的装载过程"><a href="#类的装载过程" class="headerlink" title="类的装载过程"></a>类的装载过程</h3><ol><li>加载： 通过ClassLoader加载class文件字节码，生成Class对象</li><li>链接：<ul><li>校验：检查加载的class的正确性和安全性</li><li>准备：为类变量分配存储空间并设置类变量初始值</li><li>解析：JVM将常量池内的符号引用转换为直接引用</li></ul></li><li>初始化：执行类变量赋值和静态代码块</li></ol><h3 id="loadClass和forName的区别"><a href="#loadClass和forName的区别" class="headerlink" title="loadClass和forName的区别"></a>loadClass和forName的区别</h3><p>Class.forName得到的class是已经初始化完成的</p><p>ClassLoader.loadClass得到的clas是还没有链接的</p><h3 id="JVM内存模型-JDK8"><a href="#JVM内存模型-JDK8" class="headerlink" title="JVM内存模型-JDK8"></a>JVM内存模型-JDK8</h3><p><img src="https://img-blog.csdnimg.cn/20190529150723636.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDQ4NTc0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>线程私有：程序计数器、虚拟机栈、本地方法栈</li><li>线程共享：MetaSpace、Java堆</li></ul><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><ul><li>当前线程所执行的字节码行号指示器（逻辑）</li><li>改变计数器的值来选取下一条需要执行的字节码指令</li><li>和线程是一对一的关系，即“线程私有”</li><li>对Java方法计数，如果是Native方法则计数器值为Undefined</li><li>不会发生内存泄漏</li></ul><h4 id="Java虚拟机栈（Stack）"><a href="#Java虚拟机栈（Stack）" class="headerlink" title="Java虚拟机栈（Stack）"></a>Java虚拟机栈（Stack）</h4><p><img src="https://img-blog.csdnimg.cn/20190529150740675.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDQ4NTc0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>Java方法执行的内存模型</li><li>包含多个栈帧</li></ul><h5 id="局部变量表和操作数栈"><a href="#局部变量表和操作数栈" class="headerlink" title="局部变量表和操作数栈"></a>局部变量表和操作数栈</h5><ul><li>局部变量表：包含方法执行过程中的所有变量</li><li>操作数栈：入栈、出栈、复制、交换、产生消费变量</li></ul><h5 id="递归为什么会引发java-lang-StackOverflowError异常"><a href="#递归为什么会引发java-lang-StackOverflowError异常" class="headerlink" title="递归为什么会引发java.lang.StackOverflowError异常"></a>递归为什么会引发java.lang.StackOverflowError异常</h5><p>递归过深，栈帧数超过虚拟栈深度</p><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>与虚拟机栈相似，主要作用于标注了native的方法</p><h4 id="元空间（Metaspace）："><a href="#元空间（Metaspace）：" class="headerlink" title="元空间（Metaspace）："></a>元空间（Metaspace）：</h4><p>存储已被虚拟机加载的类信息。随着JDK8的到来，JVM不再有方法区（PermGen），原方法区存储的信息被分成两部分：</p><p>1、虚拟机加载的类信息，被移动到元空间。</p><p>2、运行时常量池，被移动到了堆中<strong>（静态成员变量）</strong>。</p><h5 id="MetaSpace（元空间）相比PermGen（永久代）的优势"><a href="#MetaSpace（元空间）相比PermGen（永久代）的优势" class="headerlink" title="MetaSpace（元空间）相比PermGen（永久代）的优势"></a>MetaSpace（元空间）相比PermGen（永久代）的优势</h5><p>元数据区取代了1.7版本及以前的永久代。元数据区和永久代本质上都是方法区的实现。方法区存放虚拟机加载的类信息，静态变量，常量等数据。</p><ul><li>字符串常量池存在永久代中，容易出现性能问题和内存溢出</li><li>类和方法的信息大小难以确定，给永久代的大小指定带来困难</li><li>永久代会给GC带来不必要的复杂性</li><li>方便HotSpot与其他JVM如 Jrockit的集成</li></ul><h4 id="Java堆（Heap）"><a href="#Java堆（Heap）" class="headerlink" title="Java堆（Heap）"></a>Java堆（Heap）</h4><ul><li>对象实例的分配区域</li><li>GC管理的主要区域</li></ul><h4 id="直接内存（没有在上图体现出来）"><a href="#直接内存（没有在上图体现出来）" class="headerlink" title="直接内存（没有在上图体现出来）"></a>直接内存（没有在上图体现出来）</h4><p>jdk1.4引入了NIO，它可以使用Native函数库直接分配堆外内存。</p><h3 id="JVM三大性能调优参数-Xms-Xmx-Xss的含义"><a href="#JVM三大性能调优参数-Xms-Xmx-Xss的含义" class="headerlink" title="JVM三大性能调优参数 -Xms -Xmx -Xss的含义"></a>JVM三大性能调优参数 -Xms -Xmx -Xss的含义</h3><ul><li>-Xss：规定了每个线程虚拟机栈（堆栈）的大小</li><li>-Xms：堆的初始值</li><li>-Xmx：堆能达到的最大值</li></ul><p>一般Xms和Xmx设置为一样的值，因为扩容时会发生内存抖动。</p><h3 id="Java内存模型中堆和栈的区别——内存分配策略"><a href="#Java内存模型中堆和栈的区别——内存分配策略" class="headerlink" title="Java内存模型中堆和栈的区别——内存分配策略"></a>Java内存模型中堆和栈的区别——内存分配策略</h3><ul><li>静态存储：编译时确定每个数据目标在运行时的存储空间需求</li><li>栈式存储：数据区需求在编译时未知，运行时模块入口前确定</li><li>堆式存储：编译时或运行时模块入口都无法确定，动态分配</li></ul><h3 id="Java内存模型中堆和栈的区别"><a href="#Java内存模型中堆和栈的区别" class="headerlink" title="Java内存模型中堆和栈的区别"></a>Java内存模型中堆和栈的区别</h3><ul><li>管理方式：栈自动释放，堆需要GC</li><li>空间大小：栈比对小</li><li>碎片相关：栈产生的碎片远小于堆</li><li>分配方式：栈支持静态和动态分配，而堆仅支持动态分配</li><li>效率：栈的效率比堆高</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JVM学习&quot;&gt;&lt;a href=&quot;#JVM学习&quot; class=&quot;headerlink&quot; title=&quot;JVM学习&quot;&gt;&lt;/a&gt;JVM学习&lt;/h2&gt;&lt;h3 id=&quot;JVM如何加载-class文件&quot;&gt;&lt;a href=&quot;#JVM如何加载-class文件&quot; class=&quot;he
      
    
    </summary>
    
      <category term="笔记" scheme="http://yoursite.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/05/24/leetcode208.%20%E5%AE%9E%E7%8E%B0%20Trie%20(%E5%89%8D%E7%BC%80%E6%A0%91)/"/>
    <id>http://yoursite.com/2019/05/24/leetcode208. 实现 Trie (前缀树)/</id>
    <published>2019-05-24T12:08:06.153Z</published>
    <updated>2019-05-27T13:34:48.790Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title: leetcode208. 实现 Trie (前缀树)<br>date:<br>tags: </p><pre><code>- leetcode- java</code></pre><h2 id="categories-算法"><a href="#categories-算法" class="headerlink" title="categories: 算法"></a>categories: 算法</h2><p>﻿## 题目</p><blockquote><p>实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。</p><p><strong>示例:</strong></p><p>Trie trie = new Trie();</p><p>trie.insert(“apple”); trie.search(“apple”);   // 返回 true<br>trie.search(“app”);     // 返回 false trie.startsWith(“app”); // 返回 true<br>trie.insert(“app”);    trie.search(“app”);     // 返回 true<br><strong>说明:</strong></p><p>你可以假设所有的输入都是由小写字母 a-z 构成的。 保证所有输入均为非空字符串。</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>创建一个结点类，每个结点有26个子结点（26个字母），一个布尔变量，表示该结点是否是某个单词的结尾。<br>然后完成题目要求即可</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">class Trie &#123;</span><br><span class="line">    public class TrieNode&#123;</span><br><span class="line">        boolean isWord;</span><br><span class="line">        TrieNode[] letters = new TrieNode[26];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TrieNode root ;</span><br><span class="line">    public Trie() &#123;</span><br><span class="line">        root = new TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line">    /** Inserts a word into the trie. */</span><br><span class="line">    public void insert(String word) &#123;</span><br><span class="line">        if (word != null) &#123;</span><br><span class="line">            char[] chars = word.toCharArray();</span><br><span class="line">            TrieNode tmp = root;</span><br><span class="line">            for (int i = 0; i &lt; chars.length; i++) &#123;</span><br><span class="line">                if(tmp.letters[chars[i]-&apos;a&apos;] == null)</span><br><span class="line">                    tmp.letters[chars[i]-&apos;a&apos;] = new TrieNode();</span><br><span class="line">                tmp = tmp.letters[chars[i]-&apos;a&apos;];</span><br><span class="line">            &#125;</span><br><span class="line">            tmp.isWord = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** Returns if the word is in the trie. */</span><br><span class="line">    public boolean search(String word) &#123;</span><br><span class="line">        if (word != null) &#123;</span><br><span class="line">            char[] chars = word.toCharArray();</span><br><span class="line">            TrieNode tmp = root;</span><br><span class="line">            for (int i = 0; i &lt; chars.length; i++) &#123;</span><br><span class="line">                if (tmp.letters[chars[i]-&apos;a&apos;] == null)</span><br><span class="line">                    return false;</span><br><span class="line">                tmp = tmp.letters[chars[i]-&apos;a&apos;];</span><br><span class="line">            &#125;</span><br><span class="line">            return tmp.isWord;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** Returns if there is any word in the trie that starts with the given prefix. */</span><br><span class="line">    public boolean startsWith(String prefix) &#123;</span><br><span class="line">        char[] chars = prefix.toCharArray();</span><br><span class="line">        TrieNode tmp = root;</span><br><span class="line">        for (int i = 0; i &lt; chars.length; i++) &#123;</span><br><span class="line">            if (tmp.letters[chars[i]-&apos;a&apos;] == null)</span><br><span class="line">                return false;</span><br><span class="line">            tmp = tmp.letters[chars[i]-&apos;a&apos;];</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 163 ms, 在Implement Trie (Prefix Tree)的Java提交中击败了88.17% 的用户<br>内存消耗 : 61.8 MB, 在Implement Trie (Prefix Tree)的Java提交中击败了76.08% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;title: leetcode208. 实现 Trie (前缀树)&lt;br&gt;date:&lt;br&gt;tags: &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- leetcode
- java
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;categories-算法&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>leetcode207. 课程表</title>
    <link href="http://yoursite.com/2019/05/24/leetcode207.%20%E8%AF%BE%E7%A8%8B%E8%A1%A8/"/>
    <id>http://yoursite.com/2019/05/24/leetcode207. 课程表/</id>
    <published>2019-05-24T01:28:29.406Z</published>
    <updated>2019-05-24T05:40:04.017Z</updated>
    
    <content type="html"><![CDATA[<p>﻿## 题目</p><blockquote><p>现在你总共有 n 门课需要选，记为 0 到 n-1。</p><p>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]</p><p>给定课程总量以及它们的先决条件，判断是否可能完成所有课程的学习？</p><p><strong>示例 1:</strong></p><p><strong>输入:</strong> 2, [[1,0]]<br><strong>输出:</strong> true<br><strong>解释:</strong> 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。<br><strong>示例 2:</strong></p><p><strong>输入:</strong> 2, [[1,0],[0,1]]<br><strong>输出:</strong> false<br><strong>解释:</strong> 总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。<br><strong>说明:</strong></p><p>输入的先决条件是由边缘列表表示的图形，而不是邻接矩阵。详情请参见图的表示法。 你可以假定输入的先决条件中没有重复的边。<br><strong>提示:</strong></p><p>这个问题相当于查找一个循环是否存在于有向图中。如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。 通过 DFS 进行拓扑排序</p><ul><li>一个关于Coursera的精彩视频教程（21分钟），介绍拓扑排序的基本概念。 拓扑排序也可以通过 BFS 完成。</li></ul></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>我的解法是直接把图的边剪断，如果最后能够完成所有点没有相连的边即能够完成所有课程，也是故意不用提示的做法去做的。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean canFinish(int numCourses, int[][] prerequisites) &#123;</span><br><span class="line">        //存储可以选读的课程</span><br><span class="line">        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; prerequisites.length; i++) &#123;</span><br><span class="line">            if(!map.containsKey(prerequisites[i][0]))&#123;</span><br><span class="line">                map.put(prerequisites[i][0], 1);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                map.put(prerequisites[i][0], map.get(prerequisites[i][0]) + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; numCourses; i++) &#123;</span><br><span class="line">            if(!map.containsKey(i))&#123;</span><br><span class="line">                list.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int len = prerequisites.length;</span><br><span class="line">        while(!list.isEmpty()) &#123;</span><br><span class="line">            int tmp = list.remove(list.size()-1);</span><br><span class="line">            for (int i = 0; i &lt; prerequisites.length; i++) &#123;</span><br><span class="line">                if (prerequisites[i][1] == tmp) &#123;</span><br><span class="line">                    len--;</span><br><span class="line">                    if(map.get(prerequisites[i][0]) == 1)&#123;</span><br><span class="line">                        list.add(prerequisites[i][0]);</span><br><span class="line">                    &#125; else&#123;</span><br><span class="line">                        map.put(prerequisites[i][0], map.get(prerequisites[i][0])-1);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return len == 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 47 ms, 在Course Schedule的Java提交中击败了40.49% 的用户<br>内存消耗 : 43.1 MB, 在Course Schedule的Java提交中击败了79.55% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;﻿## 题目&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;现在你总共有 n 门课需要选，记为 0 到 n-1。&lt;/p&gt;
&lt;p&gt;在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]&lt;/p&gt;
&lt;p&gt;给定课程总
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode201. 数字范围按位与</title>
    <link href="http://yoursite.com/2019/05/23/leetcode201.%20%E6%95%B0%E5%AD%97%E8%8C%83%E5%9B%B4%E6%8C%89%E4%BD%8D%E4%B8%8E/"/>
    <id>http://yoursite.com/2019/05/23/leetcode201. 数字范围按位与/</id>
    <published>2019-05-23T13:50:51.069Z</published>
    <updated>2019-05-24T01:01:31.113Z</updated>
    
    <content type="html"><![CDATA[<p>﻿## 题目</p><blockquote><p>给定范围 [m, n]，其中 0 &lt;= m &lt;= n &lt;= 2147483647，返回此范围内所有数字的按位与（包含 m, n 两端点）。</p><p><strong>示例 1:</strong> </p><p><strong>输入:</strong> [5,7]<br><strong>输出:</strong> 4<br><strong>示例 2:</strong></p><p><strong>输入:</strong> [0,1]<br><strong>输出:</strong> 0</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>把n、m后面不一样的去掉，剩下一样的，因为不一样的&amp;之后的就是0，使用一个变量保存有多少个0。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int rangeBitwiseAnd(int m, int n) &#123;</span><br><span class="line">        if (m == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int tmp = 1;</span><br><span class="line">        while(n != m)&#123;</span><br><span class="line">            m &gt;&gt;= 1;</span><br><span class="line">            n &gt;&gt;= 1;</span><br><span class="line">            tmp &lt;&lt;= 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return m * tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 36 ms, 在Bitwise AND of Numbers Range的Java提交中击败了30.45% 的用户<br>内存消耗 : 36.5 MB, 在Bitwise AND of Numbers Range的Java提交中击败了10.42% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;﻿## 题目&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定范围 [m, n]，其中 0 &amp;lt;= m &amp;lt;= n &amp;lt;= 2147483647，返回此范围内所有数字的按位与（包含 m, n 两端点）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt; &lt;
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode199. 二叉树的右视图</title>
    <link href="http://yoursite.com/2019/05/21/leetcode199.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/"/>
    <id>http://yoursite.com/2019/05/21/leetcode199. 二叉树的右视图/</id>
    <published>2019-05-21T13:46:54.492Z</published>
    <updated>2019-05-21T14:18:57.470Z</updated>
    
    <content type="html"><![CDATA[<p>﻿## 题目</p><p>给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><p><strong>示例:</strong></p><p><strong>输入:</strong> [1,2,3,null,5,null,4]<br><strong>输出:</strong> [1, 3, 4]<br><strong>解释:</strong></p><p>   <img src="https://img-blog.csdnimg.cn/2019052121450834.png" alt="1            &lt;--- /   \2     3         &lt;--- \     \  5     4       &lt;---"></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p> 层次遍历，使用一个队列，每次把右结点先放入，再放入左结点，每一层的最右个结点加入结果即可。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; rightSideView(TreeNode root) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return new ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        while (!queue.isEmpty())&#123;</span><br><span class="line">            TreeNode tn = queue.peek();</span><br><span class="line">            int size = queue.size();</span><br><span class="line">            res.add(tn.val);</span><br><span class="line">            while(size &gt; 0)&#123;</span><br><span class="line">                tn = queue.remove();</span><br><span class="line">                if (tn.right != null)&#123;</span><br><span class="line">                    queue.add(tn.right);</span><br><span class="line">                &#125;</span><br><span class="line">                if (tn.left != null) &#123;</span><br><span class="line">                    queue.add(tn.left);</span><br><span class="line">                &#125;</span><br><span class="line">                size --;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 3 ms, 在Binary Tree Right Side View的Java提交中击败了69.61% 的用户<br>内存消耗 : 35.1 MB, 在Binary Tree Right Side View的Java提交中击败了44.50% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;﻿## 题目&lt;/p&gt;
&lt;p&gt;给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入:&lt;/strong&gt; [1,2,3,null,5,null,4]
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode187. 重复的DNA序列</title>
    <link href="http://yoursite.com/2019/05/21/leetcode187.%20%E9%87%8D%E5%A4%8D%E7%9A%84DNA%E5%BA%8F%E5%88%97/"/>
    <id>http://yoursite.com/2019/05/21/leetcode187. 重复的DNA序列/</id>
    <published>2019-05-21T12:56:09.221Z</published>
    <updated>2019-05-21T14:19:10.354Z</updated>
    
    <content type="html"><![CDATA[<p>﻿## 题目</p><blockquote><p>所有 DNA 由一系列缩写为 A，C，G 和 T 的核苷酸组成，例如：“ACGAATTCCG”。在研究 DNA 时，识别 DNA<br>中的重复序列有时会对研究非常有帮助。</p><p>编写一个函数来查找 DNA 分子中所有出现超多一次的10个字母长的序列（子串）。</p><p><strong>示例:</strong></p><p><strong>输入:</strong> s = “AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT”</p><p><strong>输出:</strong> [“AAAAACCCCC”, “CCCCCAAAAA”]</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>使用一个集合set，遍历一遍字符串，如果存入集合成功，则说明字符串是第一次出现，如果存入集合不成功，说明该字符串不是第一次出现，存入结果集合，最后把结果集合res转为链表返回即可。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;String&gt; findRepeatedDnaSequences(String s) &#123;</span><br><span class="line">        Set&lt;String&gt; set = new HashSet&lt;&gt;();</span><br><span class="line">        Set&lt;String&gt; res = new HashSet&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt;= s.length()-10; i++) &#123;</span><br><span class="line">            String str = s.substring(i,i+10);</span><br><span class="line">            if(!set.add(str))&#123;</span><br><span class="line">                res.add(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return new ArrayList&lt;&gt;(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 59 ms, 在Repeated DNA Sequences的Java提交中击败了42.82% 的用户<br>内存消耗 : 54.6 MB, 在Repeated DNA Sequences的Java提交中击败了19.19% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;﻿## 题目&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;所有 DNA 由一系列缩写为 A，C，G 和 T 的核苷酸组成，例如：“ACGAATTCCG”。在研究 DNA 时，识别 DNA&lt;br&gt;中的重复序列有时会对研究非常有帮助。&lt;/p&gt;
&lt;p&gt;编写一个函数来查找 DNA 分子
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode180. 连续出现的数字</title>
    <link href="http://yoursite.com/2019/05/20/leetcode180.%20%E8%BF%9E%E7%BB%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>http://yoursite.com/2019/05/20/leetcode180. 连续出现的数字/</id>
    <published>2019-05-20T07:54:31.140Z</published>
    <updated>2019-05-20T07:58:06.705Z</updated>
    
    <content type="html"><![CDATA[<p>﻿## 题目</p><blockquote><p>编写一个 SQL 查询，查找所有至少连续出现三次的数字。</p><p><img src="https://img-blog.csdnimg.cn/20190520155314412.png" alt="+----+-----+ | Id | Num |+----+-----+ | 1  |  1  | | 2  |  1  | | 3  |  1  | | 4  |  2  | | 5  |  1  | | 6  |  2  | | 7  |  2  |+----+-----+"> 例如，给定上面的 Logs 表， 1 是唯一连续出现至少三次的数字。</p><p><img src="https://img-blog.csdnimg.cn/2019052015532164.png" alt="+-----------------+ | ConsecutiveNums |+-----------------+ | 1               |+-----------------+"></p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>直接查找3行num相等的数据即可</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><pre><code>select distinct l1.num as ConsecutiveNumsfrom logs l1, logs l2, logs l3where l1.id = l2.id-1 and l2.id = l3.id-1 andl1.num = l2.num and l2.num = l3.num</code></pre><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 782 ms, 在Consecutive Numbers的MySQL提交中击败了41.07% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;﻿## 题目&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;编写一个 SQL 查询，查找所有至少连续出现三次的数字。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190520155314412.png&quot; alt=&quot;+----+--
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>leetcode179. 最大数</title>
    <link href="http://yoursite.com/2019/05/20/leetcode179.%20%E6%9C%80%E5%A4%A7%E6%95%B0/"/>
    <id>http://yoursite.com/2019/05/20/leetcode179. 最大数/</id>
    <published>2019-05-20T07:39:29.516Z</published>
    <updated>2019-05-20T07:55:27.589Z</updated>
    
    <content type="html"><![CDATA[<p>﻿## 题目</p><blockquote><p>给定一组非负整数，重新排列它们的顺序使之组成一个最大的整数。</p><p><strong>示例 1:</strong></p><p><strong>输入:</strong> [10,2]<br><strong>输出:</strong> 210<br><strong>示例 2:</strong></p><p><strong>输入:</strong> [3,30,34,5,9]<br><strong>输出:</strong> 9534330<br><strong>说明:</strong> 输出结果可能非常大，所以你需要返回一个字符串而不是整数。</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>直接重新排序规则即可。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String largestNumber(int[] nums) &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;();</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            arrayList.add(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(arrayList, new Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            public int compare(Integer o1, Integer o2) &#123;</span><br><span class="line">                String a = o1.toString();</span><br><span class="line">                String b = o2.toString();</span><br><span class="line">                Long res = Long.parseLong(b+a) - Long.parseLong(a+b);</span><br><span class="line">                return res.intValue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        StringBuilder res = new StringBuilder(nums.length);</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            res.append(arrayList.get(i));</span><br><span class="line">            if (i==0 &amp;&amp; Integer.parseInt(res.toString()) == 0)&#123;</span><br><span class="line">                return &quot;0&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 17 ms, 在Largest Number的Java提交中击败了75.24% 的用户<br>内存消耗 : 35.7 MB, 在Largest Number的Java提交中击败了98.40% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;﻿## 题目&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一组非负整数，重新排列它们的顺序使之组成一个最大的整数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入:&lt;/strong&gt; [10,2]&lt;br&gt;&lt;strong&gt;输出:
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode178. 分数排名</title>
    <link href="http://yoursite.com/2019/05/18/leetcode178.%20%E5%88%86%E6%95%B0%E6%8E%92%E5%90%8D/"/>
    <id>http://yoursite.com/2019/05/18/leetcode178. 分数排名/</id>
    <published>2019-05-18T08:53:44.889Z</published>
    <updated>2019-05-18T08:55:18.443Z</updated>
    
    <content type="html"><![CDATA[<p>﻿## 题目</p><blockquote><p>SQL架构 编写一个 SQL<br>查询来实现分数排名。如果两个分数相同，则两个分数排名（Rank）相同。请注意，平分后的下一个名次应该是下一个连续的整数值。换句话说，名次之间不应该有“间隔”。<br><img src="https://img-blog.csdnimg.cn/20190518165127349.png" alt="在这里插入图片描述"><br>例如，根据上述给定的 Scores 表，你的查询应该返回（按分数从高到低排列）：<br><img src="https://img-blog.csdnimg.cn/20190518165134884.png" alt="在这里插入图片描述"></p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>排序score，找出有多少个score（去除重复distinct）比当前score多，当前的rank即为其+1。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select s1.score, </span><br><span class="line">(select count(distinct s2.score)+1 </span><br><span class="line">from scores s2 </span><br><span class="line">where s2.score &gt; s1.score ) rank </span><br><span class="line">from scores s1 </span><br><span class="line">order by s1.score desc;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 833 ms, 在Rank Scores的MySQL提交中击败了63.26% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;﻿## 题目&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;SQL架构 编写一个 SQL&lt;br&gt;查询来实现分数排名。如果两个分数相同，则两个分数排名（Rank）相同。请注意，平分后的下一个名次应该是下一个连续的整数值。换句话说，名次之间不应该有“间隔”。&lt;br&gt;&lt;img src=
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>leetcode177. 第N高的薪水</title>
    <link href="http://yoursite.com/2019/05/18/leetcode177.%20%E7%AC%ACN%E9%AB%98%E7%9A%84%E8%96%AA%E6%B0%B4/"/>
    <id>http://yoursite.com/2019/05/18/leetcode177. 第N高的薪水/</id>
    <published>2019-05-18T08:50:42.459Z</published>
    <updated>2019-05-18T08:55:34.214Z</updated>
    
    <content type="html"><![CDATA[<p>﻿## 题目</p><blockquote><p>编写一个 SQL 查询，获取 Employee 表中第 n 高的薪水（Salary）。</p><p><img src="https://img-blog.csdnimg.cn/20190518164733734.png" alt="+----+--------+ | Id | Salary |+----+--------+ | 1  | 100    | | 2  | 200    | | 3  | 300    |+----+--------+"><br>例如上述 Employee 表，n = 2 时，应返回第二高的薪水 200。如果不存在第 n 高的薪水，那么查询应返回 null。</p><p><img src="https://img-blog.csdnimg.cn/2019051816474423.png" alt="+------------------------+ | getNthHighestSalary(2) |+------------------------+ | 200                    |+------------------------+"></p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>根据salary去重（distinct）降序排序（order by salary desc），然后找出第n-1行即可。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT</span><br><span class="line">BEGIN</span><br><span class="line">  Set N = N -1;</span><br><span class="line">  RETURN (</span><br><span class="line">      select distinct salary from employee</span><br><span class="line">      order by salary desc</span><br><span class="line">      limit 1 offset N</span><br><span class="line">  );</span><br><span class="line">END</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 327 ms, 在Nth Highest Salary的MySQL提交中击败了89.32% 的用户<br>内存消耗 : N/A</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;﻿## 题目&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;编写一个 SQL 查询，获取 Employee 表中第 n 高的薪水（Salary）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190518164733734.png
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>leetcode173. 二叉搜索树迭代器</title>
    <link href="http://yoursite.com/2019/05/18/leetcode173.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    <id>http://yoursite.com/2019/05/18/leetcode173. 二叉搜索树迭代器/</id>
    <published>2019-05-18T08:26:49.430Z</published>
    <updated>2019-05-18T08:54:51.078Z</updated>
    
    <content type="html"><![CDATA[<p>﻿## 题目</p><blockquote><p>实现一个二叉搜索树迭代器。你将使用二叉搜索树的根节点初始化迭代器。</p><p>调用 next() 将返回二叉搜索树中的下一个最小的数。</p><p><strong>示例：</strong><br><img src="https://img-blog.csdnimg.cn/20190518162407757.png" alt="在这里插入图片描述"><br>BSTIterator iterator = new BSTIterator(root); iterator.next();    //<br>返回 3 iterator.next();    // 返回 7 iterator.hasNext(); // 返回 true<br>iterator.next();    // 返回 9 iterator.hasNext(); // 返回 true<br>iterator.next();    // 返回 15 iterator.hasNext(); // 返回 true<br>iterator.next();    // 返回 20 iterator.hasNext(); // 返回 false  </p><p><strong>提示：</strong></p><p>next() 和 hasNext() 操作的时间复杂度是 O(1)，并使用 O(h) 内存，其中 h 是树的高度。 你可以假设 next()<br>调用总是有效的，也就是说，当调用 next() 时，BST 中至少存在一个下一个最小的数。</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>使用中序遍历，把二叉搜索树的数据存入到一个链表list中，即链表的有序的，然后每次next（）返回其链表的开头元素即可。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class BSTIterator &#123;</span><br><span class="line">    LinkedList&lt;Integer&gt; list = new LinkedList&lt;Integer&gt;();</span><br><span class="line">    public BSTIterator(TreeNode root) &#123;</span><br><span class="line">        inOrder(list, root);</span><br><span class="line">    &#125;</span><br><span class="line">    public void inOrder(List&lt;Integer&gt; list, TreeNode root)&#123;</span><br><span class="line">        if(root == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        inOrder(list, root.left);</span><br><span class="line">        list.add(root.val);</span><br><span class="line">        inOrder(list, root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    public int next() &#123;</span><br><span class="line">        return list.pollFirst();</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean hasNext() &#123;</span><br><span class="line">        return list.size() &gt; 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 95 ms, 在Binary Search Tree Iterator的Java提交中击败了97.48% 的用户<br>内存消耗 : 49.2 MB, 在Binary Search Tree Iterator的Java提交中击败了99.47% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;﻿## 题目&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;实现一个二叉搜索树迭代器。你将使用二叉搜索树的根节点初始化迭代器。&lt;/p&gt;
&lt;p&gt;调用 next() 将返回二叉搜索树中的下一个最小的数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;br&gt;&lt;img src=
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode147. 对链表进行插入排序</title>
    <link href="http://yoursite.com/2019/05/17/leetcode147.%20%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2019/05/17/leetcode147. 对链表进行插入排序/</id>
    <published>2019-05-17T12:26:32.793Z</published>
    <updated>2019-05-18T08:54:31.173Z</updated>
    
    <content type="html"><![CDATA[<p>﻿## 题目</p><blockquote><p>对链表进行插入排序。</p><p>插入排序的动画演示如上。从第一个元素开始，该链表可以被认为已经部分排序（用黑色表示）。<br>每次迭代时，从输入数据中移除一个元素（用红色表示），并原地将其插入到已排好序的链表中。</p><p>插入排序算法：</p><p>插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。<br>每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。 重复直到所有输入数据插入完为止。  </p><p><strong>示例 1：</strong></p><p><strong>输入:</strong> 4-&gt;2-&gt;1-&gt;3<br><strong>输出:</strong> 1-&gt;2-&gt;3-&gt;4<br><strong>示例 2：</strong></p><p><strong>输入:</strong> -1-&gt;5-&gt;3-&gt;4-&gt;0<br><strong>输出:</strong> -1-&gt;0-&gt;3-&gt;4-&gt;5</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>就是在链表上实现插入排序，注意链表的指针更新和链表的链接即可。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode insertionSortList(ListNode head) &#123;</span><br><span class="line">        if(head == null) return null;</span><br><span class="line">        ListNode p = head.next;</span><br><span class="line">        ListNode ppre = head;</span><br><span class="line"></span><br><span class="line">        while (p != null) &#123;</span><br><span class="line">            boolean flag = false;</span><br><span class="line">            ListNode q = p.next;</span><br><span class="line">            ListNode x = head;ListNode xpre = null;</span><br><span class="line">            for (; x != p;xpre= x, x = x.next)</span><br><span class="line">                if (x.val &gt; p.val) &#123;</span><br><span class="line">                    flag = true;</span><br><span class="line">                    if (x == head) &#123;</span><br><span class="line">                        p.next = head;</span><br><span class="line">                        head = p;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        xpre.next = p;</span><br><span class="line">                        p.next = x;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ppre.next = q;</span><br><span class="line">                    p = q;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            if(!flag)&#123;</span><br><span class="line">                ppre = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 36 ms, 在Insertion Sort List的Java提交中击败了64.10% 的用户<br>内存消耗 : 38.6 MB, 在Insertion Sort List的Java提交中击败了49.22% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;﻿## 题目&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对链表进行插入排序。&lt;/p&gt;
&lt;p&gt;插入排序的动画演示如上。从第一个元素开始，该链表可以被认为已经部分排序（用黑色表示）。&lt;br&gt;每次迭代时，从输入数据中移除一个元素（用红色表示），并原地将其插入到已排好序的链表中。&lt;/
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode142. 环形链表 II</title>
    <link href="http://yoursite.com/2019/05/17/leetcode142.%20%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%20II/"/>
    <id>http://yoursite.com/2019/05/17/leetcode142. 环形链表 II/</id>
    <published>2019-05-16T16:17:21.751Z</published>
    <updated>2019-05-16T16:17:59.747Z</updated>
    
    <content type="html"><![CDATA[<h4 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">142. 环形链表 II</a></h4><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 <code>null</code>。</p><p>为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。</p><p><strong>说明：</strong>不允许修改给定的链表。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; 输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">&gt; 输出：tail connects to node index 1</span><br><span class="line">&gt; 解释：链表中有一个环，其尾部连接到第二个节点。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; 输入：head = [1,2], pos = 0</span><br><span class="line">&gt; 输出：tail connects to node index 0</span><br><span class="line">&gt; 解释：链表中有一个环，其尾部连接到第一个节点。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; 输入：head = [1], pos = -1</span><br><span class="line">&gt; 输出：no cycle</span><br><span class="line">&gt; 解释：链表中没有环。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img"></p><p><strong>进阶：</strong><br>你是否可以不用额外空间解决此题？</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li><p>可以使用一个集合set，然后遍历一遍链表，判断set中是否存在结点，如果存在则说明是该结点，如果不存在，则把结点放入set中，如果指针走到null，则说明没有环，返回null。</p></li><li><p>使用快慢指针的方法，这个方法有点难想到，快慢指针可以判断出链表中是否存在环，你使用快慢指针走一遍，可以发现，快慢指针相遇的结点到环开始的结点和head到环开始的结点是一样的长度的。</p><p>证明的结果如下（链表有环的情况）：</p><p>head到环开始的结点长度为L1，环的长度为L2，假设快慢指针相遇时，慢指针走的长度为x，则快指针走的长度为2x，因为快指针饶了环一圈再遇见满指针，所以2x-x=L2；</p><p>所以2x+L1=x+L1(上条公式转换来的)，因为两指针要在环开头相遇，只要快指针比满指针多走L2即可，所以两个指针再走L1即可。</p></li></ol><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public ListNode detectCycle(ListNode head) &#123;</span><br><span class="line">        if(head == null) return null;</span><br><span class="line">        if(head.next == null) return null;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        while(fast != null &amp;&amp; fast.next != null) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            if(slow == fast)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(slow == fast) &#123;</span><br><span class="line">            fast = head;</span><br><span class="line">            while(slow != fast)&#123;</span><br><span class="line">                fast = fast.next;</span><br><span class="line">                slow = slow.next;</span><br><span class="line">            &#125;</span><br><span class="line">            return fast;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功</p><p>显示详情 </p><p>执行用时 : 1 ms, 在Linked List Cycle II的Java提交中击败了98.83% 的用户</p><p>内存消耗 : 34.9 MB, 在Linked List Cycle II的Java提交中击败了25.93% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;142-环形链表-II&quot;&gt;&lt;a href=&quot;#142-环形链表-II&quot; class=&quot;headerlink&quot; title=&quot;142. 环形链表 II&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/linked-lis
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode304. 二维区域和检索 - 矩阵不可变</title>
    <link href="http://yoursite.com/2019/05/16/leetcode304.%20%E4%BA%8C%E7%BB%B4%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2%20-%20%E7%9F%A9%E9%98%B5%E4%B8%8D%E5%8F%AF%E5%8F%98/"/>
    <id>http://yoursite.com/2019/05/16/leetcode304. 二维区域和检索 - 矩阵不可变/</id>
    <published>2019-05-16T11:03:41.163Z</published>
    <updated>2019-05-16T11:04:59.819Z</updated>
    
    <content type="html"><![CDATA[<p>﻿## 题目</p><blockquote><p>给定一个二维矩阵，计算其子矩形范围内元素的总和，该子矩阵的左上角为 (row1, col1) ，右下角为 (row2, col2)。<br>//原题目也没有图 上图子矩阵左上角 (row1, col1) = (2, 1) ，右下角(row2, col2) = (4,<br>3)，该子矩形内元素的总和为 8。</p><p><strong>示例:</strong></p><p>给定 matrix = [   [3, 0, 1, 4, 2],   [5, 6, 3, 2, 1],   [1, 2, 0, 1, 5],<br>[4, 1, 0, 1, 7],   [1, 0, 3, 0, 5] ]</p><p>sumRegion(2, 1, 4, 3) -&gt; 8 sumRegion(1, 1, 2, 2) -&gt; 11 sumRegion(1, 2,<br>2, 4) -&gt; 12<br><strong>说明:</strong></p><p>你可以假设矩阵不可变。 会多次调用 sumRegion 方法。 你可以假设 row1 ≤ row2 且 col1 ≤ col2。</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>使用一个二维数组sum，sum[i, j]保存 <strong>matrix[0,0]到matrix[i,j]</strong> 的和，然后sumRegion方法返回 <strong>sum[row2][col2]-sum[row2][col1-1]-sum[row1-1][col2] + sum[row1-1][col1-1]</strong> 即可，思路很清晰简单。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">class NumMatrix &#123;</span><br><span class="line">    int[][] matrix;</span><br><span class="line">    int[][] sum ;</span><br><span class="line">    public NumMatrix(int[][] matrix) &#123;</span><br><span class="line">        if(matrix.length &lt;= 0 || matrix[0].length &lt;= 0) return ;</span><br><span class="line">        this.matrix = new int[matrix.length][matrix[0].length];</span><br><span class="line">        this.matrix =  matrix.clone();</span><br><span class="line">        this.init();</span><br><span class="line">    &#125;</span><br><span class="line">    public void init()&#123;</span><br><span class="line">        sum = new int[matrix.length][matrix[0].length];</span><br><span class="line">        sum[0][0] = matrix[0][0];</span><br><span class="line">        for(int i = 1; i &lt; sum[0].length; i ++)&#123;</span><br><span class="line">            sum[0][i] = matrix[0][i]+sum[0][i-1];       </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        for(int i = 1; i &lt; sum.length; i ++)&#123;</span><br><span class="line">            sum[i][0] = matrix[i][0] + sum[i-1][0];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        for(int i = 1; i &lt; sum.length; i ++)&#123;</span><br><span class="line">            for(int j = 1; j &lt; sum[i].length; j ++)&#123;</span><br><span class="line">                sum[i][j] = sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1] + matrix[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int sumRegion(int row1, int col1, int row2, int col2) &#123;</span><br><span class="line">    //越界判断，也可以sum数组再多一行一列，空间换时间--不用进行判断</span><br><span class="line">        if(row1 == 0 &amp;&amp; col1 == 0) &#123;</span><br><span class="line">            return sum[row2][col2];</span><br><span class="line">        &#125;</span><br><span class="line">        if(row1 == 0)&#123;</span><br><span class="line">            return sum[row2][col2]- sum[row2][col1 -1];</span><br><span class="line">        &#125;</span><br><span class="line">        if(col1 == 0)&#123;</span><br><span class="line">            return sum[row2][col2]- sum[row1-1][col2];</span><br><span class="line">        &#125;</span><br><span class="line">        return sum[row2][col2]-sum[row2][col1-1]-sum[row1-1][col2] + sum[row1-1][col1-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 127 ms, 在Range Sum Query 2D - Immutable的Java提交中击败了80.42% 的用户<br>内存消耗 : 46.6 MB, 在Range Sum Query 2D - Immutable的Java提交中击败了87.50% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;﻿## 题目&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个二维矩阵，计算其子矩形范围内元素的总和，该子矩阵的左上角为 (row1, col1) ，右下角为 (row2, col2)。&lt;br&gt;//原题目也没有图 上图子矩阵左上角 (row1, col1) = (2, 1)
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode152. 乘积最大子序列</title>
    <link href="http://yoursite.com/2019/05/13/leetcode152.%20%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>http://yoursite.com/2019/05/13/leetcode152. 乘积最大子序列/</id>
    <published>2019-05-13T15:59:58.034Z</published>
    <updated>2019-05-13T16:00:28.605Z</updated>
    
    <content type="html"><![CDATA[<h4 id="152-乘积最大子序列"><a href="#152-乘积最大子序列" class="headerlink" title="152. 乘积最大子序列"></a><a href="https://leetcode-cn.com/problems/maximum-product-subarray/" target="_blank" rel="noopener">152. 乘积最大子序列</a></h4><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数数组 <code>nums</code> ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,3,-2,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 子数组 [2,3] 有最大乘积 6。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [-2,0,-1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>使用2个数组，保存当前位置所能得到的最大值以及最小值，如果下一个位置的数组是负数，则乘最小值，整数乘最大值；需要注意判断如果乘上一个位置最大值之后是否比当前位置的值还小，则当前位置的最大值为当前的值，同理最小值也如此。</p><p>上面的思路我们可以发现，每次只需要根据上一个位置的最大值最小值我们就可以判断出当前位置所能得到的最大值和最小值，所以我们可以把2个数组简化为2个变量。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxProduct(int[] nums) &#123;</span><br><span class="line">        int len = nums.length;</span><br><span class="line">        int res = nums[0];</span><br><span class="line">        int nowMax = res;</span><br><span class="line">        int nowMin = res;</span><br><span class="line">        for (int i = 1; i &lt; len; i++) &#123;</span><br><span class="line">            if(nums[i] &lt; 0)&#123;</span><br><span class="line">            //负数则交换最大值最小值</span><br><span class="line">                nowMax = nowMin ^ nowMax;</span><br><span class="line">                nowMin = nowMax ^ nowMin;</span><br><span class="line">                nowMax = nowMax ^ nowMin;</span><br><span class="line">            &#125;</span><br><span class="line">            nowMax = Math.max(nums[i], nums[i]*nowMax);</span><br><span class="line">            nowMin = Math.min(nums[i], nums[i]*nowMin);</span><br><span class="line">            res = Math.max(res, nowMax);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功</p><p>显示详情 </p><p>执行用时 : 4 ms, 在Maximum Product Subarray的Java提交中击败了62.07% 的用户</p><p>内存消耗 : 35.9 MB, 在Maximum Product Subarray的Java提交中击败了54.02% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;152-乘积最大子序列&quot;&gt;&lt;a href=&quot;#152-乘积最大子序列&quot; class=&quot;headerlink&quot; title=&quot;152. 乘积最大子序列&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/maximum-pr
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>反射</title>
    <link href="http://yoursite.com/2019/05/13/%E5%8F%8D%E5%B0%84/"/>
    <id>http://yoursite.com/2019/05/13/反射/</id>
    <published>2019-05-13T15:54:01.440Z</published>
    <updated>2019-05-14T07:24:15.383Z</updated>
    
    <content type="html"><![CDATA[<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。</p><h3 id="创建Robot类"><a href="#创建Robot类" class="headerlink" title="创建Robot类"></a>创建Robot类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package reflect;</span><br><span class="line"></span><br><span class="line">public class Robot &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    public void sayHello(String name) &#123;</span><br><span class="line">        System.out.println(&quot;hello &quot; + name);</span><br><span class="line">    &#125;</span><br><span class="line">    private int throwMaxNumber(int[] nums) &#123;</span><br><span class="line">        int max = 0;</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            if (nums[i] &gt; max) &#123;</span><br><span class="line">                max = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line">    public void introduce()&#123;</span><br><span class="line">        System.out.println(&quot;my name is &quot; + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在通过forName和反射获取Robot类的所有方法和属性"><a href="#在通过forName和反射获取Robot类的所有方法和属性" class="headerlink" title="在通过forName和反射获取Robot类的所有方法和属性"></a>在通过forName和反射获取Robot类的所有方法和属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package reflect;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.lang.reflect.InvocationTargetException;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public class ReflectSample &#123;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException, InstantiationException, NoSuchFieldException &#123;</span><br><span class="line">        //通过类名获取Class对象</span><br><span class="line">        Class robot = Class.forName(&quot;reflect.Robot&quot;);</span><br><span class="line">        //通过Class对象的newInstance方法创建一个对象</span><br><span class="line">        Robot r = (Robot) robot.newInstance();</span><br><span class="line">        //获取Class对象中的sayHello方法，该方法需要传入一个String参数</span><br><span class="line">//        Method sayHello = robot.getDeclaredMethod(&quot;sayHello&quot;, String.class);</span><br><span class="line">        Method sayHello = robot.getMethod(&quot;sayHello&quot;, String.class);</span><br><span class="line">        //通过反射机制执行该方法,传入参数： 丁先生</span><br><span class="line">        Object sayHelloOut = sayHello.invoke(r, &quot;丁先生&quot;);</span><br><span class="line">        //输出该方法返回的值</span><br><span class="line">//        System.out.println(sayHelloOut);</span><br><span class="line"></span><br><span class="line">        //获取对象中的private方法需要使用getDeclaredMethod获取</span><br><span class="line">        Method throwMaxNumber = robot.getDeclaredMethod(&quot;throwMaxNumber&quot;, int[].class);</span><br><span class="line">        //默认Accessible是false 需要设置为true,因为方法是私有的</span><br><span class="line">        throwMaxNumber.setAccessible(true);</span><br><span class="line">        Object invoke = throwMaxNumber.invoke(r, new int[]&#123;3, 5, 2, 6, 1&#125;);</span><br><span class="line">        System.out.println(invoke);</span><br><span class="line"></span><br><span class="line">        //设置r中的私有变量</span><br><span class="line">        Field name = robot.getDeclaredField(&quot;name&quot;);</span><br><span class="line">        //同私有方法也是要设置accessible为true</span><br><span class="line">        name.setAccessible(true);</span><br><span class="line">        name.set(r, &quot;陈先生&quot;);</span><br><span class="line">        Method introduce = robot.getMethod(&quot;introduce&quot;);</span><br><span class="line">        introduce.invoke(r);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="执行的输出结果"><a href="#执行的输出结果" class="headerlink" title="执行的输出结果"></a>执行的输出结果</h4><p><img src="C:\Users\xin\AppData\Roaming\Typora\typora-user-images\1557762815500.png" alt="1557762815500"></p><h3 id="通过classLoader获取Class对象"><a href="#通过classLoader获取Class对象" class="headerlink" title="通过classLoader获取Class对象"></a>通过classLoader获取Class对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package reflect;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.InvocationTargetException;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public class ClassLoaderTest &#123;</span><br><span class="line">    public static void main(String[] args) throws IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException, ClassNotFoundException &#123;</span><br><span class="line">        ClassLoader classLoader = Robot.class.getClassLoader();</span><br><span class="line">        Class robot = classLoader.loadClass(&quot;reflect.Robot&quot;);</span><br><span class="line">//      Class robot2 = Class.forName(&quot;reflect.Robot&quot;);</span><br><span class="line">        Robot r = (Robot) robot.newInstance();</span><br><span class="line">        Method introduce = robot.getMethod(&quot;introduce&quot;);</span><br><span class="line">        Object invoke = introduce.invoke(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;反射&quot;&gt;&lt;a href=&quot;#反射&quot; class=&quot;headerlink&quot; title=&quot;反射&quot;&gt;&lt;/a&gt;反射&lt;/h2&gt;&lt;p&gt;JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获
      
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 139. 单词拆分</title>
    <link href="http://yoursite.com/2019/05/13/leetcode%20139.%20%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/"/>
    <id>http://yoursite.com/2019/05/13/leetcode 139. 单词拆分/</id>
    <published>2019-05-13T12:14:07.077Z</published>
    <updated>2019-05-13T12:13:58.387Z</updated>
    
    <content type="html"><![CDATA[<p>﻿## 题目</p><blockquote><p>给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</p><p><strong>说明：</strong></p><p>拆分时可以重复使用字典中的单词。 你可以假设字典中没有重复的单词。<br><strong>示例 1：</strong></p><p><strong>输入:</strong> s = “leetcode”, wordDict = [“leet”, “code”]<br><strong>输出:</strong> true<br><strong>解释:</strong> 返回 true 因为 “leetcode” 可以被拆分成 “leet code”。<br><strong>示例 2：</strong></p><p><strong>输入:</strong> s = “applepenapple”, wordDict = [“apple”, “pen”]<br><strong>输出:</strong> true<br><strong>解释:</strong> 返回 true 因为 “applepenapple” 可以被拆分成 “apple pen apple”。<br>     注意你可以重复使用字典中的单词。<br><strong>示例 3：</strong></p><p><strong>输入:</strong> s = “catsandog”, wordDict = [“cats”, “dog”, “sand”, “and”, “cat”]<br><strong>输出:</strong> false</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>使用一个布尔数组dp，<strong>dp[i]表示s.substring(0,i)是可以由wordDic中的单词组合而来的</strong>，遍历单词可能的组成，如果s.substring(i,j)存在于wordDict中，则dp[j]=dp[i]的值，即等于s.substring(0,i)能否由wordDic中的单词组成。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123;</span><br><span class="line">        int len = s.length();</span><br><span class="line">        boolean[] dp = new boolean[len+1];</span><br><span class="line">        dp[0] = true;</span><br><span class="line">        //dp[i]记录s.substring(0,i+1)是可以由wordDic组合而来的</span><br><span class="line">        for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">            for (int j = i+1; j &lt;= len; j++) &#123;</span><br><span class="line">                if(wordDict.contains(s.substring(i,j)))&#123;</span><br><span class="line">                    if(dp[j]) continue;</span><br><span class="line"></span><br><span class="line">                    dp[j] = dp[i];</span><br><span class="line">                    if (dp[len]) return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[len];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>36 / 36 个通过测试用例<br>状态：通过<br>执行用时：7 ms</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;﻿## 题目&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;拆分时可以重复使
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode138. 复制带随机指针的链表</title>
    <link href="http://yoursite.com/2019/05/13/leetcode138.%20%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2019/05/13/leetcode138. 复制带随机指针的链表/</id>
    <published>2019-05-13T08:19:59.319Z</published>
    <updated>2019-05-13T08:22:52.517Z</updated>
    
    <content type="html"><![CDATA[<h4 id="138-复制带随机指针的链表"><a href="#138-复制带随机指针的链表" class="headerlink" title="138. 复制带随机指针的链表"></a><a href="https://leetcode-cn.com/problems/copy-list-with-random-pointer/" target="_blank" rel="noopener">138. 复制带随机指针的链表</a></h4><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。</p><p>要求返回这个链表的<strong>深拷贝</strong>。 </p><p><strong>示例：</strong></p><p><strong><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/23/1470150906153-2yxeznm.png" alt="img"></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; 输入：</span><br><span class="line">&gt; &#123;&quot;$id&quot;:&quot;1&quot;,&quot;next&quot;:&#123;&quot;$id&quot;:&quot;2&quot;,&quot;next&quot;:null,&quot;random&quot;:&#123;&quot;$ref&quot;:&quot;2&quot;&#125;,&quot;val&quot;:2&#125;,&quot;random&quot;:&#123;&quot;$ref&quot;:&quot;2&quot;&#125;,&quot;val&quot;:1&#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; 解释：</span><br><span class="line">&gt; 节点 1 的值是 1，它的下一个指针和随机指针都指向节点 2 。</span><br><span class="line">&gt; 节点 2 的值是 2，它的下一个指针指向 null，随机指针指向它自己。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><strong>提示：</strong></p><ol><li>你必须返回<strong>给定头的拷贝</strong>作为对克隆列表的引用。</li></ol></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>用一个map保存原来node对应的newNode</p><p>从头开始，创建一个新的结点，先把它put到map中，然后继续创建它的下一个结点和随机指针指向的结点，遍历到底即可。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public Node copyRandomList(Node head) &#123;</span><br><span class="line">        HashMap&lt;Node, Node&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        return helper(head, map);</span><br><span class="line">    &#125;</span><br><span class="line">    public Node helper(Node node, Map&lt;Node, Node&gt; map) &#123;</span><br><span class="line">        if (node == null) return null;</span><br><span class="line">        if (map.containsKey(node)) &#123;</span><br><span class="line">            return map.get(node);</span><br><span class="line">        &#125;</span><br><span class="line">        Node newNode = new Node(node.val, null, null);</span><br><span class="line">        map.put(node, newNode);</span><br><span class="line">        if(node.next != null) &#123;</span><br><span class="line">            newNode.next = helper(node.next, map);</span><br><span class="line">        &#125;</span><br><span class="line">        if(node.random != null) &#123;</span><br><span class="line">            newNode.random = helper(node.random, map);</span><br><span class="line">        &#125;</span><br><span class="line">        return newNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功</p><p>显示详情 </p><p>执行用时 : 3 ms, 在Copy List with Random Pointer的Java提交中击败了27.10% 的用户</p><p>内存消耗 : 33.8 MB, 在Copy List with Random Pointer的Java提交中击败了71.29% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;138-复制带随机指针的链表&quot;&gt;&lt;a href=&quot;#138-复制带随机指针的链表&quot; class=&quot;headerlink&quot; title=&quot;138. 复制带随机指针的链表&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/c
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode134. 加油站</title>
    <link href="http://yoursite.com/2019/05/13/leetcode134.%20%E5%8A%A0%E6%B2%B9%E7%AB%99/"/>
    <id>http://yoursite.com/2019/05/13/leetcode134. 加油站/</id>
    <published>2019-05-13T07:59:02.985Z</published>
    <updated>2019-05-13T08:23:13.358Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。</p><p>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i]<br>升。你从其中的一个加油站出发，开始时油箱为空。</p><p>如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。</p><p><strong>说明:</strong> </p><p>如果题目有解，该答案即为唯一答案。 输入数组均为非空数组，且长度相同。 输入数组中的元素均为非负数。<br><strong>示例 1:</strong></p><p><strong>输入:</strong>  gas  = [1,2,3,4,5] cost = [3,4,5,1,2]</p><p><strong>输出: 3</strong></p><p><strong>解释:</strong> 从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油 开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油 开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油 开往 1<br>号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油 开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油 开往 3<br>号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。 因此，3 可为起始索引。<br><strong>示例 2:</strong></p><p><strong>输入:</strong>  gas  = [2,3,4] cost = [3,4,3]</p><p><strong>输出:</strong> -1</p><p><strong>解释:</strong> 你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。 我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油 开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油 开往 1<br>号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油 你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3<br>升汽油。 因此，无论怎样，你都不可能绕环路行驶一周。</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>oil[i]为到达i油站时剩余的油量<br>len为一共有多少个油站<br>sum为从头到尾所剩余的油量<br>可以看出来<br>假设该题目有解，则会<strong>存在sum&gt;0，并且从oil[res]+oil[len-1]&gt;0;</strong><br>如果没解则会有 <strong>sum&lt;0</strong>。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int canCompleteCircuit(int[] gas, int[] cost) &#123;</span><br><span class="line">        int len = gas.length;</span><br><span class="line">        if (len == 1) &#123;</span><br><span class="line">            return gas[0] - cost[0] &gt;= 0 ? 0: -1;</span><br><span class="line">        &#125;</span><br><span class="line">        //保存每个油站所能剩余的油量</span><br><span class="line">        int[] oil = new int[len];</span><br><span class="line">        for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">            oil[i] = gas[i] - cost[i];</span><br><span class="line">        &#125;</span><br><span class="line">        int sum = 0;//从头到尾的油量，如果最后小于0则说明饶不了一圈</span><br><span class="line">        int res = 0;//开始出发的油站</span><br><span class="line">        int nowOil = 0;//开始出发的油站到当前剩下的油</span><br><span class="line">        for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">            sum += oil[i];</span><br><span class="line">            nowOil += oil[i];</span><br><span class="line">            if(nowOil &lt; 0) &#123;</span><br><span class="line">                nowOil = 0;</span><br><span class="line">                res = i+1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(sum &lt; 0) &#123;</span><br><span class="line">            return  -1;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 1 ms, 在Gas Station的Java提交中击败了93.51% 的用户<br>内存消耗 : 36.8 MB, 在Gas Station的Java提交中击败了91.99% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。&lt;/p&gt;
&lt;p&gt;你有一辆油箱容量无限的
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>数据库学习</title>
    <link href="http://yoursite.com/2019/05/13/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://yoursite.com/2019/05/13/数据库/</id>
    <published>2019-05-13T00:24:29.971Z</published>
    <updated>2019-05-13T08:22:25.048Z</updated>
    
    <content type="html"><![CDATA[<h2 id="索引模块"><a href="#索引模块" class="headerlink" title="索引模块"></a>索引模块</h2><h3 id="为什么要使用索引"><a href="#为什么要使用索引" class="headerlink" title="为什么要使用索引"></a>为什么要使用索引</h3><p>避免全表扫描去查找数据，提升检索效率</p><h3 id="什么样的信息能成为索引"><a href="#什么样的信息能成为索引" class="headerlink" title="什么样的信息能成为索引"></a>什么样的信息能成为索引</h3><p>主键、唯一键等能区分数据的字段</p><h3 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h3><p>主流是B+树，还有哈希结构以及BitMap，其中MySQL不支持BitMap索引，基于InnoDB以及MyISAM的MySQL不显式支持哈希索引</p><h3 id="密集索引和稀疏索引的区别"><a href="#密集索引和稀疏索引的区别" class="headerlink" title="密集索引和稀疏索引的区别"></a>密集索引和稀疏索引的区别</h3><p>密集索引文件中的每个搜索码都对应一个索引值</p><p>稀疏索引文件只为索引码的某些值建立索引项</p><h3 id="如何定位并优化慢查询sql"><a href="#如何定位并优化慢查询sql" class="headerlink" title="如何定位并优化慢查询sql"></a>如何定位并优化慢查询sql</h3><p>根据慢日志定位慢查询sql语句</p><p>使用explain 等工具分析sql</p><p>修改sql或者尽量让sql走索引；<strong>force index()</strong> <strong>强制走某个索引</strong></p><h3 id="索引是建立得越多越好吗"><a href="#索引是建立得越多越好吗" class="headerlink" title="索引是建立得越多越好吗"></a>索引是建立得越多越好吗</h3><p>数据量小的表不需要建立索引，建立会增加额外的索引开销</p><p>数据变更需要维护索引，隐藏更多的索引意味着更多的维护成本</p><p>更多的索引意味着也需要更多的空间</p><h2 id="数据库锁"><a href="#数据库锁" class="headerlink" title="数据库锁"></a>数据库锁</h2><h3 id="MyISAM和InnoDB关于锁方面的区别是什么"><a href="#MyISAM和InnoDB关于锁方面的区别是什么" class="headerlink" title="MyISAM和InnoDB关于锁方面的区别是什么"></a>MyISAM和InnoDB关于锁方面的区别是什么</h3><p>MyISAM默认使用的是表级锁，不支持行级锁</p><p>InnoDB默认用的是行级锁，也支持表级锁</p><h4 id="MyISAM适合的场景"><a href="#MyISAM适合的场景" class="headerlink" title="MyISAM适合的场景"></a>MyISAM适合的场景</h4><p>1.频繁执行全表count语句</p><p>2.对数据进行增删改的频率不高，查询非常频繁</p><p>3.没有事务</p><h4 id="InnoDB适合的场景"><a href="#InnoDB适合的场景" class="headerlink" title="InnoDB适合的场景"></a>InnoDB适合的场景</h4><p>1.数据增删改查都相当频繁</p><p>2.可靠性要求比较高，要求支持事务</p><h3 id="数据库锁的分类"><a href="#数据库锁的分类" class="headerlink" title="数据库锁的分类"></a>数据库锁的分类</h3><ul><li>按锁的粒度划分，可分为表级锁、行级锁、页级锁</li><li>按锁级别划分，可分为共享锁、排它锁</li><li>按加锁方式划分，可分为自动锁，显式锁</li><li>按操作划分，可分为DML锁、DDL锁</li><li>按使用方式划分，可分为乐观锁、悲观锁</li></ul><h3 id="事务隔离级别以及各级别下的并发访问问题"><a href="#事务隔离级别以及各级别下的并发访问问题" class="headerlink" title="事务隔离级别以及各级别下的并发访问问题"></a>事务隔离级别以及各级别下的并发访问问题</h3><ul><li>更新丢失—-mysql所有事务隔离级别在数据库层面上均可避免</li><li>脏读——read-committed事务隔离级别以上可避免</li><li>不可重复读——repeatable-read事务隔离级别以上可避免</li><li>幻读—–serializable事务隔离级别可避免</li></ul><h2 id="MySQL语法"><a href="#MySQL语法" class="headerlink" title="MySQL语法"></a>MySQL语法</h2><h3 id="GROUP-BY"><a href="#GROUP-BY" class="headerlink" title="GROUP BY"></a>GROUP BY</h3><ul><li><p>[ ] 满足select选出的列<strong>要么是group by的列要么是sum，max等列函数中的列(针对一张表)</strong>。</p></li><li><p>[ ] 列函数对于group by子句定义的每个组各返回一个结果</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#查询所有同学的学号、选课数、总成绩</span><br><span class="line">select student_id, count(course_id), sum(score)</span><br><span class="line">from score</span><br><span class="line">group by student_id</span><br></pre></td></tr></table></figure><h3 id="HAVING"><a href="#HAVING" class="headerlink" title="HAVING"></a>HAVING</h3><ul><li style="list-style: none"><input type="checkbox"> 通常与GROUP BY子句一起使用</li><li style="list-style: none"><input type="checkbox"> WHERE过滤行，HAVING过滤组</li><li style="list-style: none"><input type="checkbox"> 出现在同一sql的顺序：WHERE &gt; GROUP UP &gt; HAVING</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#查询平均成绩大于60的同学的学号和平均成绩</span><br><span class="line">select student_id, avg(score)</span><br><span class="line">from score</span><br><span class="line">group by student_id,</span><br><span class="line">having avg(score)&gt;60</span><br><span class="line"></span><br><span class="line">#取出student_id为1的学生的成绩情况</span><br><span class="line">select * from score where student_id = 1;</span><br><span class="line">#如果省略group by子句，having子句行为跟where一样</span><br><span class="line">select * from score having student_id = 1;</span><br></pre></td></tr></table></figure><p>查询没有学全所有课的同学的学号、姓名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select stu.student_id, stu.name</span><br><span class="line">from score s, student stu</span><br><span class="line">where stu.student_id = s.student_id</span><br><span class="line">group by s.student_id</span><br><span class="line">having count(*) &lt;</span><br><span class="line">(</span><br><span class="line">select count(*) from course</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>查询表中name的数据，并且desc是降序排序，asc是升序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name from student order by name desc;</span><br></pre></td></tr></table></figure><p>查询表中id从1到2000000的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from table_name where id between 1 and 2000000;</span><br></pre></td></tr></table></figure><p>更新表中的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update table_name set account = newAccount  where id between 1 and 2000000;</span><br></pre></td></tr></table></figure><p>给表加锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock tables table_name read | write;</span><br></pre></td></tr></table></figure><p>释放锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unlock tables;</span><br></pre></td></tr></table></figure><p>查询事务隔离级别</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select @@tx_isolation;</span><br></pre></td></tr></table></figure><p>修改事务隔离级别为read-committed，可以避免脏读，不可以避免不可重复读</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;</span><br></pre></td></tr></table></figure><p>开始事务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">START TRANSACTION;</span><br></pre></td></tr></table></figure><p>回滚事务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROLLBACK;</span><br></pre></td></tr></table></figure><p>提交事务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COMMIT;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;索引模块&quot;&gt;&lt;a href=&quot;#索引模块&quot; class=&quot;headerlink&quot; title=&quot;索引模块&quot;&gt;&lt;/a&gt;索引模块&lt;/h2&gt;&lt;h3 id=&quot;为什么要使用索引&quot;&gt;&lt;a href=&quot;#为什么要使用索引&quot; class=&quot;headerlink&quot; title=&quot;为
      
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
</feed>
