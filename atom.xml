<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>白哥的博客</title>
  
  <subtitle>白哥的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-20T12:06:06.954Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>白哥</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode24. 两两交换链表中的节点</title>
    <link href="http://yoursite.com/2019/04/20/leetcode24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"/>
    <id>http://yoursite.com/2019/04/20/leetcode24-两两交换链表中的节点/</id>
    <published>2019-04-20T12:05:40.000Z</published>
    <updated>2019-04-20T12:06:06.954Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p></blockquote><blockquote><p><strong>示例:</strong></p><p>给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>直接两两互换一直遍历到最后即可。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode swapPairs(ListNode head) &#123;</span><br><span class="line">if(head == null) return null;</span><br><span class="line">        ListNode p = head;</span><br><span class="line">        ListNode q = head.next;</span><br><span class="line">        ListNode pre = head;</span><br><span class="line">        while(q != null) &#123;</span><br><span class="line">        p.next = q.next;</span><br><span class="line">        q.next = p;</span><br><span class="line">        //如果是第一个，则pre不用指向q，而且要更新head</span><br><span class="line">        if(p == head) &#123;</span><br><span class="line">        head = q;</span><br><span class="line">        pre = head.next;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">        pre.next = q;</span><br><span class="line">        pre = p;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p.next;</span><br><span class="line">        //q在p之后，如果p已经null则可以直接结束</span><br><span class="line">        if(p == null) break;</span><br><span class="line">        q = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 1 ms, 在Swap Nodes in Pairs的Java提交中击败了97.35% 的用户<br>内存消耗 : 33.4 MB, 在Swap Nodes in Pairs的Java提交中击败了98.47% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。&lt;/p&gt;
&lt;p&gt;你不能只是单纯的改变节点内部的值，而是需
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode29. 两数相除</title>
    <link href="http://yoursite.com/2019/04/20/leetcode29-%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4/"/>
    <id>http://yoursite.com/2019/04/20/leetcode29-两数相除/</id>
    <published>2019-04-20T12:04:49.000Z</published>
    <updated>2019-04-20T12:05:52.731Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。</p><p>返回被除数 dividend 除以除数 divisor 得到的商。</p><p><strong>示例 1:</strong></p><p><strong>输入:</strong> dividend = 10, divisor = 3<br><strong>输出:</strong> 3<br> <strong>示例 2:</strong></p><p><strong>输入:</strong> dividend = 7, divisor = -3<br><strong>输出:</strong> -2<br> <strong>说明:</strong></p><p>被除数和除数均为 32 位有符号整数。 除数不为 0。 假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231,  231 −<br>1]。本题中，如果除法结果溢出，则返回 231 − 1。</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>一开始的解题思路是直接用减法去实现，每次都减去除数，然后递归调用，结果在边界值爆了。<br>看了一下评论区的提示后，使用了移位运算解答此题。<br>dividend&lt;&lt;i相当于dividend除以2^i;<br>dividend&lt;<i \>=divisor就是disisor*2^n &lt;dividend;<br>由此来进行减法，可以大大的缩减运算时间。</i></p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int divide(int dividend, int divisor) &#123;</span><br><span class="line">        if(divisor == 1) return dividend;</span><br><span class="line">        if(dividend == Integer.MIN_VALUE &amp;&amp; divisor == -1) return Integer.MAX_VALUE;</span><br><span class="line">int res = 0;</span><br><span class="line">        int flag = (dividend^divisor) &lt; 0 ? -1 : 1;</span><br><span class="line">        long newDividend = Math.abs((long)dividend);</span><br><span class="line">        long newDivisor = Math.abs((long)divisor);</span><br><span class="line">        for(int i = 31; i &gt;= 0; i--) &#123;</span><br><span class="line">        if(newDividend&gt;&gt;i &gt;= newDivisor) &#123;</span><br><span class="line">        res += 1&lt;&lt;i;</span><br><span class="line">        newDividend -= newDivisor&lt;&lt;i;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return flag &gt; 0? res : -res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 6 ms, 在Divide Two Integers的Java提交中击败了95.78% 的用户<br>内存消耗 : 33.6 MB, 在Divide Two Integers的Java提交中击败了76.86% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode19. 删除链表的倒数第N个节点</title>
    <link href="http://yoursite.com/2019/04/20/leetcode19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <id>http://yoursite.com/2019/04/20/leetcode19-删除链表的倒数第N个节点/</id>
    <published>2019-04-20T04:40:26.000Z</published>
    <updated>2019-04-20T04:40:59.247Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p><p><strong>示例：</strong></p><p>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.</p><p>当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5. 说明：</p><p>给定的 n 保证是有效的。</p><p><strong>进阶：</strong></p><p>你能尝试使用一趟扫描实现吗？</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>本来自己的思路一上来就是遍历出他的长度，然后删掉第len-n个结点；但是看到了进阶中的使用一趟扫描，在舍友的提醒下使用了一个移动窗口实现。<br><strong>方法：</strong>定义2个指针pre、next，next是pre的后面第n个结点，如果next已经是链表的结尾，即删除pre结点；如若不是，则pre和next一起往后移动，直到结尾。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode removeNthFromEnd(ListNode head, int n) &#123;</span><br><span class="line">        ListNode pre = head;</span><br><span class="line">        ListNode ppre = head;</span><br><span class="line">        ListNode next = head;</span><br><span class="line">        for(int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">        next = next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        while(next.next != null) &#123;</span><br><span class="line">        if(pre != head) </span><br><span class="line">        ppre = ppre.next;</span><br><span class="line">        pre = pre.next;</span><br><span class="line">        next = next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        if(pre == head) &#123;</span><br><span class="line">        return head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ppre.next = pre.next;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 2 ms, 在Remove Nth Node From End of List的Java提交中击败了97.20% 的用户<br>内存消耗 : 34.4 MB, 在Remove Nth Node From End of List的Java提交中击败了89.63% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/str
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode22.括号生成</title>
    <link href="http://yoursite.com/2019/04/20/leetcode22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/"/>
    <id>http://yoursite.com/2019/04/20/leetcode22-括号生成/</id>
    <published>2019-04-20T04:39:40.000Z</published>
    <updated>2019-04-20T04:40:35.469Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。</p><p><strong>例如</strong>，给出 n = 3，<br>生成结果为：</p><p>[   “((()))”,   “(()())”,   “(())()”,   “()(())”,   “()()()” ]</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>我自己的思路首先的采用分治递归的方法，把每个问题都分为子问题(i)+(n-i)来解决，每次把子问题生成的括号相加，就是最终的结果，这个思路很容易想懂，不多解释。<br>看了一下别人的解题代码，是利用dfs去解答的。<br>记录左右括号的个数，如果左括号比右括号大，就<strong>加入一个右括号或左括号</strong>，当<strong>左括号右括号个数大于n</strong>的话说明这字符串不符合要求，return掉。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><p><strong>自己的解法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;String&gt; generateParenthesis(int n) &#123;</span><br><span class="line">        Set&lt;String&gt; res = new HashSet&lt;&gt;();</span><br><span class="line">        if(n == 1) &#123;</span><br><span class="line">        res.add(&quot;()&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">        for(int i = 1; i &lt;= n/2; i ++) &#123;</span><br><span class="line">        List&lt;String&gt; list1 = generateParenthesis(i);</span><br><span class="line">        List&lt;String&gt; list2 = generateParenthesis(n-i);</span><br><span class="line">        for(String s1: list1) &#123;</span><br><span class="line">        for(String s2: list2) &#123;</span><br><span class="line">        if(i==1) res.add(&quot;(&quot;+s2+&quot;)&quot;);</span><br><span class="line">                res.add(s1+s2);</span><br><span class="line">                res.add(s2+s1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return new ArrayList&lt;&gt;(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>利用dfs解法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;String&gt; generateParenthesis(int n) &#123;</span><br><span class="line">        List&lt;String&gt; res = new ArrayList&lt;&gt;(1000);</span><br><span class="line">        dfs(n, 0, 0, &quot;&quot;, res);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">public void dfs(int n, int l, int r, String s, List&lt;String&gt; list) &#123;</span><br><span class="line">if(l &gt; n || r &gt; n) return;</span><br><span class="line">if(l ==n &amp;&amp; r == n) list.add(s.toString());</span><br><span class="line">if(l &gt;= r) &#123;</span><br><span class="line">dfs(n, l+1, r, s + &quot;(&quot;, list);</span><br><span class="line">dfs(n, l, r+1,  s + &quot;)&quot;, list);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 2 ms, 在Generate Parentheses的Java提交中击败了96.81% 的用户<br>内存消耗 : 37.7 MB, 在Generate Parentheses的Java提交中击败了73.49% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。&lt;/p&gt;
&lt;p&gt;&lt;str
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode18. 四数之和</title>
    <link href="http://yoursite.com/2019/04/20/leetcode18-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://yoursite.com/2019/04/20/leetcode18-四数之和/</id>
    <published>2019-04-20T04:39:28.939Z</published>
    <updated>2019-04-20T04:39:53.092Z</updated>
    
    <content type="html"><![CDATA[<h2 id><a href="#" class="headerlink" title="??"></a>??</h2><blockquote><p>?????? n ?????? nums ?????? target,?? nums ????????? a,b,c ? d ,?? a +<br>b + c + d ??? target ????????????????????</p><p><strong>??:</strong></p><p>???????????????</p><p><strong>??:</strong></p><p>???? nums = [1, 0, -1, 0, -2, 2],? target = 0?</p><p>???????????: [   [-1,  0, 0, 1],   [-2, -1, 1, 2],   [-2,  0, 0, 2] ]</p></blockquote><h2 id="-1"><a href="#-1" class="headerlink" title="????"></a>????</h2><p>????????????,?????????????</p><h2 id="-2"><a href="#-2" class="headerlink" title="????"></a>????</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123;</span><br><span class="line">        if(nums.length &lt; 4) &#123;</span><br><span class="line">return new ArrayList&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line">Arrays.sort(nums);</span><br><span class="line">//??set??</span><br><span class="line">Set&lt;List&lt;Integer&gt;&gt; set = new HashSet&lt;&gt;();</span><br><span class="line">for(int a = 0; a &lt; nums.length-3; a ++) &#123;</span><br><span class="line">//????</span><br><span class="line">if(nums[a] + nums[nums.length-1] +nums[nums.length-2]+nums[nums.length-3] &lt; target) &#123;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">if(nums[a] + nums[a+1] +nums[a+2]+nums[a+3] &gt; target) &#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">if(a&gt;0 &amp;&amp; nums[a] == nums[a-1]) &#123;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">for(int b = nums.length-1; b &gt; a; b--) &#123;</span><br><span class="line">int c = a+1, d = b-1;</span><br><span class="line">while(c &lt; d) &#123;</span><br><span class="line">int tmp = nums[a] + nums[b] + nums[c] + nums[d];</span><br><span class="line">if(tmp == target) &#123;</span><br><span class="line">List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">list.add(nums[a]);list.add(nums[b]);list.add(nums[c]);list.add(nums[d]);</span><br><span class="line">set.add(list);</span><br><span class="line">c++;d--;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">else if(tmp &lt; target) &#123;</span><br><span class="line">c++;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">d--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return new ArrayList&lt;&gt;(set);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="-3"><a href="#-3" class="headerlink" title="????"></a>????</h2><p>??<br>????<br>???? : 20 ms, ?4Sum?Java??????96.47% ???<br>???? : 37.5 MB, ?4Sum?Java??????94.30% ???</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;??&quot;&gt;&lt;/a&gt;??&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;?????? n ?????? nums ?????? target,?? nums ????????? a,b,c ? d ,
      
    
    </summary>
    
      <category term="??" scheme="http://yoursite.com/categories//"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode16. 最接近的三数之和</title>
    <link href="http://yoursite.com/2019/04/19/leetcode16-%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://yoursite.com/2019/04/19/leetcode16-最接近的三数之和/</id>
    <published>2019-04-19T13:25:24.000Z</published>
    <updated>2019-04-19T13:25:53.127Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target<br>最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p><p>例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.</p><p>与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>我的思路是直接暴力解了，没想到更好的办法，时间复杂度为O(n²)。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int threeSumClosest(int[] nums, int target) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        int res = Integer.MAX_VALUE;</span><br><span class="line">        boolean flag = false;</span><br><span class="line">        for(int i = 0; i &lt; nums.length - 2; i ++) &#123;</span><br><span class="line">        int left = i+1, right = nums.length-1;</span><br><span class="line">        while(left &lt; right) &#123;</span><br><span class="line">            int tmp = nums[i] + nums[left] + nums[right];</span><br><span class="line">            if(tmp == target) &#123;</span><br><span class="line">        res = 0;</span><br><span class="line">        flag = true;</span><br><span class="line">        break;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(tmp &gt; target) &#123;</span><br><span class="line">        res = Math.abs(tmp - target) &gt; Math.abs(res) ? res : tmp - target;</span><br><span class="line">        right--;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">        res = Math.abs(tmp - target) &gt; Math.abs(res) ? res : tmp - target;</span><br><span class="line">        left++;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(flag) break;</span><br><span class="line">        &#125;</span><br><span class="line">        return target + res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 17 ms, 在3Sum Closest的Java提交中击败了75.39% 的用户<br>内存消耗 : 35.5 MB, 在3Sum Closest的Java提交中击败了87.66% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode856. 括号的分数</title>
    <link href="http://yoursite.com/2019/04/19/leetcode856-%E6%8B%AC%E5%8F%B7%E7%9A%84%E5%88%86%E6%95%B0/"/>
    <id>http://yoursite.com/2019/04/19/leetcode856-括号的分数/</id>
    <published>2019-04-19T13:25:13.000Z</published>
    <updated>2019-04-19T13:25:40.824Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个平衡括号字符串 S，按下述规则计算该字符串的分数：</p><p>() 得 1 分。 AB 得 A + B 分，其中 A 和 B 是平衡括号字符串。 (A) 得 2 * A 分，其中 A 是平衡括号字符串。<br>示例 1：<br>输入： “()” 输出： 1<br>示例 2：<br>输入： “(())” 输出： 2<br>示例 3：<br>输入： “()()” 输出： 2<br>示例 4：<br>输入： “(()(()))” 输出： 6  </p><p>提示：</p><p>S 是平衡括号字符串，且只含有 ( 和 ) 。 2 &lt;= S.length &lt;= 50</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>遇到括号的题目首先想到了利用栈匹配括号。<br>遍历一遍字符串，如果是’(‘，就压栈；若不是，则分2种情况<br>⑴如果栈顶是’(‘,则                                                                                                                                                                                                                                                     往栈顶把pop(‘(‘),push(1)<br>⑵如果不是，则把不是’(‘的元素全部pop并加起来，最后pop(‘(‘) 并push(sum)。<br>最后返回栈内所有元素的总和。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int scoreOfParentheses(String S) &#123;</span><br><span class="line">if(S.length() &lt; 2) return 0;</span><br><span class="line">        int[] stack = new int[S.length()];</span><br><span class="line">        int top = -1;</span><br><span class="line">        for(int i = 0; i &lt; S.length(); i++) &#123;</span><br><span class="line">        char temp = S.charAt(i);</span><br><span class="line">        if(temp == &apos;(&apos;) </span><br><span class="line">        stack[++top] = &apos;(&apos;;</span><br><span class="line">        else &#123;</span><br><span class="line">        int cnt = 0;</span><br><span class="line">        if(stack[top]==&apos;(&apos;) &#123;</span><br><span class="line">        stack[top] = 1;</span><br><span class="line">        continue;</span><br><span class="line">        &#125;</span><br><span class="line">        while(stack[top] != &apos;(&apos;)</span><br><span class="line">        cnt += stack[top--];</span><br><span class="line">        stack[top] = cnt * 2 ;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int res = 0;</span><br><span class="line">        while(top &gt;= 0) </span><br><span class="line">        res += stack[top--];</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 1 ms, 在Score of Parentheses的Java提交中击败了100.00% 的用户<br>内存消耗 : 33.3 MB, 在Score of Parentheses的Java提交中击败了94.55% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个平衡括号字符串 S，按下述规则计算该字符串的分数：&lt;/p&gt;
&lt;p&gt;() 得 1 分。 AB 得 A + B
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode12. 整数转罗马数字</title>
    <link href="http://yoursite.com/2019/04/19/leetcode12-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/"/>
    <id>http://yoursite.com/2019/04/19/leetcode12-整数转罗马数字/</id>
    <published>2019-04-19T13:24:33.000Z</published>
    <updated>2019-04-19T13:24:54.804Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。<br>字符          数值 I             1 V             5 X             10 L<br>50 C             100 D             500 M             1000 例如， 罗马数字 2<br>写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5<br>的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p><p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示<br>40 和 90。  C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。<br>示例 1:<br>输入: 3<br>输出: “III”<br> 示例 2:<br>输入: 4<br>输出: “IV”<br>示例 3:<br>输入: 9<br>输出: “IX”<br>示例 4:<br>输入: 58<br>输出: “LVIII”<br> 解释: L = 50, V = 5, III = 3.<br> 示例 5:<br>输入: 1994<br>输出: “MCMXCIV”<br>解释: M = 1000, CM = 900, XC = 90, IV = 4.</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>把所有能转化的罗马数字存起来，把要转化的数字直接对所有的罗马数字（从最大开始）求余，结果res每次都加上 (num/罗马数字的对应值)个罗马数字即可。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String intToRoman(int num) &#123;</span><br><span class="line">        String[] RomeNum = &#123;&quot;I&quot;, &quot;IV&quot;,&quot;V&quot;,&quot;IX&quot;,&quot;X&quot;, &quot;XL&quot;,&quot;L&quot;, &quot;XC&quot;, &quot;C&quot;, &quot;CD&quot;, &quot;D&quot;, &quot;CM&quot;, &quot;M&quot;&#125;;</span><br><span class="line">        int[] nums = &#123;1,4,5,9,10,40,50,90,100,400,500,900,1000&#125;;</span><br><span class="line">        //字符串相加使用StringBuilder更好</span><br><span class="line">        StringBuilder res = new StringBuilder();</span><br><span class="line">        int index = nums.length-1;//从最大的开始</span><br><span class="line">        while(num &gt; 0) &#123;</span><br><span class="line">        //整除当前罗马数组的商</span><br><span class="line">        int t = num / nums[index];</span><br><span class="line">        if(t &gt; 0) &#123;</span><br><span class="line">        while(t-- &gt; 0)</span><br><span class="line">        //加上相应个数的罗马数字</span><br><span class="line">        res.append(RomeNum[index]);</span><br><span class="line">        num %= nums[index];</span><br><span class="line">        &#125;</span><br><span class="line">        index --;</span><br><span class="line">        &#125;</span><br><span class="line">        return res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 21 ms, 在Integer to Roman的Java提交中击败了96.36% 的用户<br>内存消耗 : 41 MB, 在Integer to Roman的Java提交中击败了78.75% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。&lt;br&gt;字符          数值 I    
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode11. 盛最多水的容器</title>
    <link href="http://yoursite.com/2019/04/19/leetcode11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/"/>
    <id>http://yoursite.com/2019/04/19/leetcode11-盛最多水的容器/</id>
    <published>2019-04-19T08:39:04.000Z</published>
    <updated>2019-04-19T08:39:43.420Z</updated>
    
    <content type="html"><![CDATA[<p>题目：</p><blockquote><p>给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i<br>的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>说明：你不能倾斜容器，且 n 的值至少为 2。<br><img src="https://img-blog.csdnimg.cn/20190419161634314.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDQ4NTc0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。<br>示例:</p><p>输入: [1,8,6,2,5,4,8,3,7] 输出: 49</p></blockquote><p>解题思路：<br>最大容水的量其实就是直观上构成的长方形的体积最大，即Math.min(nums[left],nums[right]) * (right-left)最大。我的解法就是，使用双指针，一直缩小(right-left)，因为矩形的一条边一直在变短，所以一定是另外2边的短的一边向内遍历。<br>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxArea(int[] height) &#123;</span><br><span class="line">        int left = 0, right = height.length - 1;</span><br><span class="line">        int  area = 0;</span><br><span class="line">        while(left &lt; right) &#123;</span><br><span class="line">        //保存找到的最大面积</span><br><span class="line">        if(Math.min(height[left] , height[right]) * (right - left) &gt; area) &#123;</span><br><span class="line">        area = Math.min(height[left] , height[right]) * (right - left);</span><br><span class="line">        &#125;</span><br><span class="line">        //小的一边的下标向内遍历</span><br><span class="line">        if(height[left] &lt; height[right]) left ++;</span><br><span class="line">        else right --;</span><br><span class="line">        &#125;</span><br><span class="line">        return area;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码提交结果：<br>成功<br>显示详情<br>执行用时 : 5 ms, 在Container With Most Water的Java提交中击败了96.11% 的用户<br>内存消耗 : 45.1 MB, 在Container With Most Water的Java提交中击败了55.83% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i&lt;br&gt;的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>项目学习1-数据库准备</title>
    <link href="http://yoursite.com/2019/04/19/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A01-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%87%86%E5%A4%87/"/>
    <id>http://yoursite.com/2019/04/19/项目学习1-数据库准备/</id>
    <published>2019-04-19T03:13:04.000Z</published>
    <updated>2019-04-19T03:13:49.232Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>第一步：新建一个数据bos32</p><p>create database bos32 character set utf8;<br><img src="https://img-blog.csdnimg.cn/20190419111122555.png" alt="在这里插入图片描述"></p><p>第二步：新建一个用户xiaolizi<br>create user xiaolizi identified by ‘ermazi’;<br><img src="https://img-blog.csdnimg.cn/20190419110655303.png" alt="在这里插入图片描述"><br>第三步：为新用户授权<br>grant all on bos32.* to xiaolizi;<br><img src="https://img-blog.csdnimg.cn/20190419110749810.png" alt="在这里插入图片描述"><br>第四步：使用新用户登录MySQL<br><img src="https://img-blog.csdnimg.cn/20190419110829191.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDQ4NTc0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></blockquote><p>ps：学习来自于黑马项目</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;第一步：新建一个数据bos32&lt;/p&gt;
&lt;p&gt;create database bos32 character set utf8;&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190419111122555.
      
    
    </summary>
    
      <category term="项目开发" scheme="http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>leetcode8. 字符串转换整数 (atoi)</title>
    <link href="http://yoursite.com/2019/04/18/leetcode8-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0-atoi/"/>
    <id>http://yoursite.com/2019/04/18/leetcode8-字符串转换整数-atoi/</id>
    <published>2019-04-18T13:32:43.000Z</published>
    <updated>2019-04-18T13:33:49.709Z</updated>
    
    <content type="html"><![CDATA[<p>题目：</p><blockquote><p>请你来实现一个 atoi 函数，使其能将字符串转换成整数。</p><p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p><p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p><p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p><p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p><p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p><p>说明：</p><p>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，qing返回<br>INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p><p>示例 1:</p><p>输入: “42” 输出: 42<br>示例 2:</p><p>输入: “   -42” 输出: -42 解释: 第一个非空白字符为 ‘-‘, 它是一个负号。<br>     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。<br>      示例 3:</p><p>输入: “4193 with words” 输出: 4193 解释: 转换截止于数字 ‘3’ ，因为它的下一个字符不为数字。<br> 示例 4:</p><p>输入: “words and 987” 输出: 0 解释: 第一个非空字符是 ‘w’, 但它不是数字或正、负号。<br>     因此无法执行有效的转换。<br>     示例 5:</p><p>输入: “-91283472332” 输出: -2147483648 解释: 数字 “-91283472332” 超过 32<br>位有符号整数范围。 因此返回 INT_MIN (−231) 。</p></blockquote><p><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/" target="_blank" rel="noopener">题目原链接</a></p><p>解题思路：<br>如果开头是空格符，去掉空格符，可以用String的trim()函数，我是直接使用遍历。<br>然后，判断接下来的第一个字符是不是+、-、或者数字，如果不是直接返回0。<br>接着遍历接下来的数字，如果不是数字就break；如果已经达到integer边界就返回；</p><p>代码如下：</p><pre><code>class Solution {    public int myAtoi(String str) {        if(str.length() &lt; 1) return 0;        int index = 0;        str = str.trim();        long res = 0;        if(index == str.length()) return 0;//如果全部是空格返回0        int flag = 1;        //判断接下来的第一个字符        if(str.charAt(index) == &apos;-&apos;){            flag = -1;            index ++;        }        else if(str.charAt(index) == &apos;+&apos;) {            index ++;        }        else if(!Character.isDigit(str.charAt(index))){            return 0;        }        //遍历接下来的数字        for(; index &lt; str.length(); index ++) {            char ch = str.charAt(index);            if(!Character.isDigit(ch))                break;            res = res * 10 + ch - &apos;0&apos;;            if(res * flag&gt; Integer.MAX_VALUE)                return Integer.MAX_VALUE;            if(res * flag&lt; Integer.MIN_VALUE)                return Integer.MIN_VALUE;        }        return (int)res*flag;    }}</code></pre><p>代码提交结果：<br>成功<br>显示详情<br>执行用时 : 8 ms, 在String to Integer (atoi)的Java提交中击败了93.94% 的用户<br>内存消耗 : 37.3 MB, 在String to Integer (atoi)的Java提交中击败了77.77% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;请你来实现一个 atoi 函数，使其能将字符串转换成整数。&lt;/p&gt;
&lt;p&gt;首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。&lt;/p&gt;
&lt;p&gt;当我们寻找到的第一个非空字符为正或者负号时，则将该符号与
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode6. Z 字形变换</title>
    <link href="http://yoursite.com/2019/04/17/leetcode6-Z-%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/"/>
    <id>http://yoursite.com/2019/04/17/leetcode6-Z-字形变换/</id>
    <published>2019-04-17T15:51:54.000Z</published>
    <updated>2019-04-17T15:53:18.055Z</updated>
    
    <content type="html"><![CDATA[<p>题目：</p><blockquote><p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。</p><p>比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下：<br>L   C   I   R<br>E T O E S I I G<br>E   D   H   N<br>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”LCIRETOESIIGEDHN”。</p><p>请你实现这个将字符串进行指定行数变换的函数：</p><p>string convert(string s, int numRows); </p><p><strong>示例 1:</strong></p><p>输入: s = “LEETCODEISHIRING”, numRows = 3 输出: “LCIRETOESIIGEDHN”<br><strong>示例 2:</strong></p><p>输入: s = “LEETCODEISHIRING”, numRows = 4 输出: “LDREOEIIECIHNTSG” 解释:<br>L     D     R<br>E   O E   I I<br>E C   I H   N<br>T     S     G<br>（解释中的显示不太正确，以原题为准）<br><a href="https://leetcode-cn.com/problems/zigzag-conversion/" target="_blank" rel="noopener">题目原链接</a></p></blockquote><p>解题思路：<br>首先，要看懂题目，Z字形在此题目中是竖直的，类似N字形。<br>然后，不难看出来N的2竖的元素在字符串的规律，s.chat(i)对应的就是s.chat(i + 2 <em> numRows - 2)，所以每一行对应的竖直元素很显然可以得到；从第二行开始，斜着的元素稍加观察可以看出是由对应竖直元素减去当前行i</em>2得来的，所以创建一个StringBuilder每次添加一整行的元素即可。</p><p>代码如下：</p><pre><code>class Solution {    public String convert(String s, int numRows) {        if(numRows == 1) return s;        int n = 2 * numRows - 2;        StringBuilder res = new StringBuilder();        for(int i = 0; i &lt; numRows; i ++) {            for(int j = i; j &lt; s.length(); j += n) {                res.append(s.charAt(j));                 //第一行和最后一行没有斜着的元素                if(i != 0 &amp;&amp; i != numRows-1) {                     //对应行斜着的元素的下标                    int temp = j + n - 2*i;                    if(temp &gt; 0 &amp;&amp; temp &lt; s.length())                        res.append(s.charAt(j+n-2*i));                }            }        }        return res.toString();    }}</code></pre><p>代码提交结果：<br>成功<br>显示详情<br>执行用时 : 9 ms, 在ZigZag Conversion的Java提交中击败了99.18% 的用户<br>内存消耗 : 37.9 MB, 在ZigZag Conversion的Java提交中击败了97.81% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。&lt;/p&gt;
&lt;p&gt;比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下：&lt;br&gt;L   C   I   R&lt;br&gt;E T O E
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode78.子集</title>
    <link href="http://yoursite.com/2019/04/16/leetcode78-%E5%AD%90%E9%9B%86/"/>
    <id>http://yoursite.com/2019/04/16/leetcode78-子集/</id>
    <published>2019-04-16T13:40:53.000Z</published>
    <updated>2019-04-16T13:41:16.203Z</updated>
    
    <content type="html"><![CDATA[<p>给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</p><p>说明：解集不能包含重复的子集。</p><p>示例:</p><p>输入: nums = [1,2,3]<br>输出:<br>[<br>  [3],<br>  [1],<br>  [2],<br>  [1,2,3],<br>  [1,3],<br>  [2,3],<br>  [1,2],<br>  []<br>]</p><p>解题思路：<br>遍历一遍数组，每次遍历都把原来res链表里面的子链全部加上这个数。</p><p>代码如下：</p><pre><code>class Solution {    public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) {        List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;();        List&lt;Integer&gt; list = new LinkedList&lt;&gt;();        for(int i = 0; i &lt; nums.length; i ++) {            int size = res.size();            for(int j = 0; j &lt; size; j++) {                list = new LinkedList&lt;&gt;(res.get(j));                list.add(nums[i]);                res.add(list);            }            list = new LinkedList&lt;&gt;();            list.add(nums[i]);            res.add(list);        }        list = new LinkedList&lt;&gt;();        res.add(list);        return res;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。&lt;/p&gt;
&lt;p&gt;说明：解集不能包含重复的子集。&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;p&gt;输入: nums = [1,2,3]&lt;br&gt;输出:&lt;br&gt;[&lt;br&gt;  [3],&lt;br&gt;  [1],&lt;br&gt;  [
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>leetcode654. 最大二叉树</title>
    <link href="http://yoursite.com/2019/04/16/leetcode654-%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2019/04/16/leetcode654-最大二叉树/</id>
    <published>2019-04-16T11:40:51.000Z</published>
    <updated>2019-04-17T15:53:13.734Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：</p><p>二叉树的根是数组中的最大元素。<br>左子树是通过数组中最大值左边部分构造出的最大二叉树。<br>右子树是通过数组中最大值右边部分构造出的最大二叉树。<br>通过给定的数组构建最大二叉树，并且输出这个树的根节点。</p><p>Example 1:<br>输入: [3,2,1,6,0,5]<br>输入: 返回下面这棵树的根节点：</p><pre><code>   6 /   \3     5 \    /   2  0       \     1</code></pre><p>注意:<br>给定的数组的大小在 [1, 1000] 之间。</p><p>解题思路：<br>创建一个辅助函数从left到right遍历找出最大值，保存其下标index，然后把其作为节点root的值，再使其左结点为left到index-1，右节点为index+1到right，最后返回root</p><p>代码如下：</p><pre><code>class Solution {    public TreeNode constructMaximumBinaryTree(int[] nums) {    return helper( 0, nums.length-1, nums);}public TreeNode helper(int left, int right, int[] nums) {    if(left &gt; right) return null;    if(left == right) {        return new TreeNode(nums[left]);    }    int max = 0,index = 0;    for(int i = left; i &lt;= right; i ++) {        if(nums[i] &gt; max) {            max = nums[i];            index = i;        }    }    TreeNode root = new TreeNode(max);    root.left = helper(left, index-1, nums);    root.right = helper(index+1, right, nums);    return root;}</code></pre><p>}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：&lt;/p&gt;
&lt;p&gt;二叉树的根是数组中的最大元素。&lt;br&gt;左子树是通过数组中最大值左边部分构造出的最大二叉树。&lt;br&gt;右子树是通过数组中最大值右边部分构造出的最大二叉树。&lt;br&gt;通过给定的数组构建最大二叉树，
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode807. 保持城市天际线</title>
    <link href="http://yoursite.com/2019/04/16/807-%E4%BF%9D%E6%8C%81%E5%9F%8E%E5%B8%82%E5%A4%A9%E9%99%85%E7%BA%BF/"/>
    <id>http://yoursite.com/2019/04/16/807-保持城市天际线/</id>
    <published>2019-04-16T10:22:52.000Z</published>
    <updated>2019-04-17T14:46:28.944Z</updated>
    
    <content type="html"><![CDATA[<p>在二维数组grid中，grid[i][j]代表位于某处的建筑物的高度。 我们被允许增加任何数量（不同建筑物的数量可能不同）的建筑物的高度。 高度 0 也被认为是建筑物。</p><p>最后，从新数组的所有四个方向（即顶部，底部，左侧和右侧）观看的“天际线”必须与原始数组的天际线相同。 城市的天际线是从远处观看时，由所有建筑物形成的矩形的外部轮廓。 请看下面的例子。</p><p>建筑物高度可以增加的最大总和是多少？</p><p>例子：<br>输入： grid = [[3,0,8,4],[2,4,5,7],[9,2,6,3],[0,3,1,0]]<br>输出： 35<br>解释：<br>The grid is:<br>[ [3, 0, 8, 4],<br>  [2, 4, 5, 7],<br>  [9, 2, 6, 3],<br>  [0, 3, 1, 0] ]</p><p>从数组竖直方向（即顶部，底部）看“天际线”是：[9, 4, 8, 7]<br>从水平水平方向（即左侧，右侧）看“天际线”是：[8, 7, 9, 3]</p><p>在不影响天际线的情况下对建筑物进行增高后，新数组如下：</p><p>gridNew = [ [8, 4, 8, 7],<br>            [7, 4, 7, 7],<br>            [9, 4, 8, 7],<br>            [3, 3, 3, 3] ]<br>说明:</p><p>1 &lt; grid.length = grid[0].length &lt;= 50。<br> grid[i][j] 的高度范围是： [0, 100]。<br>一座建筑物占据一个grid[i][j]：换言之，它们是 1 x 1 x grid[i][j] 的长方体。<br>解题思路：<br>创建2个数组row、col，遍历<strong>一遍</strong>数组，使row、col保存水平、竖直“天际线”。<br>再遍历一遍数组，i行j列的楼层如果比Math.min(row[i],col[j]) 小的话，则是可以增加的楼层，Math.min(row[i],col[j])-grid[i][j]则是可增加的楼层数量。<br>代码如下：</p><pre><code>class Solution {    public int maxIncreaseKeepingSkyline(int[][] grid) {        int[] row = new int[grid.length];        int[] col = new int[grid[0].length];        for(int i = 0; i &lt; grid.length; i ++) {            int max = 0;            for(int j = 0; j &lt; grid.length; j ++) {                //更新col数组                if(grid[i][j] &gt; col[j]) col[j] = grid[i][j];                if(grid[i][j] &gt; max) max = grid[i][j];            }            //更新row数组            row[i] = max;        }        int res = 0;        for(int i = 0; i &lt; grid.length; i ++) {            for(int j = 0; j &lt; grid.length; j ++) {                int min = Math.min(row[i], col[j]);                if(grid[i][j] &lt; min) res += min - grid[i][j];            }        }        return res;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在二维数组grid中，grid[i][j]代表位于某处的建筑物的高度。 我们被允许增加任何数量（不同建筑物的数量可能不同）的建筑物的高度。 高度 0 也被认为是建筑物。&lt;/p&gt;
&lt;p&gt;最后，从新数组的所有四个方向（即顶部，底部，左侧和右侧）观看的“天际线”必须与原始数组的天
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode995. K 连续位的最小翻转次数</title>
    <link href="http://yoursite.com/2019/04/12/leetcode995/"/>
    <id>http://yoursite.com/2019/04/12/leetcode995/</id>
    <published>2019-04-12T03:16:55.890Z</published>
    <updated>2019-04-12T03:25:29.397Z</updated>
    
    <content type="html"><![CDATA[<h2 id="995-K-连续位的最小翻转次数"><a href="#995-K-连续位的最小翻转次数" class="headerlink" title="995. K 连续位的最小翻转次数"></a>995. K 连续位的最小翻转次数</h2><p>在仅包含 0 和 1 的数组 A 中，一次 K 位翻转包括选择一个长度为 K 的（连续）子数组，同时将子数组中的每个 0 更改为 1，而每个 1 更改为 0。</p><p>返回所需的 K 位翻转的次数，以便数组没有值为 0 的元素。如果不可能，返回 -1。</p><p>示例 1：</p><p>输入：A = [0,1,0], K = 1<br>输出：2<br>解释：先翻转 A[0]，然后翻转 A[2]。<br>示例 2：</p><p>输入：A = [1,1,0], K = 2<br>输出：-1<br>解释：无论我们怎样翻转大小为 2 的子数组，我们都不能使数组变为 [1,1,1]。<br>示例 3：</p><p>输入：A = [0,0,0,1,0,1,1,0], K = 3<br>输出：3<br>解释：<br>翻转 A[0],A[1],A[2]: A变成 [1,1,1,1,0,1,1,0]<br>翻转 A[4],A[5],A[6]: A变成 [1,1,1,1,1,0,0,0]<br>翻转 A[5],A[6],A[7]: A变成 [1,1,1,1,1,1,1,1]</p><p>提示：</p><p>1.1 &lt;= A.length &lt;= 30000<br>2.1 &lt;= K &lt;= A.length<br>代码如下：</p><pre><code>class Solution {    public static int minKBitFlips(int[] A, int K) {    int times = 0;    int begin = 0;    // 如果剩下的牌不够K 则跳出    while (begin &lt;= A.length - K) {        begin = getFirstZero(A);        if (begin == -1) {            return times;        }        draw(A, begin, K);        times++;    }    return -1;    }    public static int getFirstZero(int[] A) {        for (int i = 0; i &lt; A.length; i++) {            if (A[i] == 0) {                return i;            }        }        return -1;    }    public static void draw(int[] A, int begin, int k) {        if (begin + k &gt; A.length) return;        for (int i = begin; i &lt; begin + k; i++) {            if (A[i] == 0) {                A[i] = 1;            } else {                A[i] = 0;            }        }    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;995-K-连续位的最小翻转次数&quot;&gt;&lt;a href=&quot;#995-K-连续位的最小翻转次数&quot; class=&quot;headerlink&quot; title=&quot;995. K 连续位的最小翻转次数&quot;&gt;&lt;/a&gt;995. K 连续位的最小翻转次数&lt;/h2&gt;&lt;p&gt;在仅包含 0 和 1 的
      
    
    </summary>
    
    
  </entry>
  
</feed>
