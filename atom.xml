<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>白哥的博客</title>
  
  <subtitle>白哥的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-17T15:53:18.055Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>白哥</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode6. Z 字形变换</title>
    <link href="http://yoursite.com/2019/04/17/leetcode6-Z-%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/"/>
    <id>http://yoursite.com/2019/04/17/leetcode6-Z-字形变换/</id>
    <published>2019-04-17T15:51:54.000Z</published>
    <updated>2019-04-17T15:53:18.055Z</updated>
    
    <content type="html"><![CDATA[<p>题目：</p><blockquote><p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。</p><p>比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下：<br>L   C   I   R<br>E T O E S I I G<br>E   D   H   N<br>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”LCIRETOESIIGEDHN”。</p><p>请你实现这个将字符串进行指定行数变换的函数：</p><p>string convert(string s, int numRows); </p><p><strong>示例 1:</strong></p><p>输入: s = “LEETCODEISHIRING”, numRows = 3 输出: “LCIRETOESIIGEDHN”<br><strong>示例 2:</strong></p><p>输入: s = “LEETCODEISHIRING”, numRows = 4 输出: “LDREOEIIECIHNTSG” 解释:<br>L     D     R<br>E   O E   I I<br>E C   I H   N<br>T     S     G<br>（解释中的显示不太正确，以原题为准）<br><a href="https://leetcode-cn.com/problems/zigzag-conversion/" target="_blank" rel="noopener">题目原链接</a></p></blockquote><p>解题思路：<br>首先，要看懂题目，Z字形在此题目中是竖直的，类似N字形。<br>然后，不难看出来N的2竖的元素在字符串的规律，s.chat(i)对应的就是s.chat(i + 2 <em> numRows - 2)，所以每一行对应的竖直元素很显然可以得到；从第二行开始，斜着的元素稍加观察可以看出是由对应竖直元素减去当前行i</em>2得来的，所以创建一个StringBuilder每次添加一整行的元素即可。</p><p>代码如下：</p><pre><code>class Solution {    public String convert(String s, int numRows) {        if(numRows == 1) return s;        int n = 2 * numRows - 2;        StringBuilder res = new StringBuilder();        for(int i = 0; i &lt; numRows; i ++) {            for(int j = i; j &lt; s.length(); j += n) {                res.append(s.charAt(j));                 //第一行和最后一行没有斜着的元素                if(i != 0 &amp;&amp; i != numRows-1) {                     //对应行斜着的元素的下标                    int temp = j + n - 2*i;                    if(temp &gt; 0 &amp;&amp; temp &lt; s.length())                        res.append(s.charAt(j+n-2*i));                }            }        }        return res.toString();    }}</code></pre><p>代码提交结果：<br>成功<br>显示详情<br>执行用时 : 9 ms, 在ZigZag Conversion的Java提交中击败了99.18% 的用户<br>内存消耗 : 37.9 MB, 在ZigZag Conversion的Java提交中击败了97.81% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。&lt;/p&gt;
&lt;p&gt;比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下：&lt;br&gt;L   C   I   R&lt;br&gt;E T O E
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode78.子集</title>
    <link href="http://yoursite.com/2019/04/16/leetcode78-%E5%AD%90%E9%9B%86/"/>
    <id>http://yoursite.com/2019/04/16/leetcode78-子集/</id>
    <published>2019-04-16T13:40:53.000Z</published>
    <updated>2019-04-16T13:41:16.203Z</updated>
    
    <content type="html"><![CDATA[<p>给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</p><p>说明：解集不能包含重复的子集。</p><p>示例:</p><p>输入: nums = [1,2,3]<br>输出:<br>[<br>  [3],<br>  [1],<br>  [2],<br>  [1,2,3],<br>  [1,3],<br>  [2,3],<br>  [1,2],<br>  []<br>]</p><p>解题思路：<br>遍历一遍数组，每次遍历都把原来res链表里面的子链全部加上这个数。</p><p>代码如下：</p><pre><code>class Solution {    public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) {        List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;();        List&lt;Integer&gt; list = new LinkedList&lt;&gt;();        for(int i = 0; i &lt; nums.length; i ++) {            int size = res.size();            for(int j = 0; j &lt; size; j++) {                list = new LinkedList&lt;&gt;(res.get(j));                list.add(nums[i]);                res.add(list);            }            list = new LinkedList&lt;&gt;();            list.add(nums[i]);            res.add(list);        }        list = new LinkedList&lt;&gt;();        res.add(list);        return res;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。&lt;/p&gt;
&lt;p&gt;说明：解集不能包含重复的子集。&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;p&gt;输入: nums = [1,2,3]&lt;br&gt;输出:&lt;br&gt;[&lt;br&gt;  [3],&lt;br&gt;  [1],&lt;br&gt;  [
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>leetcode654. 最大二叉树</title>
    <link href="http://yoursite.com/2019/04/16/leetcode654-%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2019/04/16/leetcode654-最大二叉树/</id>
    <published>2019-04-16T11:40:51.000Z</published>
    <updated>2019-04-17T15:53:13.734Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：</p><p>二叉树的根是数组中的最大元素。<br>左子树是通过数组中最大值左边部分构造出的最大二叉树。<br>右子树是通过数组中最大值右边部分构造出的最大二叉树。<br>通过给定的数组构建最大二叉树，并且输出这个树的根节点。</p><p>Example 1:<br>输入: [3,2,1,6,0,5]<br>输入: 返回下面这棵树的根节点：</p><pre><code>   6 /   \3     5 \    /   2  0       \     1</code></pre><p>注意:<br>给定的数组的大小在 [1, 1000] 之间。</p><p>解题思路：<br>创建一个辅助函数从left到right遍历找出最大值，保存其下标index，然后把其作为节点root的值，再使其左结点为left到index-1，右节点为index+1到right，最后返回root</p><p>代码如下：</p><pre><code>class Solution {    public TreeNode constructMaximumBinaryTree(int[] nums) {    return helper( 0, nums.length-1, nums);}public TreeNode helper(int left, int right, int[] nums) {    if(left &gt; right) return null;    if(left == right) {        return new TreeNode(nums[left]);    }    int max = 0,index = 0;    for(int i = left; i &lt;= right; i ++) {        if(nums[i] &gt; max) {            max = nums[i];            index = i;        }    }    TreeNode root = new TreeNode(max);    root.left = helper(left, index-1, nums);    root.right = helper(index+1, right, nums);    return root;}</code></pre><p>}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：&lt;/p&gt;
&lt;p&gt;二叉树的根是数组中的最大元素。&lt;br&gt;左子树是通过数组中最大值左边部分构造出的最大二叉树。&lt;br&gt;右子树是通过数组中最大值右边部分构造出的最大二叉树。&lt;br&gt;通过给定的数组构建最大二叉树，
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode807. 保持城市天际线</title>
    <link href="http://yoursite.com/2019/04/16/807-%E4%BF%9D%E6%8C%81%E5%9F%8E%E5%B8%82%E5%A4%A9%E9%99%85%E7%BA%BF/"/>
    <id>http://yoursite.com/2019/04/16/807-保持城市天际线/</id>
    <published>2019-04-16T10:22:52.000Z</published>
    <updated>2019-04-17T14:46:28.944Z</updated>
    
    <content type="html"><![CDATA[<p>在二维数组grid中，grid[i][j]代表位于某处的建筑物的高度。 我们被允许增加任何数量（不同建筑物的数量可能不同）的建筑物的高度。 高度 0 也被认为是建筑物。</p><p>最后，从新数组的所有四个方向（即顶部，底部，左侧和右侧）观看的“天际线”必须与原始数组的天际线相同。 城市的天际线是从远处观看时，由所有建筑物形成的矩形的外部轮廓。 请看下面的例子。</p><p>建筑物高度可以增加的最大总和是多少？</p><p>例子：<br>输入： grid = [[3,0,8,4],[2,4,5,7],[9,2,6,3],[0,3,1,0]]<br>输出： 35<br>解释：<br>The grid is:<br>[ [3, 0, 8, 4],<br>  [2, 4, 5, 7],<br>  [9, 2, 6, 3],<br>  [0, 3, 1, 0] ]</p><p>从数组竖直方向（即顶部，底部）看“天际线”是：[9, 4, 8, 7]<br>从水平水平方向（即左侧，右侧）看“天际线”是：[8, 7, 9, 3]</p><p>在不影响天际线的情况下对建筑物进行增高后，新数组如下：</p><p>gridNew = [ [8, 4, 8, 7],<br>            [7, 4, 7, 7],<br>            [9, 4, 8, 7],<br>            [3, 3, 3, 3] ]<br>说明:</p><p>1 &lt; grid.length = grid[0].length &lt;= 50。<br> grid[i][j] 的高度范围是： [0, 100]。<br>一座建筑物占据一个grid[i][j]：换言之，它们是 1 x 1 x grid[i][j] 的长方体。<br>解题思路：<br>创建2个数组row、col，遍历<strong>一遍</strong>数组，使row、col保存水平、竖直“天际线”。<br>再遍历一遍数组，i行j列的楼层如果比Math.min(row[i],col[j]) 小的话，则是可以增加的楼层，Math.min(row[i],col[j])-grid[i][j]则是可增加的楼层数量。<br>代码如下：</p><pre><code>class Solution {    public int maxIncreaseKeepingSkyline(int[][] grid) {        int[] row = new int[grid.length];        int[] col = new int[grid[0].length];        for(int i = 0; i &lt; grid.length; i ++) {            int max = 0;            for(int j = 0; j &lt; grid.length; j ++) {                //更新col数组                if(grid[i][j] &gt; col[j]) col[j] = grid[i][j];                if(grid[i][j] &gt; max) max = grid[i][j];            }            //更新row数组            row[i] = max;        }        int res = 0;        for(int i = 0; i &lt; grid.length; i ++) {            for(int j = 0; j &lt; grid.length; j ++) {                int min = Math.min(row[i], col[j]);                if(grid[i][j] &lt; min) res += min - grid[i][j];            }        }        return res;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在二维数组grid中，grid[i][j]代表位于某处的建筑物的高度。 我们被允许增加任何数量（不同建筑物的数量可能不同）的建筑物的高度。 高度 0 也被认为是建筑物。&lt;/p&gt;
&lt;p&gt;最后，从新数组的所有四个方向（即顶部，底部，左侧和右侧）观看的“天际线”必须与原始数组的天
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode995. K 连续位的最小翻转次数</title>
    <link href="http://yoursite.com/2019/04/12/leetcode995/"/>
    <id>http://yoursite.com/2019/04/12/leetcode995/</id>
    <published>2019-04-12T03:16:55.890Z</published>
    <updated>2019-04-12T03:25:29.397Z</updated>
    
    <content type="html"><![CDATA[<h2 id="995-K-连续位的最小翻转次数"><a href="#995-K-连续位的最小翻转次数" class="headerlink" title="995. K 连续位的最小翻转次数"></a>995. K 连续位的最小翻转次数</h2><p>在仅包含 0 和 1 的数组 A 中，一次 K 位翻转包括选择一个长度为 K 的（连续）子数组，同时将子数组中的每个 0 更改为 1，而每个 1 更改为 0。</p><p>返回所需的 K 位翻转的次数，以便数组没有值为 0 的元素。如果不可能，返回 -1。</p><p>示例 1：</p><p>输入：A = [0,1,0], K = 1<br>输出：2<br>解释：先翻转 A[0]，然后翻转 A[2]。<br>示例 2：</p><p>输入：A = [1,1,0], K = 2<br>输出：-1<br>解释：无论我们怎样翻转大小为 2 的子数组，我们都不能使数组变为 [1,1,1]。<br>示例 3：</p><p>输入：A = [0,0,0,1,0,1,1,0], K = 3<br>输出：3<br>解释：<br>翻转 A[0],A[1],A[2]: A变成 [1,1,1,1,0,1,1,0]<br>翻转 A[4],A[5],A[6]: A变成 [1,1,1,1,1,0,0,0]<br>翻转 A[5],A[6],A[7]: A变成 [1,1,1,1,1,1,1,1]</p><p>提示：</p><p>1.1 &lt;= A.length &lt;= 30000<br>2.1 &lt;= K &lt;= A.length<br>代码如下：</p><pre><code>class Solution {    public static int minKBitFlips(int[] A, int K) {    int times = 0;    int begin = 0;    // 如果剩下的牌不够K 则跳出    while (begin &lt;= A.length - K) {        begin = getFirstZero(A);        if (begin == -1) {            return times;        }        draw(A, begin, K);        times++;    }    return -1;    }    public static int getFirstZero(int[] A) {        for (int i = 0; i &lt; A.length; i++) {            if (A[i] == 0) {                return i;            }        }        return -1;    }    public static void draw(int[] A, int begin, int k) {        if (begin + k &gt; A.length) return;        for (int i = begin; i &lt; begin + k; i++) {            if (A[i] == 0) {                A[i] = 1;            } else {                A[i] = 0;            }        }    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;995-K-连续位的最小翻转次数&quot;&gt;&lt;a href=&quot;#995-K-连续位的最小翻转次数&quot; class=&quot;headerlink&quot; title=&quot;995. K 连续位的最小翻转次数&quot;&gt;&lt;/a&gt;995. K 连续位的最小翻转次数&lt;/h2&gt;&lt;p&gt;在仅包含 0 和 1 的
      
    
    </summary>
    
    
  </entry>
  
</feed>
