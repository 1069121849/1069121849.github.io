<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>白哥的博客</title>
  
  <subtitle>白哥的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-05-13T16:00:28.605Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>白哥</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode152. 乘积最大子序列</title>
    <link href="http://yoursite.com/2019/05/13/leetcode152.%20%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>http://yoursite.com/2019/05/13/leetcode152. 乘积最大子序列/</id>
    <published>2019-05-13T15:59:58.034Z</published>
    <updated>2019-05-13T16:00:28.605Z</updated>
    
    <content type="html"><![CDATA[<h4 id="152-乘积最大子序列"><a href="#152-乘积最大子序列" class="headerlink" title="152. 乘积最大子序列"></a><a href="https://leetcode-cn.com/problems/maximum-product-subarray/" target="_blank" rel="noopener">152. 乘积最大子序列</a></h4><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数数组 <code>nums</code> ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,3,-2,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 子数组 [2,3] 有最大乘积 6。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [-2,0,-1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>使用2个数组，保存当前位置所能得到的最大值以及最小值，如果下一个位置的数组是负数，则乘最小值，整数乘最大值；需要注意判断如果乘上一个位置最大值之后是否比当前位置的值还小，则当前位置的最大值为当前的值，同理最小值也如此。</p><p>上面的思路我们可以发现，每次只需要根据上一个位置的最大值最小值我们就可以判断出当前位置所能得到的最大值和最小值，所以我们可以把2个数组简化为2个变量。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxProduct(int[] nums) &#123;</span><br><span class="line">        int len = nums.length;</span><br><span class="line">        int res = nums[0];</span><br><span class="line">        int nowMax = res;</span><br><span class="line">        int nowMin = res;</span><br><span class="line">        for (int i = 1; i &lt; len; i++) &#123;</span><br><span class="line">            if(nums[i] &lt; 0)&#123;</span><br><span class="line">            //负数则交换最大值最小值</span><br><span class="line">                nowMax = nowMin ^ nowMax;</span><br><span class="line">                nowMin = nowMax ^ nowMin;</span><br><span class="line">                nowMax = nowMax ^ nowMin;</span><br><span class="line">            &#125;</span><br><span class="line">            nowMax = Math.max(nums[i], nums[i]*nowMax);</span><br><span class="line">            nowMin = Math.min(nums[i], nums[i]*nowMin);</span><br><span class="line">            res = Math.max(res, nowMax);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功</p><p>显示详情 </p><p>执行用时 : 4 ms, 在Maximum Product Subarray的Java提交中击败了62.07% 的用户</p><p>内存消耗 : 35.9 MB, 在Maximum Product Subarray的Java提交中击败了54.02% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;152-乘积最大子序列&quot;&gt;&lt;a href=&quot;#152-乘积最大子序列&quot; class=&quot;headerlink&quot; title=&quot;152. 乘积最大子序列&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/maximum-pr
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>反射</title>
    <link href="http://yoursite.com/2019/05/13/%E5%8F%8D%E5%B0%84/"/>
    <id>http://yoursite.com/2019/05/13/反射/</id>
    <published>2019-05-13T15:54:01.440Z</published>
    <updated>2019-05-14T07:24:15.383Z</updated>
    
    <content type="html"><![CDATA[<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。</p><h3 id="创建Robot类"><a href="#创建Robot类" class="headerlink" title="创建Robot类"></a>创建Robot类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package reflect;</span><br><span class="line"></span><br><span class="line">public class Robot &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    public void sayHello(String name) &#123;</span><br><span class="line">        System.out.println(&quot;hello &quot; + name);</span><br><span class="line">    &#125;</span><br><span class="line">    private int throwMaxNumber(int[] nums) &#123;</span><br><span class="line">        int max = 0;</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            if (nums[i] &gt; max) &#123;</span><br><span class="line">                max = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line">    public void introduce()&#123;</span><br><span class="line">        System.out.println(&quot;my name is &quot; + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在通过forName和反射获取Robot类的所有方法和属性"><a href="#在通过forName和反射获取Robot类的所有方法和属性" class="headerlink" title="在通过forName和反射获取Robot类的所有方法和属性"></a>在通过forName和反射获取Robot类的所有方法和属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package reflect;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.lang.reflect.InvocationTargetException;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public class ReflectSample &#123;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException, InstantiationException, NoSuchFieldException &#123;</span><br><span class="line">        //通过类名获取Class对象</span><br><span class="line">        Class robot = Class.forName(&quot;reflect.Robot&quot;);</span><br><span class="line">        //通过Class对象的newInstance方法创建一个对象</span><br><span class="line">        Robot r = (Robot) robot.newInstance();</span><br><span class="line">        //获取Class对象中的sayHello方法，该方法需要传入一个String参数</span><br><span class="line">//        Method sayHello = robot.getDeclaredMethod(&quot;sayHello&quot;, String.class);</span><br><span class="line">        Method sayHello = robot.getMethod(&quot;sayHello&quot;, String.class);</span><br><span class="line">        //通过反射机制执行该方法,传入参数： 丁先生</span><br><span class="line">        Object sayHelloOut = sayHello.invoke(r, &quot;丁先生&quot;);</span><br><span class="line">        //输出该方法返回的值</span><br><span class="line">//        System.out.println(sayHelloOut);</span><br><span class="line"></span><br><span class="line">        //获取对象中的private方法需要使用getDeclaredMethod获取</span><br><span class="line">        Method throwMaxNumber = robot.getDeclaredMethod(&quot;throwMaxNumber&quot;, int[].class);</span><br><span class="line">        //默认Accessible是false 需要设置为true,因为方法是私有的</span><br><span class="line">        throwMaxNumber.setAccessible(true);</span><br><span class="line">        Object invoke = throwMaxNumber.invoke(r, new int[]&#123;3, 5, 2, 6, 1&#125;);</span><br><span class="line">        System.out.println(invoke);</span><br><span class="line"></span><br><span class="line">        //设置r中的私有变量</span><br><span class="line">        Field name = robot.getDeclaredField(&quot;name&quot;);</span><br><span class="line">        //同私有方法也是要设置accessible为true</span><br><span class="line">        name.setAccessible(true);</span><br><span class="line">        name.set(r, &quot;陈先生&quot;);</span><br><span class="line">        Method introduce = robot.getMethod(&quot;introduce&quot;);</span><br><span class="line">        introduce.invoke(r);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="执行的输出结果"><a href="#执行的输出结果" class="headerlink" title="执行的输出结果"></a>执行的输出结果</h4><p><img src="C:\Users\xin\AppData\Roaming\Typora\typora-user-images\1557762815500.png" alt="1557762815500"></p><h3 id="通过classLoader获取Class对象"><a href="#通过classLoader获取Class对象" class="headerlink" title="通过classLoader获取Class对象"></a>通过classLoader获取Class对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package reflect;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.InvocationTargetException;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public class ClassLoaderTest &#123;</span><br><span class="line">    public static void main(String[] args) throws IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException, ClassNotFoundException &#123;</span><br><span class="line">        ClassLoader classLoader = Robot.class.getClassLoader();</span><br><span class="line">        Class robot = classLoader.loadClass(&quot;reflect.Robot&quot;);</span><br><span class="line">//      Class robot2 = Class.forName(&quot;reflect.Robot&quot;);</span><br><span class="line">        Robot r = (Robot) robot.newInstance();</span><br><span class="line">        Method introduce = robot.getMethod(&quot;introduce&quot;);</span><br><span class="line">        Object invoke = introduce.invoke(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;反射&quot;&gt;&lt;a href=&quot;#反射&quot; class=&quot;headerlink&quot; title=&quot;反射&quot;&gt;&lt;/a&gt;反射&lt;/h2&gt;&lt;p&gt;JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获
      
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 139. 单词拆分</title>
    <link href="http://yoursite.com/2019/05/13/leetcode%20139.%20%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/"/>
    <id>http://yoursite.com/2019/05/13/leetcode 139. 单词拆分/</id>
    <published>2019-05-13T12:14:07.077Z</published>
    <updated>2019-05-13T12:13:58.387Z</updated>
    
    <content type="html"><![CDATA[<p>﻿## 题目</p><blockquote><p>给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</p><p><strong>说明：</strong></p><p>拆分时可以重复使用字典中的单词。 你可以假设字典中没有重复的单词。<br><strong>示例 1：</strong></p><p><strong>输入:</strong> s = “leetcode”, wordDict = [“leet”, “code”]<br><strong>输出:</strong> true<br><strong>解释:</strong> 返回 true 因为 “leetcode” 可以被拆分成 “leet code”。<br><strong>示例 2：</strong></p><p><strong>输入:</strong> s = “applepenapple”, wordDict = [“apple”, “pen”]<br><strong>输出:</strong> true<br><strong>解释:</strong> 返回 true 因为 “applepenapple” 可以被拆分成 “apple pen apple”。<br>     注意你可以重复使用字典中的单词。<br><strong>示例 3：</strong></p><p><strong>输入:</strong> s = “catsandog”, wordDict = [“cats”, “dog”, “sand”, “and”, “cat”]<br><strong>输出:</strong> false</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>使用一个布尔数组dp，<strong>dp[i]表示s.substring(0,i)是可以由wordDic中的单词组合而来的</strong>，遍历单词可能的组成，如果s.substring(i,j)存在于wordDict中，则dp[j]=dp[i]的值，即等于s.substring(0,i)能否由wordDic中的单词组成。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123;</span><br><span class="line">        int len = s.length();</span><br><span class="line">        boolean[] dp = new boolean[len+1];</span><br><span class="line">        dp[0] = true;</span><br><span class="line">        //dp[i]记录s.substring(0,i+1)是可以由wordDic组合而来的</span><br><span class="line">        for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">            for (int j = i+1; j &lt;= len; j++) &#123;</span><br><span class="line">                if(wordDict.contains(s.substring(i,j)))&#123;</span><br><span class="line">                    if(dp[j]) continue;</span><br><span class="line"></span><br><span class="line">                    dp[j] = dp[i];</span><br><span class="line">                    if (dp[len]) return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[len];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>36 / 36 个通过测试用例<br>状态：通过<br>执行用时：7 ms</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;﻿## 题目&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;拆分时可以重复使
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode138. 复制带随机指针的链表</title>
    <link href="http://yoursite.com/2019/05/13/leetcode138.%20%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2019/05/13/leetcode138. 复制带随机指针的链表/</id>
    <published>2019-05-13T08:19:59.319Z</published>
    <updated>2019-05-13T08:22:52.517Z</updated>
    
    <content type="html"><![CDATA[<h4 id="138-复制带随机指针的链表"><a href="#138-复制带随机指针的链表" class="headerlink" title="138. 复制带随机指针的链表"></a><a href="https://leetcode-cn.com/problems/copy-list-with-random-pointer/" target="_blank" rel="noopener">138. 复制带随机指针的链表</a></h4><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。</p><p>要求返回这个链表的<strong>深拷贝</strong>。 </p><p><strong>示例：</strong></p><p><strong><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/23/1470150906153-2yxeznm.png" alt="img"></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; 输入：</span><br><span class="line">&gt; &#123;&quot;$id&quot;:&quot;1&quot;,&quot;next&quot;:&#123;&quot;$id&quot;:&quot;2&quot;,&quot;next&quot;:null,&quot;random&quot;:&#123;&quot;$ref&quot;:&quot;2&quot;&#125;,&quot;val&quot;:2&#125;,&quot;random&quot;:&#123;&quot;$ref&quot;:&quot;2&quot;&#125;,&quot;val&quot;:1&#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; 解释：</span><br><span class="line">&gt; 节点 1 的值是 1，它的下一个指针和随机指针都指向节点 2 。</span><br><span class="line">&gt; 节点 2 的值是 2，它的下一个指针指向 null，随机指针指向它自己。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><strong>提示：</strong></p><ol><li>你必须返回<strong>给定头的拷贝</strong>作为对克隆列表的引用。</li></ol></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>用一个map保存原来node对应的newNode</p><p>从头开始，创建一个新的结点，先把它put到map中，然后继续创建它的下一个结点和随机指针指向的结点，遍历到底即可。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public Node copyRandomList(Node head) &#123;</span><br><span class="line">        HashMap&lt;Node, Node&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        return helper(head, map);</span><br><span class="line">    &#125;</span><br><span class="line">    public Node helper(Node node, Map&lt;Node, Node&gt; map) &#123;</span><br><span class="line">        if (node == null) return null;</span><br><span class="line">        if (map.containsKey(node)) &#123;</span><br><span class="line">            return map.get(node);</span><br><span class="line">        &#125;</span><br><span class="line">        Node newNode = new Node(node.val, null, null);</span><br><span class="line">        map.put(node, newNode);</span><br><span class="line">        if(node.next != null) &#123;</span><br><span class="line">            newNode.next = helper(node.next, map);</span><br><span class="line">        &#125;</span><br><span class="line">        if(node.random != null) &#123;</span><br><span class="line">            newNode.random = helper(node.random, map);</span><br><span class="line">        &#125;</span><br><span class="line">        return newNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功</p><p>显示详情 </p><p>执行用时 : 3 ms, 在Copy List with Random Pointer的Java提交中击败了27.10% 的用户</p><p>内存消耗 : 33.8 MB, 在Copy List with Random Pointer的Java提交中击败了71.29% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;138-复制带随机指针的链表&quot;&gt;&lt;a href=&quot;#138-复制带随机指针的链表&quot; class=&quot;headerlink&quot; title=&quot;138. 复制带随机指针的链表&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/c
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode134. 加油站</title>
    <link href="http://yoursite.com/2019/05/13/leetcode134.%20%E5%8A%A0%E6%B2%B9%E7%AB%99/"/>
    <id>http://yoursite.com/2019/05/13/leetcode134. 加油站/</id>
    <published>2019-05-13T07:59:02.985Z</published>
    <updated>2019-05-13T08:23:13.358Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。</p><p>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i]<br>升。你从其中的一个加油站出发，开始时油箱为空。</p><p>如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。</p><p><strong>说明:</strong> </p><p>如果题目有解，该答案即为唯一答案。 输入数组均为非空数组，且长度相同。 输入数组中的元素均为非负数。<br><strong>示例 1:</strong></p><p><strong>输入:</strong>  gas  = [1,2,3,4,5] cost = [3,4,5,1,2]</p><p><strong>输出: 3</strong></p><p><strong>解释:</strong> 从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油 开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油 开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油 开往 1<br>号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油 开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油 开往 3<br>号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。 因此，3 可为起始索引。<br><strong>示例 2:</strong></p><p><strong>输入:</strong>  gas  = [2,3,4] cost = [3,4,3]</p><p><strong>输出:</strong> -1</p><p><strong>解释:</strong> 你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。 我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油 开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油 开往 1<br>号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油 你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3<br>升汽油。 因此，无论怎样，你都不可能绕环路行驶一周。</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>oil[i]为到达i油站时剩余的油量<br>len为一共有多少个油站<br>sum为从头到尾所剩余的油量<br>可以看出来<br>假设该题目有解，则会<strong>存在sum&gt;0，并且从oil[res]+oil[len-1]&gt;0;</strong><br>如果没解则会有 <strong>sum&lt;0</strong>。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int canCompleteCircuit(int[] gas, int[] cost) &#123;</span><br><span class="line">        int len = gas.length;</span><br><span class="line">        if (len == 1) &#123;</span><br><span class="line">            return gas[0] - cost[0] &gt;= 0 ? 0: -1;</span><br><span class="line">        &#125;</span><br><span class="line">        //保存每个油站所能剩余的油量</span><br><span class="line">        int[] oil = new int[len];</span><br><span class="line">        for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">            oil[i] = gas[i] - cost[i];</span><br><span class="line">        &#125;</span><br><span class="line">        int sum = 0;//从头到尾的油量，如果最后小于0则说明饶不了一圈</span><br><span class="line">        int res = 0;//开始出发的油站</span><br><span class="line">        int nowOil = 0;//开始出发的油站到当前剩下的油</span><br><span class="line">        for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">            sum += oil[i];</span><br><span class="line">            nowOil += oil[i];</span><br><span class="line">            if(nowOil &lt; 0) &#123;</span><br><span class="line">                nowOil = 0;</span><br><span class="line">                res = i+1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(sum &lt; 0) &#123;</span><br><span class="line">            return  -1;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 1 ms, 在Gas Station的Java提交中击败了93.51% 的用户<br>内存消耗 : 36.8 MB, 在Gas Station的Java提交中击败了91.99% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。&lt;/p&gt;
&lt;p&gt;你有一辆油箱容量无限的
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>数据库学习</title>
    <link href="http://yoursite.com/2019/05/13/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://yoursite.com/2019/05/13/数据库/</id>
    <published>2019-05-13T00:24:29.971Z</published>
    <updated>2019-05-13T08:22:25.048Z</updated>
    
    <content type="html"><![CDATA[<h2 id="索引模块"><a href="#索引模块" class="headerlink" title="索引模块"></a>索引模块</h2><h3 id="为什么要使用索引"><a href="#为什么要使用索引" class="headerlink" title="为什么要使用索引"></a>为什么要使用索引</h3><p>避免全表扫描去查找数据，提升检索效率</p><h3 id="什么样的信息能成为索引"><a href="#什么样的信息能成为索引" class="headerlink" title="什么样的信息能成为索引"></a>什么样的信息能成为索引</h3><p>主键、唯一键等能区分数据的字段</p><h3 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h3><p>主流是B+树，还有哈希结构以及BitMap，其中MySQL不支持BitMap索引，基于InnoDB以及MyISAM的MySQL不显式支持哈希索引</p><h3 id="密集索引和稀疏索引的区别"><a href="#密集索引和稀疏索引的区别" class="headerlink" title="密集索引和稀疏索引的区别"></a>密集索引和稀疏索引的区别</h3><p>密集索引文件中的每个搜索码都对应一个索引值</p><p>稀疏索引文件只为索引码的某些值建立索引项</p><h3 id="如何定位并优化慢查询sql"><a href="#如何定位并优化慢查询sql" class="headerlink" title="如何定位并优化慢查询sql"></a>如何定位并优化慢查询sql</h3><p>根据慢日志定位慢查询sql语句</p><p>使用explain 等工具分析sql</p><p>修改sql或者尽量让sql走索引；<strong>force index()</strong> <strong>强制走某个索引</strong></p><h3 id="索引是建立得越多越好吗"><a href="#索引是建立得越多越好吗" class="headerlink" title="索引是建立得越多越好吗"></a>索引是建立得越多越好吗</h3><p>数据量小的表不需要建立索引，建立会增加额外的索引开销</p><p>数据变更需要维护索引，隐藏更多的索引意味着更多的维护成本</p><p>更多的索引意味着也需要更多的空间</p><h2 id="数据库锁"><a href="#数据库锁" class="headerlink" title="数据库锁"></a>数据库锁</h2><h3 id="MyISAM和InnoDB关于锁方面的区别是什么"><a href="#MyISAM和InnoDB关于锁方面的区别是什么" class="headerlink" title="MyISAM和InnoDB关于锁方面的区别是什么"></a>MyISAM和InnoDB关于锁方面的区别是什么</h3><p>MyISAM默认使用的是表级锁，不支持行级锁</p><p>InnoDB默认用的是行级锁，也支持表级锁</p><h4 id="MyISAM适合的场景"><a href="#MyISAM适合的场景" class="headerlink" title="MyISAM适合的场景"></a>MyISAM适合的场景</h4><p>1.频繁执行全表count语句</p><p>2.对数据进行增删改的频率不高，查询非常频繁</p><p>3.没有事务</p><h4 id="InnoDB适合的场景"><a href="#InnoDB适合的场景" class="headerlink" title="InnoDB适合的场景"></a>InnoDB适合的场景</h4><p>1.数据增删改查都相当频繁</p><p>2.可靠性要求比较高，要求支持事务</p><h3 id="数据库锁的分类"><a href="#数据库锁的分类" class="headerlink" title="数据库锁的分类"></a>数据库锁的分类</h3><ul><li>按锁的粒度划分，可分为表级锁、行级锁、页级锁</li><li>按锁级别划分，可分为共享锁、排它锁</li><li>按加锁方式划分，可分为自动锁，显式锁</li><li>按操作划分，可分为DML锁、DDL锁</li><li>按使用方式划分，可分为乐观锁、悲观锁</li></ul><h3 id="事务隔离级别以及各级别下的并发访问问题"><a href="#事务隔离级别以及各级别下的并发访问问题" class="headerlink" title="事务隔离级别以及各级别下的并发访问问题"></a>事务隔离级别以及各级别下的并发访问问题</h3><ul><li>更新丢失—-mysql所有事务隔离级别在数据库层面上均可避免</li><li>脏读——read-committed事务隔离级别以上可避免</li><li>不可重复读——repeatable-read事务隔离级别以上可避免</li><li>幻读—–serializable事务隔离级别可避免</li></ul><h2 id="MySQL语法"><a href="#MySQL语法" class="headerlink" title="MySQL语法"></a>MySQL语法</h2><h3 id="GROUP-BY"><a href="#GROUP-BY" class="headerlink" title="GROUP BY"></a>GROUP BY</h3><ul><li><p>[ ] 满足select选出的列<strong>要么是group by的列要么是sum，max等列函数中的列(针对一张表)</strong>。</p></li><li><p>[ ] 列函数对于group by子句定义的每个组各返回一个结果</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#查询所有同学的学号、选课数、总成绩</span><br><span class="line">select student_id, count(course_id), sum(score)</span><br><span class="line">from score</span><br><span class="line">group by student_id</span><br></pre></td></tr></table></figure><h3 id="HAVING"><a href="#HAVING" class="headerlink" title="HAVING"></a>HAVING</h3><ul><li style="list-style: none"><input type="checkbox"> 通常与GROUP BY子句一起使用</li><li style="list-style: none"><input type="checkbox"> WHERE过滤行，HAVING过滤组</li><li style="list-style: none"><input type="checkbox"> 出现在同一sql的顺序：WHERE &gt; GROUP UP &gt; HAVING</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#查询平均成绩大于60的同学的学号和平均成绩</span><br><span class="line">select student_id, avg(score)</span><br><span class="line">from score</span><br><span class="line">group by student_id,</span><br><span class="line">having avg(score)&gt;60</span><br><span class="line"></span><br><span class="line">#取出student_id为1的学生的成绩情况</span><br><span class="line">select * from score where student_id = 1;</span><br><span class="line">#如果省略group by子句，having子句行为跟where一样</span><br><span class="line">select * from score having student_id = 1;</span><br></pre></td></tr></table></figure><p>查询没有学全所有课的同学的学号、姓名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select stu.student_id, stu.name</span><br><span class="line">from score s, student stu</span><br><span class="line">where stu.student_id = s.student_id</span><br><span class="line">group by s.student_id</span><br><span class="line">having count(*) &lt;</span><br><span class="line">(</span><br><span class="line">select count(*) from course</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>查询表中name的数据，并且desc是降序排序，asc是升序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name from student order by name desc;</span><br></pre></td></tr></table></figure><p>查询表中id从1到2000000的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from table_name where id between 1 and 2000000;</span><br></pre></td></tr></table></figure><p>更新表中的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update table_name set account = newAccount  where id between 1 and 2000000;</span><br></pre></td></tr></table></figure><p>给表加锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock tables table_name read | write;</span><br></pre></td></tr></table></figure><p>释放锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unlock tables;</span><br></pre></td></tr></table></figure><p>查询事务隔离级别</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select @@tx_isolation;</span><br></pre></td></tr></table></figure><p>修改事务隔离级别为read-committed，可以避免脏读，不可以避免不可重复读</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;</span><br></pre></td></tr></table></figure><p>开始事务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">START TRANSACTION;</span><br></pre></td></tr></table></figure><p>回滚事务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROLLBACK;</span><br></pre></td></tr></table></figure><p>提交事务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COMMIT;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;索引模块&quot;&gt;&lt;a href=&quot;#索引模块&quot; class=&quot;headerlink&quot; title=&quot;索引模块&quot;&gt;&lt;/a&gt;索引模块&lt;/h2&gt;&lt;h3 id=&quot;为什么要使用索引&quot;&gt;&lt;a href=&quot;#为什么要使用索引&quot; class=&quot;headerlink&quot; title=&quot;为
      
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>ArrayList源码阅读</title>
    <link href="http://yoursite.com/2019/05/12/ArrayList%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    <id>http://yoursite.com/2019/05/12/ArrayList源码阅读/</id>
    <published>2019-05-12T15:14:41.187Z</published>
    <updated>2019-05-12T15:14:30.002Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ArrayList源码阅读"><a href="#ArrayList源码阅读" class="headerlink" title="ArrayList源码阅读"></a>ArrayList源码阅读</h1><p><strong>ArrayList继承AbstractList抽象类实现List, RandomAccess, Cloneable, java.io.Serializable</strong></p><h2 id="变量"><a href="#变量" class="headerlink" title="变量:"></a>变量:</h2><p><strong>默认容量：初始默认值为10</strong>。ArrayList是用数组实现的，如果没有定义其默认容量，则添加元素时会初始化为10，也就是默认的数组长度是10。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static final int DEFAULT_CAPACITY = 10;</span><br></pre></td></tr></table></figure><p><strong>默认数组：一个空数组</strong>。用于空实例的共享空数组实例。如果舒适化ArrayList的时候指定参数为0，则创建指向此数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br></pre></td></tr></table></figure><p><strong>默认数组：一个空数组</strong>。如果初始化ArrayList的时候没有指定参数，则默认创建此数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br></pre></td></tr></table></figure><p><strong>缓冲数组：</strong>该数组用来存储ArrayList的元素，ArrayList的容量是此缓冲数组的长度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transient Object[] elementData;</span><br></pre></td></tr></table></figure><p><strong>ArrayList大小：</strong>用来保存ArrayList有多少个元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private int size;</span><br></pre></td></tr></table></figure><p><strong>最大的容量：</strong>指定ArrayList能保存的最大容量，值为Integer.MAX_VALUE - 8;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span><br></pre></td></tr></table></figure><p><strong>被修改的次数：</strong>记录ArrayList被修改的次数，默认值为0，是继承AbstractList的变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protected transient int modCount = 0;</span><br></pre></td></tr></table></figure><h2 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h2><h4 id="带int参数的构造方法"><a href="#带int参数的构造方法" class="headerlink" title="带int参数的构造方法"></a>带int参数的构造方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList(int initialCapacity) &#123;</span><br><span class="line">    if (initialCapacity &gt; 0) &#123;</span><br><span class="line">//如果initialCapacity大于0，则把数组创建为长度</span><br><span class="line">        this.elementData = new Object[initialCapacity];</span><br><span class="line">    &#125; else if (initialCapacity == 0) &#123;</span><br><span class="line">    //等于0则指向默认的空数组</span><br><span class="line">        this.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">//小于0则抛出错误</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="不带参数的构造方法"><a href="#不带参数的构造方法" class="headerlink" title="不带参数的构造方法"></a>不带参数的构造方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList() &#123;</span><br><span class="line">//直接指向默认的空数组</span><br><span class="line">        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="带Collection对象的参数"><a href="#带Collection对象的参数" class="headerlink" title="带Collection对象的参数"></a>带Collection对象的参数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    if ((size = elementData.length) != 0) &#123;</span><br><span class="line">        // c.toArray可能返回的不是Object的对象</span><br><span class="line">        if (elementData.getClass() != Object[].class)</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 替换为空数组。</span><br><span class="line">        this.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="扩展缓冲数组的长度的方法"><a href="#扩展缓冲数组的长度的方法" class="headerlink" title="扩展缓冲数组的长度的方法"></a>扩展缓冲数组的长度的方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private void grow(int minCapacity) &#123;</span><br><span class="line">    // 保存当前的数组长度，</span><br><span class="line">    int oldCapacity = elementData.length;</span><br><span class="line">    //新的数组长度等于老的数组长度*1.5即1+0.5</span><br><span class="line">    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class="line">    //如果新的长度小于最小需要的长度，则新的长度用最小需要的长度</span><br><span class="line">    if (newCapacity - minCapacity &lt; 0)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    //如果新的数组长度大于ArrayList的最大容量，则使用最小需要的容量或者Integer.MAX_VALUE</span><br><span class="line">    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    // 扩展数组</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="扩展数组所使用的到的方法"><a href="#扩展数组所使用的到的方法" class="headerlink" title="扩展数组所使用的到的方法"></a>扩展数组所使用的到的方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private static int hugeCapacity(int minCapacity) &#123;</span><br><span class="line">    if (minCapacity &lt; 0) </span><br><span class="line">        throw new OutOfMemoryError();</span><br><span class="line">    return (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="得到ArrayList的大小（所含元素的个数）"><a href="#得到ArrayList的大小（所含元素的个数）" class="headerlink" title="得到ArrayList的大小（所含元素的个数）"></a>得到ArrayList的大小（所含元素的个数）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public int size() &#123;</span><br><span class="line">    return size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="判断ArrayList是否为空，即所含元素个数是否为0"><a href="#判断ArrayList是否为空，即所含元素个数是否为0" class="headerlink" title="判断ArrayList是否为空，即所含元素个数是否为0"></a>判断ArrayList是否为空，即所含元素个数是否为0</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean isEmpty() &#123;</span><br><span class="line">    return size == 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="判断ArrayList是否包含对象o"><a href="#判断ArrayList是否包含对象o" class="headerlink" title="判断ArrayList是否包含对象o"></a>判断ArrayList是否包含对象o</h4><p>判断o所在的位置是否大于0，若存在则必然是大于等于0；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean contains(Object o) &#123;</span><br><span class="line">    return indexOf(o) &gt;= 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="得到o的位置"><a href="#得到o的位置" class="headerlink" title="得到o的位置"></a>得到o的位置</h4><p>从缓冲数组尾部遍历，如果不存在则返回-1；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public int indexOf(Object o) &#123;</span><br><span class="line">    if (o == null) &#123;</span><br><span class="line">        for (int i = 0; i &lt; size; i++)</span><br><span class="line">            if (elementData[i]==null)</span><br><span class="line">                return i;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for (int i = 0; i &lt; size; i++)</span><br><span class="line">            if (o.equals(elementData[i]))</span><br><span class="line">                return i;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="得到对象o所在的最后一个位置"><a href="#得到对象o所在的最后一个位置" class="headerlink" title="得到对象o所在的最后一个位置"></a>得到对象o所在的最后一个位置</h4><p>从缓冲数组尾部遍历，如果不存在则返回-1；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public int lastIndexOf(Object o) &#123;</span><br><span class="line">    if (o == null) &#123;</span><br><span class="line">        for (int i = size-1; i &gt;= 0; i--)</span><br><span class="line">            if (elementData[i]==null)</span><br><span class="line">                return i;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for (int i = size-1; i &gt;= 0; i--)</span><br><span class="line">            if (o.equals(elementData[i]))</span><br><span class="line">                return i;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复制ArrayList"><a href="#复制ArrayList" class="headerlink" title="复制ArrayList"></a>复制ArrayList</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public Object clone() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) super.clone();</span><br><span class="line">        v.elementData = Arrays.copyOf(elementData, size);</span><br><span class="line">        v.modCount = 0;</span><br><span class="line">        return v;</span><br><span class="line">    &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">        // this shouldn&apos;t happen, since we are Cloneable</span><br><span class="line">        throw new InternalError(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="把ArrayList转化为数组"><a href="#把ArrayList转化为数组" class="headerlink" title="把ArrayList转化为数组"></a>把ArrayList转化为数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Object[] toArray() &#123;</span><br><span class="line">    return Arrays.copyOf(elementData, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="返回一个新的a数组类型的数组"><a href="#返回一个新的a数组类型的数组" class="headerlink" title="返回一个新的a数组类型的数组"></a>返回一个新的a数组类型的数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">    if (a.length &lt; size)</span><br><span class="line">  //如果a数组长度小于ArrayList的元素个数，返回一个新的数组，并把ArrayList的元素存入其中</span><br><span class="line">        return (T[]) Arrays.copyOf(elementData, size, a.getClass());</span><br><span class="line">    //把ArrayList的元素存入a中</span><br><span class="line">    System.arraycopy(elementData, 0, a, 0, size);</span><br><span class="line">    //让a[size]置为null，但是并没有清空a数组之后的元素</span><br><span class="line">    if (a.length &gt; size)</span><br><span class="line">        a[size] = null;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="返回缓冲数组的elementData-index-元素，这是一个default方法"><a href="#返回缓冲数组的elementData-index-元素，这是一个default方法" class="headerlink" title="返回缓冲数组的elementData[index]元素，这是一个default方法"></a>返回缓冲数组的elementData[index]元素，这是一个default方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">E elementData(int index) &#123;</span><br><span class="line">    return (E) elementData[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="通过index返回ArrayList的元素方法"><a href="#通过index返回ArrayList的元素方法" class="headerlink" title="通过index返回ArrayList的元素方法"></a>通过index返回ArrayList的元素方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public E get(int index) &#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    return elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="判断index是否合法，即index要小于ArrayList元素的个数"><a href="#判断index是否合法，即index要小于ArrayList元素的个数" class="headerlink" title="判断index是否合法，即index要小于ArrayList元素的个数"></a>判断index是否合法，即index要小于ArrayList元素的个数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private void rangeCheck(int index) &#123;</span><br><span class="line">    if (index &gt;= size)</span><br><span class="line">        throw new IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="设置ArrayList的index位置的值为element并返回之前的值"><a href="#设置ArrayList的index位置的值为element并返回之前的值" class="headerlink" title="设置ArrayList的index位置的值为element并返回之前的值"></a>设置ArrayList的index位置的值为element并返回之前的值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public E set(int index, E element) &#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    return oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="往ArrayList的尾部加入一个元素"><a href="#往ArrayList的尾部加入一个元素" class="headerlink" title="往ArrayList的尾部加入一个元素"></a>往ArrayList的尾部加入一个元素</h4><p>如果没有初始化数组长度，则第一次添加元素会把ArrayList的缓冲数组长度置为DEFAULT_CAPACITY即10。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">//确保ArrayList的容量足够，也就是缓冲数组是否已经存满，如果满了要扩展数组</span><br><span class="line">    ensureCapacityInternal(size + 1); </span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="执行扩展缓冲数组的方法"><a href="#执行扩展缓冲数组的方法" class="headerlink" title="执行扩展缓冲数组的方法"></a>执行扩展缓冲数组的方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private void ensureExplicitCapacity(int minCapacity) &#123;</span><br><span class="line">//增加了ArrayList对象的修改次数</span><br><span class="line">    modCount++;</span><br><span class="line">//扩展数组</span><br><span class="line">    if (minCapacity - elementData.length &gt; 0)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="确保ArrayList容量的方法"><a href="#确保ArrayList容量的方法" class="headerlink" title="确保ArrayList容量的方法"></a>确保ArrayList容量的方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private void ensureCapacityInternal(int minCapacity) &#123;</span><br><span class="line">//如果是缓冲数组是默认的空数组即初始化ArrayList时没有传入参数</span><br><span class="line">//则会判断默认的初始化数组长度和最小所需的长度，即添加第一个元素的时候默认初始数组长度为10</span><br><span class="line">    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="移除ArrayList的index下标的元素"><a href="#移除ArrayList的index下标的元素" class="headerlink" title="移除ArrayList的index下标的元素"></a>移除ArrayList的index下标的元素</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public E remove(int index) &#123;</span><br><span class="line">//越界检查</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">//ArrayList对象修改的次数+1</span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">//要移动的数组的长度</span><br><span class="line">    int numMoved = size - index - 1;</span><br><span class="line">    //把index之后的元素往前移1位</span><br><span class="line">    if (numMoved &gt; 0)</span><br><span class="line">        System.arraycopy(elementData, index+1, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = null; // 清空最后一位。并且把size-1</span><br><span class="line"></span><br><span class="line">    return oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="根据元素删除ArrayList的元素"><a href="#根据元素删除ArrayList的元素" class="headerlink" title="根据元素删除ArrayList的元素"></a>根据元素删除ArrayList的元素</h4><p>如果存在则删除并返回true，不存在则返回false；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">    if (o == null) &#123;</span><br><span class="line">        for (int index = 0; index &lt; size; index++)</span><br><span class="line">            if (elementData[index] == null) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for (int index = 0; index &lt; size; index++)</span><br><span class="line">            if (o.equals(elementData[index])) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="跟remove相似的功能，用于remove-Object-o-方法"><a href="#跟remove相似的功能，用于remove-Object-o-方法" class="headerlink" title="跟remove相似的功能，用于remove(Object o)方法"></a>跟remove相似的功能，用于remove(Object o)方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private void fastRemove(int index) &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    int numMoved = size - index - 1;</span><br><span class="line">    if (numMoved &gt; 0)</span><br><span class="line">        System.arraycopy(elementData, index+1, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = null; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="清空ArrayList"><a href="#清空ArrayList" class="headerlink" title="清空ArrayList"></a>清空ArrayList</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void clear() &#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; size; i++)</span><br><span class="line">        elementData[i] = null;</span><br><span class="line"></span><br><span class="line">    size = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="添加Collection的所有元素"><a href="#添加Collection的所有元素" class="headerlink" title="添加Collection的所有元素"></a>添加Collection的所有元素</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public boolean addAll(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    int numNew = a.length;</span><br><span class="line">    ensureCapacityInternal(size + numNew);  // 确保缓冲数组容量足够</span><br><span class="line">    // 把a的所有元素添加到数组的后面</span><br><span class="line">    System.arraycopy(a, 0, elementData, size, numNew);</span><br><span class="line">    size += numNew;</span><br><span class="line">    return numNew != 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="添加Collection的所有元素在index的位置"><a href="#添加Collection的所有元素在index的位置" class="headerlink" title="添加Collection的所有元素在index的位置"></a>添加Collection的所有元素在index的位置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    int numNew = a.length;</span><br><span class="line">    ensureCapacityInternal(size + numNew); </span><br><span class="line"></span><br><span class="line">    int numMoved = size - index;</span><br><span class="line">    if (numMoved &gt; 0)</span><br><span class="line">    //把index后面的所有元素往后移插入元素个数个位子</span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + numNew,</span><br><span class="line">                         numMoved);</span><br><span class="line">//把c的元素放到index之后</span><br><span class="line">    System.arraycopy(a, 0, elementData, index, numNew);</span><br><span class="line">    size += numNew;</span><br><span class="line">    return numNew != 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="把ArrayList元素中c的元素全部移除"><a href="#把ArrayList元素中c的元素全部移除" class="headerlink" title="把ArrayList元素中c的元素全部移除"></a>把ArrayList元素中c的元素全部移除</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public boolean removeAll(Collection&lt;?&gt; c) &#123;</span><br><span class="line">//判断c是否为空</span><br><span class="line">    Objects.requireNonNull(c);</span><br><span class="line">    return batchRemove(c, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="批量删除方法"><a href="#批量删除方法" class="headerlink" title="批量删除方法"></a>批量删除方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) &#123;</span><br><span class="line">    final Object[] elementData = this.elementData;</span><br><span class="line">    int r = 0, w = 0;</span><br><span class="line">    boolean modified = false;</span><br><span class="line">    try &#123;</span><br><span class="line">        for (; r &lt; size; r++)</span><br><span class="line">        //如果complement是false</span><br><span class="line">        //则把不是c的元素往前聚凑在elementData的最前面</span><br><span class="line">        //反之就是把c的元素聚凑在elementData中</span><br><span class="line">            if (c.contains(elementData[r]) == complement)</span><br><span class="line">                elementData[w++] = elementData[r];</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        //保持与AbstractCollection的行为兼容性，</span><br><span class="line">        //即使c.contains（）抛出。</span><br><span class="line">        if (r != size) &#123;</span><br><span class="line">            System.arraycopy(elementData, r,</span><br><span class="line">                             elementData, w,</span><br><span class="line">                             size - r);</span><br><span class="line">            w += size - r;</span><br><span class="line">        &#125;</span><br><span class="line">        //把w之后的元素全部清除</span><br><span class="line">        if (w != size) &#123;</span><br><span class="line">            // clear to let GC do its work</span><br><span class="line">            for (int i = w; i &lt; size; i++)</span><br><span class="line">                elementData[i] = null;</span><br><span class="line">            modCount += size - w;</span><br><span class="line">            size = w;</span><br><span class="line">            modified = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return modified;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="只保存ArrayList中c的元素"><a href="#只保存ArrayList中c的元素" class="headerlink" title="只保存ArrayList中c的元素"></a>只保存ArrayList中c的元素</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public boolean removeAll(Collection&lt;?&gt; c) &#123;</span><br><span class="line">    Objects.requireNonNull(c);</span><br><span class="line">    return batchRemove(c, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="返回一个迭代器，操作的对象为ArrayList下标index的元素"><a href="#返回一个迭代器，操作的对象为ArrayList下标index的元素" class="headerlink" title="返回一个迭代器，操作的对象为ArrayList下标index的元素"></a>返回一个迭代器，操作的对象为ArrayList下标index的元素</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public ListIterator&lt;E&gt; listIterator(int index) &#123;</span><br><span class="line">    if (index &lt; 0 || index &gt; size)</span><br><span class="line">        throw new IndexOutOfBoundsException(&quot;Index: &quot;+index);</span><br><span class="line">    return new ListItr(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="返回一个迭代器"><a href="#返回一个迭代器" class="headerlink" title="返回一个迭代器"></a>返回一个迭代器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public ListIterator&lt;E&gt; listIterator() &#123;</span><br><span class="line">    return new ListItr(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="对ArrayList进行排序"><a href="#对ArrayList进行排序" class="headerlink" title="对ArrayList进行排序"></a>对ArrayList进行排序</h4><p>根据的是Comparator对象c重写的compare方法去排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void sort(Comparator&lt;? super E&gt; c) &#123;</span><br><span class="line">    final int expectedModCount = modCount;</span><br><span class="line">    Arrays.sort((E[]) elementData, 0, size, c);</span><br><span class="line">    if (modCount != expectedModCount) &#123;</span><br><span class="line">        throw new ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><h3 id="Itr类实现Iterator接口"><a href="#Itr类实现Iterator接口" class="headerlink" title="Itr类实现Iterator接口"></a>Itr类实现Iterator接口</h3><p>AbstractList.Itr的优化版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">private class Itr implements Iterator&lt;E&gt; &#123;</span><br><span class="line">    int cursor;       // 要返回的下一个元素的索引</span><br><span class="line">    int lastRet = -1; // 返回最后一个元素的索引;</span><br><span class="line">    int expectedModCount = modCount;</span><br><span class="line">//如果cursor不是指向最后一个元素则还有下一个元素</span><br><span class="line">    public boolean hasNext() &#123;</span><br><span class="line">        return cursor != size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public E next() &#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        int i = cursor;</span><br><span class="line">        //越界判断</span><br><span class="line">        if (i &gt;= size)</span><br><span class="line">            throw new NoSuchElementException();</span><br><span class="line">        Object[] elementData = ArrayList.this.elementData;</span><br><span class="line">        if (i &gt;= elementData.length)</span><br><span class="line">            throw new ConcurrentModificationException();</span><br><span class="line">        cursor = i + 1;</span><br><span class="line">        return (E) elementData[lastRet = i];</span><br><span class="line">    &#125;</span><br><span class="line">//调用了ArrayList的remove方法去移除最后一个元素</span><br><span class="line">    public void remove() &#123;</span><br><span class="line">        if (lastRet &lt; 0)</span><br><span class="line">            throw new IllegalStateException();</span><br><span class="line">        checkForComodification();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            ArrayList.this.remove(lastRet);</span><br><span class="line">            cursor = lastRet;</span><br><span class="line">            lastRet = -1;</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">        &#125; catch (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">            throw new ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public void forEachRemaining(Consumer&lt;? super E&gt; consumer) &#123;</span><br><span class="line">        Objects.requireNonNull(consumer);</span><br><span class="line">        final int size = ArrayList.this.size;</span><br><span class="line">        int i = cursor;</span><br><span class="line">        if (i &gt;= size) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        final Object[] elementData = ArrayList.this.elementData;</span><br><span class="line">        if (i &gt;= elementData.length) &#123;</span><br><span class="line">            throw new ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">        while (i != size &amp;&amp; modCount == expectedModCount) &#123;</span><br><span class="line">            consumer.accept((E) elementData[i++]);</span><br><span class="line">        &#125;</span><br><span class="line">        // update once at end of iteration to reduce heap write traffic</span><br><span class="line">        cursor = i;</span><br><span class="line">        lastRet = i - 1;</span><br><span class="line">        checkForComodification();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final void checkForComodification() &#123;</span><br><span class="line">        if (modCount != expectedModCount)</span><br><span class="line">            throw new ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ListItr类"><a href="#ListItr类" class="headerlink" title="ListItr类"></a>ListItr类</h3><p>ListItr继承了Itr类并实现ListIterator接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">private class ListItr extends Itr implements ListIterator&lt;E&gt; &#123;</span><br><span class="line">    ListItr(int index) &#123;</span><br><span class="line">        super();</span><br><span class="line">        cursor = index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean hasPrevious() &#123;</span><br><span class="line">        return cursor != 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int nextIndex() &#123;</span><br><span class="line">        return cursor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int previousIndex() &#123;</span><br><span class="line">        return cursor - 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public E previous() &#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        int i = cursor - 1;</span><br><span class="line">        if (i &lt; 0)</span><br><span class="line">            throw new NoSuchElementException();</span><br><span class="line">        Object[] elementData = ArrayList.this.elementData;</span><br><span class="line">        if (i &gt;= elementData.length)</span><br><span class="line">            throw new ConcurrentModificationException();</span><br><span class="line">        cursor = i;</span><br><span class="line">        return (E) elementData[lastRet = i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void set(E e) &#123;</span><br><span class="line">        if (lastRet &lt; 0)</span><br><span class="line">            throw new IllegalStateException();</span><br><span class="line">        checkForComodification();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            ArrayList.this.set(lastRet, e);</span><br><span class="line">        &#125; catch (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">            throw new ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void add(E e) &#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            int i = cursor;</span><br><span class="line">            ArrayList.this.add(i, e);</span><br><span class="line">            cursor = i + 1;</span><br><span class="line">            lastRet = -1;</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">        &#125; catch (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">            throw new ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ArrayList源码阅读&quot;&gt;&lt;a href=&quot;#ArrayList源码阅读&quot; class=&quot;headerlink&quot; title=&quot;ArrayList源码阅读&quot;&gt;&lt;/a&gt;ArrayList源码阅读&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;ArrayList继承Abstrac
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode131. 分割回文串</title>
    <link href="http://yoursite.com/2019/05/12/leetcode131.%20%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2/"/>
    <id>http://yoursite.com/2019/05/12/leetcode131. 分割回文串/</id>
    <published>2019-05-12T07:43:20.588Z</published>
    <updated>2019-05-12T10:57:56.775Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。</p><p>返回 s 所有可能的分割方案。</p><p><strong>示例:</strong></p><p><strong>输入:</strong> “aab”<br><strong>输出:</strong> [   [“aa”,”b”],   [“a”,”a”,”b”] ]</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>判断字符串s从[0,i)是否是回文串：<br>如果是，则放入list，然后继续深度遍历s[i,s.len]，在深度结束时移除。<br>如果不是，则不做处理。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        dfs(res, list, s);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void dfs(List&lt;List&lt;String&gt;&gt; res, List&lt;String&gt; list, String s) &#123;</span><br><span class="line">        //如果s为空，则说明所有的子串都已经加入list,此时是深度的出头</span><br><span class="line">        if (s.equals(&quot;&quot;)) &#123;</span><br><span class="line">            res.add(new ArrayList&lt;&gt;(list));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        char[] chars = s.toCharArray();</span><br><span class="line">        int len = chars.length;</span><br><span class="line">        //从[0,1)判断到[0,len)</span><br><span class="line">        for (int i = 1; i &lt;= len; i++) &#123;</span><br><span class="line">            if (helper(chars, i)) &#123;</span><br><span class="line">                list.add(s.substring(0,i));</span><br><span class="line">                dfs(res, list, s.substring(i));</span><br><span class="line">                list.remove(list.size()-1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //判断chars[0]到chars[len]是否是回文串</span><br><span class="line">    public boolean helper(char[] chars, int len) &#123;</span><br><span class="line">        for (int i = 0; i &lt; len / 2; i++) &#123;</span><br><span class="line">            if (chars[i] != chars[len - i - 1])</span><br><span class="line">                return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 6 ms, 在Palindrome Partitioning的Java提交中击败了89.23% 的用户<br>内存消耗 : 48.6 MB, 在Palindrome Partitioning的Java提交中击败了62.19% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。&lt;/p&gt;
&lt;p&gt;返回 s 所有可能的分割方案。&lt;
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode130. 被围绕的区域</title>
    <link href="http://yoursite.com/2019/05/11/leetcode130.%20%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F/"/>
    <id>http://yoursite.com/2019/05/11/leetcode130. 被围绕的区域/</id>
    <published>2019-05-11T06:59:01.628Z</published>
    <updated>2019-05-11T07:07:48.815Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个二维的矩阵，包含 ‘X’ 和 ‘O’（字母 O）。</p><p>找到所有被 ‘X’ 围绕的区域，并将这些区域里所有的 ‘O’ 用 ‘X’ 填充。</p><p><strong>示例:</strong></p><p>X X X X X O O X X X O X X O X X 运行你的函数后，矩阵变为：</p><p>X X X X X X X X X X X X X O X X<br><strong>解释:</strong></p><p>被围绕的区间不会存在于边界上，换句话说，任何边界上的 ‘O’ 都不会被填充为 ‘X’。 任何不在边界上，或不与边界上的 ‘O’ 相连的<br>‘O’ 最终都会被填充为 ‘X’。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>创建一个数组states判断他是否被围绕，遍历外围的字符，如果是O的则遍历它旁边的字符，与<strong>外围O连接的O才不会被围绕</strong>，深度遍历即可。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void solve(char[][] board) &#123;</span><br><span class="line">int n = board.length;</span><br><span class="line">if(n &lt; 2) return;;</span><br><span class="line">int m = board[0].length;</span><br><span class="line">if(m &lt; 2) return;</span><br><span class="line">boolean[][] states = new boolean[n][m];</span><br><span class="line">//上下2行</span><br><span class="line">for(int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">helper(board, states, n-1, j);</span><br><span class="line">helper(board, states, 0, j);</span><br><span class="line">&#125;</span><br><span class="line">//左右2列</span><br><span class="line">for(int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">helper(board, states, i, 0);</span><br><span class="line">helper(board, states, i, m-1);</span><br><span class="line">&#125;</span><br><span class="line">//更新数组</span><br><span class="line">for(int i = 0; i &lt; n; i ++)&#123;</span><br><span class="line">for(int j = 0; j &lt; m; j ++)&#123;</span><br><span class="line">                if(!states[i][j] &amp;&amp; board[i][j] == &apos;O&apos;)</span><br><span class="line">board[i][j] = &apos;X&apos;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public void helper(char[][] board, boolean[][] states, int i, int j) &#123;</span><br><span class="line">//判断是否越界</span><br><span class="line">if(i &lt; 0 || i &gt;= board.length || j &lt; 0 || j &gt;= board[0].length) &#123;</span><br><span class="line">return ;</span><br><span class="line">&#125;</span><br><span class="line">//为X直接跳过</span><br><span class="line">if(board[i][j] == &apos;X&apos;) &#123;</span><br><span class="line">return ;</span><br><span class="line">&#125;</span><br><span class="line">//如果为true则已经判断不会被围绕了</span><br><span class="line">if(!states[i][j])&#123;</span><br><span class="line">states[i][j] = true;</span><br><span class="line">//把相连的O置为true</span><br><span class="line">helper(board, states, i, j+1);</span><br><span class="line">helper(board, states, i+1, j);</span><br><span class="line">helper(board, states, i-1, j);</span><br><span class="line">helper(board, states, i, j-1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 4 ms, 在Surrounded Regions的Java提交中击败了85.99% 的用户<br>内存消耗 : 48.1 MB, 在Surrounded Regions的Java提交中击败了49.18% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个二维的矩阵，包含 ‘X’ 和 ‘O’（字母 O）。&lt;/p&gt;
&lt;p&gt;找到所有被 ‘X’ 围绕的区域，并将这些
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode129. 求根到叶子节点数字之和 (1)</title>
    <link href="http://yoursite.com/2019/05/11/leetcode129.%20%E6%B1%82%E6%A0%B9%E5%88%B0%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C%20(1)/"/>
    <id>http://yoursite.com/2019/05/11/leetcode129. 求根到叶子节点数字之和 (1)/</id>
    <published>2019-05-11T06:01:16.825Z</published>
    <updated>2019-05-11T07:08:04.189Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。</p><p>例如，从根到叶子节点路径 1-&gt;2-&gt;3 代表数字 123。</p><p>计算从根到叶子节点生成的所有数字之和。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p><strong>示例 1:</strong></p><p><strong>输入:</strong> [1,2,3]<br>    <img src="https://img-blog.csdnimg.cn/20190511135419415.png" alt="1    / \   2   3"><br><strong>输出:</strong> 25<br><strong>解释:</strong> 从根到叶子节点路径 1-&gt;2 代表数字 12. 从根到叶子节点路径 1-&gt;3 代表数字 13. 因此，数字总和 = 12 + 13 = 25.<br><strong>示例 2:</strong></p><p><strong>输入:</strong> [4,9,0,5,1]<br>    <img src="https://img-blog.csdnimg.cn/20190511135437697.png" alt="4    / \   9   0  / \ 5   1"><br><strong>输出:</strong> 1026<br><strong>解释:</strong> 从根到叶子节点路径 4-&gt;9-&gt;5 代表数字 495. 从根到叶子节点路径 4-&gt;9-&gt;1 代表数字 491. 从根到叶子节点路径 4-&gt;0 代表数字 40. 因此，数字总和 = 495 + 491 + 40 = 1026.</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这是一道比较简单的dfs问题，直接把当前结点和当前的和作为参数进行深度，每次把当前的和*10然后加上当前结点的值继续深度遍历即可。<br>传递一个数组是因为要记录结果，也可以使用成员变量去做。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public int sumNumbers(TreeNode root) &#123;</span><br><span class="line">if(root == null) return 0;</span><br><span class="line">int[] res = &#123;0&#125;;</span><br><span class="line">dfs(root, root.val, res);</span><br><span class="line">return res[0];</span><br><span class="line">&#125;</span><br><span class="line">public void dfs(TreeNode root, int sum, int[] res) &#123;</span><br><span class="line">if(root.left == null &amp;&amp; root.right == null) &#123;</span><br><span class="line">res[0] += sum;</span><br><span class="line">return ;</span><br><span class="line">&#125;</span><br><span class="line">if(root.left != null)</span><br><span class="line"> dfs(root.left, sum*10 + root.left.val, res);</span><br><span class="line">if(root.right != null)</span><br><span class="line">dfs(root.right, sum*10 + root.right.val, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 1 ms, 在Sum Root to Leaf Numbers的Java提交中击败了94.38% 的用户<br>内存消耗 : 34.6 MB, 在Sum Root to Leaf Numbers的Java提交中击败了46.90% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。&lt;/p&gt;
&lt;p&gt;例
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode127. 单词接龙</title>
    <link href="http://yoursite.com/2019/05/10/leetcode127.%20%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99/"/>
    <id>http://yoursite.com/2019/05/10/leetcode127. 单词接龙/</id>
    <published>2019-05-10T15:08:11.005Z</published>
    <updated>2019-05-10T15:19:42.689Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord<br>的最短转换序列的长度。转换需遵循如下规则：</p><p>每次转换只能改变一个字母。 转换过程中的中间单词必须是字典中的单词。<br><strong>说明:</strong></p><p>如果不存在这样的转换序列，返回 0。 所有单词具有相同的长度。 所有单词只由小写字母组成。 字典中不存在重复的单词。 你可以假设<br>beginWord 和 endWord 是非空的，且二者不相同。<br><strong>示例 1:</strong></p><p><strong>输入:</strong> beginWord = “hit”, endWord = “cog”, wordList = [“hot”,”dot”,”dog”,”lot”,”log”,”cog”]</p><p><strong>输出: 5</strong></p><p><strong>解释:</strong> 一个最短转换序列是 “hit” -&gt; “hot” -&gt; “dot” -&gt; “dog” -&gt; “cog”,<br>     返回它的长度 5。<br><strong>示例 2:</strong></p><p><strong>输入:</strong> beginWord = “hit” endWord = “cog” wordList = [“hot”,”dot”,”dog”,”lot”,”log”]</p><p><strong>输出:</strong> 0</p><p><strong>解释:</strong> endWord “cog” 不在字典中，所以无法进行转换。</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>就是找出图的最短路径，从beginWord出发，找出能到达的点；然后再遍历能到达的点，找到其能到达的点，一直查询直到到达endWord或者全部到达终点即不能再到达其他点。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public int ladderLength(String beginWord, String endWord, List&lt;String&gt; wordList) &#123;</span><br><span class="line">        HashSet&lt;String&gt; wordSet = new HashSet&lt;&gt;(wordList);</span><br><span class="line">        if(!wordSet.contains(endWord)) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        //记录已经使用过的结点</span><br><span class="line">        HashMap&lt;String, Integer&gt; stateMap = new HashMap&lt;&gt;();</span><br><span class="line">        HashSet&lt;String&gt; bs = new HashSet&lt;&gt;();</span><br><span class="line">        bs.add(beginWord);</span><br><span class="line">        Queue&lt;String&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(beginWord);</span><br><span class="line">        //记录原点，并记录路径长度</span><br><span class="line">        stateMap.put(beginWord, 1);</span><br><span class="line">        while(!queue.isEmpty()) &#123;</span><br><span class="line">            String word = queue.poll();</span><br><span class="line">            int level = stateMap.get(word);</span><br><span class="line">            for(int i = 0; i &lt; wordList.size(); i ++) &#123;</span><br><span class="line">                String newWord = wordList.get(i);</span><br><span class="line">                if(helper(word, newWord)) &#123;</span><br><span class="line">                    //已经走过的点的路径就是最短的了 可以直接去掉</span><br><span class="line">                    wordList.remove(i--);</span><br><span class="line">                    if(newWord.equals(endWord)) return level + 1;</span><br><span class="line">                    stateMap.put(newWord, level+1);</span><br><span class="line">                    //把能走的点放入队列，继续判断可到达的点</span><br><span class="line">                    queue.add(newWord);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">public boolean helper(String word, String beginWord) &#123;</span><br><span class="line">int cnt = 0, len = word.length();</span><br><span class="line">for(int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">if(word.charAt(i) != beginWord.charAt(i)) cnt++;</span><br><span class="line">if(cnt &gt; 1) return  false;</span><br><span class="line">&#125;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 277 ms, 在Word Ladder的Java提交中击败了50.48% 的用户<br>内存消耗 : 41.1 MB, 在Word Ladder的Java提交中击败了66.22% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord&lt;
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-B树</title>
    <link href="http://yoursite.com/2019/05/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-B%E6%A0%91/"/>
    <id>http://yoursite.com/2019/05/10/数据结构-B树/</id>
    <published>2019-05-10T08:23:52.696Z</published>
    <updated>2019-05-10T15:19:20.161Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-B树的定义"><a href="#1-B树的定义" class="headerlink" title="1.    B树的定义"></a>1.    B树的定义</h2><p>B树是为磁盘或其他直接存取的辅助存储设备而设计的一种平衡搜索树。<br>一棵B树T是具有以下性质的有根树（根为T.root）：</p><ol><li><p>每个结点x有下面的属性：<br>a)    x.n，当前存储在结点x中的关键字个数。<br>b)    x.n个关键字本身x.key1，x.key2，……，x.keyn，以非降序存放，使得x.key1≤x.key2≤……≤x.keyn。<br>c)    x.leaf，一个布尔值，如果x是叶结点则为true；如果x为内部结点，则为false。</p></li><li><p>每个内部结点x还包含x.n+1个指向其孩子的指针x.c1，x.c2，……，x.cx.n+1。叶结点没有孩子，所以他们的ci属性没有定义。</p></li><li>关键字x.keyi对存储在各子树中的关键字范围加以分割：如果ki为任意一个存储在以x.ci为根的子树中的关键字，那么<br>k1≤x.key1≤k2≤x.key2≤……≤x.keyn≤x.keyn+1<br>即父节点的关键字把子节点的关键字按大小分隔开。</li><li>每个叶结点具有相同的深度，即树的高度h。</li><li>每个结点所包含的关键字个数有上界和下界。用一个被称为B树的最小度数的固定整数t≥2来表示这些界：<br>a)    除了根节点以外的每个结点必须至少有t-1个关键字。因此，除了根节点以外的每个内部结点至少有t个孩子。如果树非空，根结点至少有一个关键字。<br>b)    每个结点至多可包含2t-1个关键字。因此，一个内部结点之多可有2t个孩子。当一个结点恰好有2t-1个关键字是，称该结点是满的。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-B树的定义&quot;&gt;&lt;a href=&quot;#1-B树的定义&quot; class=&quot;headerlink&quot; title=&quot;1.    B树的定义&quot;&gt;&lt;/a&gt;1.    B树的定义&lt;/h2&gt;&lt;p&gt;B树是为磁盘或其他直接存取的辅助存储设备而设计的一种平衡搜索树。&lt;br&gt;一棵B树T是
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>1_Collection接口</title>
    <link href="http://yoursite.com/2019/05/10/1_Collection%E6%8E%A5%E5%8F%A3/"/>
    <id>http://yoursite.com/2019/05/10/1_Collection接口/</id>
    <published>2019-05-10T00:41:14.062Z</published>
    <updated>2019-05-10T00:42:13.011Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-1-List接口"><a href="#1-1-List接口" class="headerlink" title="1.1 List接口"></a>1.1 List接口</h2><h3 id="1-1-1-ArrayList"><a href="#1-1-1-ArrayList" class="headerlink" title="1.1.1 ArrayList"></a>1.1.1 ArrayList</h3><p>1、    实现原理：采用动态数组对象实现，默认构造方法创建了一个空数组<br>2、    第一次添加元素，扩展容量为10，之后的扩充算法：原来数组大小+原来数组的一半<br>3、    不适合进行删除或插入操作<br>4、    为了防止数组动态的扩充次数过多，建议创建ArrayList时，给定初始容量<br>5、    线程不安全，适合在单线程访问时使用</p><h3 id="1-1-2-Vector"><a href="#1-1-2-Vector" class="headerlink" title="1.1.2 Vector"></a>1.1.2 Vector</h3><p>1、    实现原理：采用动态数组对象实现，默认构造方法创建了一个大小为10的对象数组<br>2、    扩充算法：当增量小于等于0时，扩充为原来的2倍，当增量大于0时，扩充为原来数组大小+增量。<br>3、    不适合删除或插入操作。<br>4、    为了防止数组动态的扩充次数过多，建议创建Vector时，给定初始容量<br>5、    线程安全，适合在多线程时访问使用；效率较低。</p><h3 id="1-1-3-LinkedList"><a href="#1-1-3-LinkedList" class="headerlink" title="1.1.3 LinkedList"></a>1.1.3 LinkedList</h3><p>1、    实现原理：采用双向链表结构实现<br>2、    适合插入，删除操作，性能高<br>如何选择List的具体实现？<br>1、    安全性问题<br>2、    是否频繁插入，删除操作（LinkedList）<br>3、    是否是存储后遍历</p><h2 id="1-2-Set接口"><a href="#1-2-Set接口" class="headerlink" title="1.2 Set接口"></a>1.2 Set接口</h2><p>1、    无序的，不保证顺序<br>2、    不允许重复元素</p><h3 id="1-2-1-HashSet"><a href="#1-2-1-HashSet" class="headerlink" title="1.2.1  HashSet"></a>1.2.1  HashSet</h3><p>1、实现原理：基于哈希表（HashMap）实现<br>2、不允许重复，可以有一个null<br>3、不保证顺序恒久不变<br>4、添加元素时，把元素作为HashMap的key，HashMap的value使用一个固定的Object对象<br>5、排除重复元素是通过equals来判断的（关键）<br>6、判断两个对象是否相同，先判断两个对象的hashCode是否相同（如果hashCode相同，不一定是同一个对象，如果不同，则一定不是同一个对象），如果不同，则两个对象不是用一个对象，如果相同，还要进行equals判断，如果相同是同一个对象，如果不同则不是同一个对象<br>7、自定义对象要认为属性值相同时为同一个对象，有这种需求时，那么我们要重写对象所在类的 hashCode和 equas方法</p><h3 id="1-2-2-TreeSet"><a href="#1-2-2-TreeSet" class="headerlink" title="1.2.2  TreeSet"></a>1.2.2  TreeSet</h3><p>1、有序的，基于TreeMap（二叉树结构），对象需要比较大小，通过对象比较器来实现<br>2、对象比较器还可以用来去除重复元素，没有实现比较器接口，将无法添加到TreeSet集合中</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-1-List接口&quot;&gt;&lt;a href=&quot;#1-1-List接口&quot; class=&quot;headerlink&quot; title=&quot;1.1 List接口&quot;&gt;&lt;/a&gt;1.1 List接口&lt;/h2&gt;&lt;h3 id=&quot;1-1-1-ArrayList&quot;&gt;&lt;a href=&quot;#1-1-1-
      
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode120. 三角形最小路径和</title>
    <link href="http://yoursite.com/2019/05/09/leetcode120.%20%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
    <id>http://yoursite.com/2019/05/09/leetcode120. 三角形最小路径和/</id>
    <published>2019-05-09T03:09:24.829Z</published>
    <updated>2019-05-09T11:48:31.336Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><pre><code>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。例如，给定三角形：    [         [2],        [3,4],       [6,5,7],      [4,1,8,3]    ]自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。说明：如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。</code></pre><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p><strong>上一行的点index只能走下一行的index和index+1</strong>这2个下标，所以自底向上的做法来维护一个dp数组，可以得出dp[index] = Math.min(dp[index], dp[index+1]) + list.get(index);<br><strong>下一行的点index只能走上一行的 index-1和index</strong>,所以自顶向下的做法可得出dp[index] = Math.min(dp[index-1], dp[index]) + list.get(index);</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123;</span><br><span class="line">        /**</span><br><span class="line">         * 自顶向下</span><br><span class="line">         */</span><br><span class="line">        int size = triangle.size();</span><br><span class="line">        if(size == 0) return 0;</span><br><span class="line">        int[] dp = new int[size];</span><br><span class="line">        dp[0] = triangle.get(0).get(0);</span><br><span class="line">        //排除后面的数据的干扰</span><br><span class="line">        for(int i = 1; i &lt; size; i ++) &#123;</span><br><span class="line">            dp[i] = Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 1; i &lt; size; i ++) &#123;</span><br><span class="line">            List&lt;Integer&gt; list = triangle.get(i);</span><br><span class="line">            //dp改变后对后面的数据有影响</span><br><span class="line">            int[] tmp = Arrays.copyOf(dp, size);</span><br><span class="line">            for(int j = 0; j &lt;= i; j ++) &#123;</span><br><span class="line">                dp[j] = list.get(j) + (j-1&gt;=0 ? Math.min(tmp[j-1], tmp[j]) : tmp[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //不知道最小的值在哪里 仍需要再遍历一遍数组</span><br><span class="line">        int res = Integer.MAX_VALUE;</span><br><span class="line">        for(int i = 0; i &lt; size; i ++) &#123;</span><br><span class="line">            res = Math.min(dp[i], res);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">        /**</span><br><span class="line">         * 自底向上的做法</span><br><span class="line">         * 直接从后面走到最上面解决</span><br><span class="line">         */</span><br><span class="line">        /*int size = triangle.size();</span><br><span class="line">        if(size == 0) return 0;</span><br><span class="line">        int[] dp = new int[size];</span><br><span class="line">        List&lt;Integer&gt; list = triangle.get(size-1);</span><br><span class="line">        for(int i = 0; i &lt; size; i ++) &#123;</span><br><span class="line">            dp[i] = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = size-2; i &gt;= 0; i --) &#123;</span><br><span class="line">            list = triangle.get(i);</span><br><span class="line">            for(int j = 0; j &lt;= i; j ++) &#123;</span><br><span class="line">                dp[j] = Math.min(dp[j], dp[j+1]) + list.get(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[0];*/</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 4 ms, 在Triangle的Java提交中击败了95.80% 的用户<br>内存消耗 : 35.4 MB, 在Triangle的Java提交中击败了95.85% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。

例如，给定三角形：

    [
   
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode117. 填充每个节点的下一个右侧节点指针 II</title>
    <link href="http://yoursite.com/2019/05/08/leetcode117.%20%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88%20II/"/>
    <id>http://yoursite.com/2019/05/08/leetcode117. 填充每个节点的下一个右侧节点指针 II/</id>
    <published>2019-05-08T13:33:51.544Z</published>
    <updated>2019-05-08T13:33:49.509Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个二叉树</p><pre><code>struct Node {  int val;  Node *left;  Node *right;  Node *next;}</code></pre><p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p><p>初始状态下，所有 next 指针都被设置为 NULL。<br><img src="https://img-blog.csdnimg.cn/20190508212123665.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDQ4NTc0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这题使用队列来解决思路比较清晰，把每一层的结点放入队列中，在每一层的后面放入一个null作为每一层的结束结点，每次都把每一层的前一个结点的next指向下一个即可。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public Node connect(Node root) &#123;</span><br><span class="line">        if(root == null) return null;</span><br><span class="line">        Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        queue.add(null);</span><br><span class="line">        while(!queue.isEmpty()) &#123;</span><br><span class="line">            Node preNode = queue.remove();</span><br><span class="line">            Node nextNode = queue.peek();</span><br><span class="line">            preNode.next = nextNode;</span><br><span class="line">            if(preNode.left != null) queue.add(preNode.left);</span><br><span class="line">            if(preNode.right != null) queue.add(preNode.right);</span><br><span class="line">            if(nextNode == null) &#123;</span><br><span class="line">            //每一层的结束</span><br><span class="line">                queue.remove();</span><br><span class="line">                if(!queue.isEmpty())</span><br><span class="line">                    queue.add(null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 7 ms, 在Populating Next Right Pointers in Each Node II的Java提交中击败了51.00% 的用户<br>内存消耗 : 67.5 MB, 在Populating Next Right Pointers in Each Node II的Java提交中击败了5.12% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个二叉树&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct Node {
  int val;
  Node *l
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode116. 填充每个节点的下一个右侧节点指针</title>
    <link href="http://yoursite.com/2019/05/08/leetcode116.%20%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88/"/>
    <id>http://yoursite.com/2019/05/08/leetcode116. 填充每个节点的下一个右侧节点指针/</id>
    <published>2019-05-08T13:33:34.506Z</published>
    <updated>2019-05-08T13:33:31.701Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p><pre><code>struct Node {  int val;  Node *left;  Node *right;  Node *next;}</code></pre><p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p><p>初始状态下，所有 next 指针都被设置为 NULL。<br><strong>示例：</strong> <img src="https://img-blog.csdnimg.cn/20190508204149742.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDQ4NTc0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>解释：</strong> 给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>左结点的next指向右结点，然后递归调用他们的叶子结点即可。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public Node connect(Node root) &#123;</span><br><span class="line">        if(root == null) return null;</span><br><span class="line">        root.next = null;</span><br><span class="line">        connect(root.left, root.right);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    public void connect(Node left, Node right) &#123;</span><br><span class="line">        if(left == null) return;</span><br><span class="line">        left.next = right;</span><br><span class="line">        connect(left.left, left.right);</span><br><span class="line">        connect(left.right, right.left);</span><br><span class="line">        connect(right.left, right.right);</span><br><span class="line">        right.next = null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 1 ms, 在Populating Next Right Pointers in Each Node的Java提交中击败了86.12% 的用户<br>内存消耗 : 34.8 MB, 在Populating Next Right Pointers in Each Node的Java提交中击败了89.07% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：&lt;/p&gt;
&lt;pre&gt;&lt;co
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode114. 二叉树展开为链表</title>
    <link href="http://yoursite.com/2019/05/08/leetcode114.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2019/05/08/leetcode114. 二叉树展开为链表/</id>
    <published>2019-05-08T13:31:24.045Z</published>
    <updated>2019-05-08T13:33:25.150Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个二叉树，原地将它展开为链表。</p><p>例如，给定二叉树<br><img src="https://img-blog.csdnimg.cn/20190508194419597.png" alt="在这里插入图片描述"> 将其展开为：<br><img src="https://img-blog.csdnimg.cn/20190508194434133.png" alt="在这里插入图片描述"></p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>1.因为其左右子结点的关系很符合栈的先进后出原理，所以可以利用栈，把root右结点先push，然后push左结点；从栈中取出的栈顶元素，如果再push其右结点、左结点，接到root的最右个结点（记得把其左子树置null），直到栈为空即可。<br>2.使用递归方式求解。把左子树的结点接到root的右边，右子树接到左子树的右边，一直递归进行即可。</p><h2 id="思路1代码如下"><a href="#思路1代码如下" class="headerlink" title="思路1代码如下"></a>思路1代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public void flatten(TreeNode root) &#123;</span><br><span class="line">        if(root == null) return;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        //栈先进后出，所以先把右结点push，再push左结点</span><br><span class="line">        if(root.right != null) stack.push(root.right);</span><br><span class="line">        if(root.left != null) stack.push(root.left);</span><br><span class="line">        TreeNode p = root;</span><br><span class="line">        p.left = null;</span><br><span class="line">        while(!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode tn = stack.pop();</span><br><span class="line">            if(tn.right != null) stack.push(tn.right);</span><br><span class="line">            if(tn.left != null) stack.push(tn.left);</span><br><span class="line">            //把结点取出来接到p的右边，然后把取出来的结点的左子树去掉</span><br><span class="line">            p.right = tn;</span><br><span class="line">            p = p.right;</span><br><span class="line">            p.left = null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 4 ms, 在Flatten Binary Tree to Linked List的Java提交中击败了68.62% 的用户<br>内存消耗 : 35.3 MB, 在Flatten Binary Tree to Linked List的Java提交中击败了85.69% 的用户</p><h2 id="思路2代码如下"><a href="#思路2代码如下" class="headerlink" title="思路2代码如下"></a>思路2代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void flatten(TreeNode root) &#123;</span><br><span class="line">    helper(root);</span><br><span class="line">    &#125;</span><br><span class="line">    public TreeNode helper(TreeNode root) &#123;</span><br><span class="line">        if(root == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode left = helper(root.left);</span><br><span class="line">        TreeNode right = helper(root.right);</span><br><span class="line">        if(left != null)&#123;</span><br><span class="line">            root.right = left;</span><br><span class="line">            //left指针走到left&quot;链表&quot;的最后</span><br><span class="line">            while(left.right != null)&#123;</span><br><span class="line">                left = left.right;</span><br><span class="line">            &#125;</span><br><span class="line">            left.right = right;</span><br><span class="line">        &#125;</span><br><span class="line">        //去掉root的左子树</span><br><span class="line">        root.left = null;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果-1"><a href="#提交结果-1" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 2 ms, 在Flatten Binary Tree to Linked List的Java提交中击败了98.12% 的用户<br>内存消耗 : 34.7 MB, 在Flatten Binary Tree to Linked List的Java提交中击败了91.99% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个二叉树，原地将它展开为链表。&lt;/p&gt;
&lt;p&gt;例如，给定二叉树&lt;br&gt;&lt;img src=&quot;https://i
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>apache POI学习</title>
    <link href="http://yoursite.com/2019/05/08/apache%20POI%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2019/05/08/apache POI学习/</id>
    <published>2019-05-08T02:58:04.433Z</published>
    <updated>2019-05-08T10:18:16.040Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-导入包"><a href="#1-导入包" class="headerlink" title="1.导入包"></a>1.导入包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.poi&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;poi&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;3.11&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="2-编写测试代码"><a href="#2-编写测试代码" class="headerlink" title="2.编写测试代码"></a>2.编写测试代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import org.apache.poi.hssf.usermodel.HSSFSheet;</span><br><span class="line">import org.apache.poi.hssf.usermodel.HSSFWorkbook;</span><br><span class="line">import org.apache.poi.ss.usermodel.Cell;</span><br><span class="line">import org.apache.poi.ss.usermodel.Row;</span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">public class POITest &#123;</span><br><span class="line">@Test</span><br><span class="line">public void test() throws FileNotFoundException, IOException &#123;</span><br><span class="line">//定义导入excel文件的路径</span><br><span class="line">String filePath = &quot;D:\\区域导入测试数据.xls&quot;;</span><br><span class="line">//包装一个Excel文件对象</span><br><span class="line">HSSFWorkbook workbook = new HSSFWorkbook(new FileInputStream(new File(filePath)));</span><br><span class="line">//读取Excel文件中的第一个sheet标签</span><br><span class="line">HSSFSheet hssfSheet = workbook.getSheetAt(0);</span><br><span class="line">//遍历标签页中所有的行</span><br><span class="line">for(Row row: hssfSheet) &#123;</span><br><span class="line">//遍历标签行里的所有单元格</span><br><span class="line">for(Cell cell: row) &#123;</span><br><span class="line">//输出单元格中的数据</span><br><span class="line">String val = cell.getStringCellValue();</span><br><span class="line">System.out.print(val);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-运行结果"><a href="#3-运行结果" class="headerlink" title="3.运行结果"></a>3.运行结果</h2><p><img src="https://img-blog.csdnimg.cn/20190508105753168.png" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-导入包&quot;&gt;&lt;a href=&quot;#1-导入包&quot; class=&quot;headerlink&quot; title=&quot;1.导入包&quot;&gt;&lt;/a&gt;1.导入包&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;
      
    
    </summary>
    
      <category term="项目开发" scheme="http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode109. 有序链表转换二叉搜索树</title>
    <link href="http://yoursite.com/2019/05/07/leetcode109.%20%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>http://yoursite.com/2019/05/07/leetcode109. 有序链表转换二叉搜索树/</id>
    <published>2019-05-07T12:42:00.681Z</published>
    <updated>2019-05-07T12:41:54.984Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。</p><p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p><p><strong>示例:</strong></p><p>给定的有序链表： [-10, -3, 0, 5, 9],</p><p>一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：<br><img src="https://img-blog.csdnimg.cn/20190507171848340.png" alt="在这里插入图片描述"></p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>找出list的中间结点list[i]，以其作为根结点，然后把list[0,i)作为其左子树，list[i+1,n]为其右子树，递归建树即可。<br>在找list的中间结点时，我本来是用传入链表长度len参数的方法去找，然后又学习了一种查找list中间指针的方法—<strong>快慢指针</strong>的方法，就是使用2个指针mid,midNext每次<strong>mid走一步，midNext走2步</strong>，等到midNext为空或者midNext.next为空，mid即为中间结点。</p><h2 id="使用len参数的代码"><a href="#使用len参数的代码" class="headerlink" title="使用len参数的代码"></a>使用len参数的代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode sortedListToBST(ListNode head) &#123;</span><br><span class="line">        ListNode p = head;</span><br><span class="line">        int len = 0;</span><br><span class="line">        while (p != null)&#123;</span><br><span class="line">            len++;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        if(len == 0) return null;</span><br><span class="line">        return helper(head, len);</span><br><span class="line">    &#125;</span><br><span class="line">    public TreeNode helper(ListNode head, int len)&#123;</span><br><span class="line">        TreeNode root;</span><br><span class="line">        if(len == 1)&#123;</span><br><span class="line">            root = new TreeNode(head.val);</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line">        if(len &lt; 1)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode p = head;</span><br><span class="line">        //找到中间结点</span><br><span class="line">        for(int i = 1; i &lt; (len+1)/2; i ++)&#123;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        root = new TreeNode(p.val);</span><br><span class="line">        root.right = helper(p.next, len-(len+1)/2);</span><br><span class="line">        p.next = null;</span><br><span class="line">        //-1是去掉中间结点</span><br><span class="line">        root.left = helper(head, (len+1)/2-1);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用快慢指针的方法"><a href="#使用快慢指针的方法" class="headerlink" title="使用快慢指针的方法"></a>使用快慢指针的方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode sortedListToBST(ListNode head) &#123;</span><br><span class="line">        if(head == null || head.next == null)&#123;</span><br><span class="line">            return head == null ? null : new TreeNode(head.val);</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode pre = head, mid = head, midNext = head;</span><br><span class="line">        while(midNext != null &amp;&amp; midNext.next != null)&#123;</span><br><span class="line">            pre = mid;</span><br><span class="line">            mid = mid.next;</span><br><span class="line">            midNext = midNext.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre.next = null;</span><br><span class="line">        TreeNode root = new TreeNode(mid.val);</span><br><span class="line">        root.left = sortedListToBST(head);</span><br><span class="line">        root.right = sortedListToBST(mid.next);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p><img src="https://img-blog.csdnimg.cn/20190507172545934.png" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。&lt;/p&gt;
&lt;p&gt;本题中，一个高度平衡二叉树是
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode106. 从中序与后序遍历序列构造二叉树</title>
    <link href="http://yoursite.com/2019/05/07/leetcode106.%20%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2019/05/07/leetcode106. 从中序与后序遍历序列构造二叉树/</id>
    <published>2019-05-07T03:20:40.826Z</published>
    <updated>2019-05-07T03:20:56.515Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>根据一棵树的中序遍历与后序遍历构造二叉树。</p><p><strong>注意:</strong> 你可以假设树中没有重复的元素。</p><p>例如，给出</p><p>中序遍历 inorder = [9,3,15,20,7] 后序遍历 postorder = [9,15,7,20,3] 返回如下的二叉树：<br><img src="https://img-blog.csdnimg.cn/20190507110245228.png" alt="在这里插入图片描述"></p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>跟使用前序遍历和中序遍历建树一样的思路，就是后序遍历的最后结点为根结点root而已。<br>这题我学习了leetcode上的一个小技巧，在遍历中序遍历的时候从尾遍历，提交结果就快了近10倍，可能是用例问题 <strong>？</strong></p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode buildTree(int[] inorder, int[] postorder) &#123;</span><br><span class="line">        int len = inorder.length;</span><br><span class="line">        if(len == 0) return null;</span><br><span class="line">        return helper(inorder,0,len, postorder,0,len);</span><br><span class="line">    &#125;</span><br><span class="line">    public TreeNode helper(int[] inorder, int inStart, int inEnd, int[] postorder, int postStart, int postEnd) &#123;</span><br><span class="line">        if(postEnd == 0) return null;</span><br><span class="line">        TreeNode root = null;</span><br><span class="line">        int rootVal = postorder[postEnd-1];</span><br><span class="line">        for(int i = inEnd-1; i &gt;= inStart; i --)&#123;</span><br><span class="line">            if(inorder[i] == rootVal)&#123;</span><br><span class="line">                root = new TreeNode(rootVal);</span><br><span class="line">                root.left = helper(inorder, inStart, i, postorder, postStart, postStart+i-inStart);</span><br><span class="line">                root.right = helper(inorder, i+1, inEnd, postorder, postStart+i-inStart, postEnd-1);</span><br><span class="line">                return root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p>成功<br>显示详情<br>执行用时 : 3 ms, 在Construct Binary Tree from Inorder and Postorder Traversal的Java提交中击败了97.97% 的用户<br>内存消耗 : 35.3 MB, 在Construct Binary Tree from Inorder and Postorder Traversal的Java提交中击败了99.05% 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;根据一棵树的中序遍历与后序遍历构造二叉树。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt; 你可以假设树中
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
</feed>
